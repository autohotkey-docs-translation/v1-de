<!DOCTYPE HTML>
<html>
<head>
<title>Object</title>
<meta name="keywords" content="Objekt">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
    <h1>Object</h1>
    <p>Alle internen Methoden von Objekten, die mit <a href="../Objects.htm#Usage_Associative_Arrays">Object()</a> oder <code>{}</code> erstellt wurden, k&ouml;nnen entweder als regul&auml;re Funktionen oder als Methoden aufgerufen werden:</p>
    <pre>Ergebnis := Object.Methode(Parameter)</pre>
    <p>Mit so einem Methodenaufruf kann jedes Objekt sein eigenes Verhalten f&uuml;r diese Methode umsetzen.  Wenn ein Objekt allerdings eine interne Methode &uuml;berschreibt, muss das Objekt irgendwie auf die urspr&uuml;ngliche Funktionalit&auml;t zur&uuml;ckgreifen. Mithilfe der folgenden Funktionsform kann das erreicht werden:</p>
    <pre>Ergebnis := ObjMethod(Objekt, Parameter)</pre>
    <p>Der direkte Aufruf der Funktion ist ein wenig schneller, da der Name bei der Ladezeit aufgel&ouml;st wird, jedoch ist die Syntax nicht gerade intuitiv.  Jedes implementierte benutzerdefinierte Verhalten vom Objekt wird umgangen, daher sollte diese Funktionen nur vom Objekt selbst verwendet werden.</p>
    <div class="methodShort" id="Insert">
      <h2>Insert <span class="ver">[AHK_L 31+]</span></h2>
      <p>F&uuml;gt Schl&uuml;ssel-Wert-Paare in das Objekt ein und passt gegebenenfalls automatisch vorhandene Schl&uuml;ssel an.</p>
      <pre class="Syntax">Object.Insert(Index, Wert1 [, Wert2, ... ... Wert<i>N</i> ])
Object.Insert(Wert)
Object.Insert(Schl&uuml;ssel, Wert)</pre>
      <table class="info">
        <tr>
          <td style="width: 15%;">Index</td>
          <td style="width: 85%;">Ein Integer-Schl&uuml;ssel, der bei Wert1 eingef&uuml;gt wird. Nachfolgende Werte werden bei Index+1, Index+2 und so weiter eingef&uuml;gt.<br>
            Falls weggelassen, gilt standardm&auml;&szlig;ig <code>MaxIndex()="" ? 1 : MaxIndex() + 1</code>.</td>
        </tr>
        <tr>
          <td>Schl&uuml;ssel</td>
          <td>Ein String oder Objektschl&uuml;ssel.  Wenn der Schl&uuml;ssel bereits vorhanden ist,  wird sein Wert &uuml;berschrieben.</td>
        </tr>
        <tr>
          <td>Wert</td>
          <td>Ein String, eine Zahl oder ein Objekt.</td>
        </tr>
        <tr>
          <td><b>R&uuml;ckgabe</b></td>
          <td>Der Wert ist bei Erfolg <i>wahr</i> oder bei Misserfolg ein leerer String, wenn das Script nicht genug Arbeitsspeicher hat.</td>
        </tr>
      </table>
      <h3>Bemerkungen</h3>
      <p>Beachtet, dass diese Methode den <a href="../Objects.htm#Meta_Functions">__Set</a>-Mechanismus und das Sonderverhalten des <a href="../Objects.htm#Custom_Objects">base</a>-Schl&uuml;ssels umgeht.  Zum Beispiel bewirkt <code>Object.Insert("base","")</code>, dass <code>Object.base</code> einen leeren String anstelle des echten base-Objekts zur&uuml;ckgibt, wobei andere Operationen nicht daran gehindert werden, die Meta-Funktionen des Objekts auszul&ouml;sen.</p>
    </div>
    <div class="methodShort" id="Remove">
      <h2>Remove <span class="ver">[AHK_L 31+]</span></h2>
      <p>Entfernt Schl&uuml;ssel-Wert-Paare von einem Objekt.</p>
      <pre class="Syntax">Object.Remove(ErsterSchl&uuml;ssel, LetzterSchl&uuml;ssel)</pre>
      <table class="info">
        <tr>
          <td style="width: 15%;">ErsterSchl&uuml;ssel, LetzterSchl&uuml;ssel</td>
          <td style="width: 85%;">Eine Reihe von Integer- oder String-Schl&uuml;sseln, die entfernt werden.  Wenn beide Schl&uuml;ssel Integer sind, wird jeder Integer-Schl&uuml;ssel gr&ouml;&szlig;er als <i>LetzterSchl&uuml;ssel</i> um <code>(LetzterSchl&uuml;ssel - ErsterSchl&uuml;ssel + 1)</code> verringert, um einen typischen numerisch indizierten Array zu emulieren.  Beide Schl&uuml;ssel m&uuml;ssen vom gleichen Typ sein (Integer oder String).</td>
        </tr>
        <tr>
          <td><b>R&uuml;ckgabe</b></td>
          <td>Die tats&auml;chliche Anzahl von Schl&uuml;ssel-Wert-Paaren, die erfolgreich entfernt wurden; eine 0, falls keine Schl&uuml;ssel gefunden wurden; oder bei Misserfolg ein leerer String.</td>
        </tr>
      </table>
      <pre class="Syntax" style="margin-top:15px">Object.Remove(Schl&uuml;ssel = <i>MaxIndex()</i>)</pre>
      <table class="info">
        <tr>
          <td style="width: 15%;">Schl&uuml;ssel</td>
          <td style="width: 85%;">Beliebiger g&uuml;ltiger Schl&uuml;ssel.  Falls weggelassen, gilt standardm&auml;&szlig;ig der h&ouml;chste vorhandene Integer-Schl&uuml;ssel; falls keine vorhanden sind, wird nichts entfernt. Vorhandene Schl&uuml;ssel werden angepasst, als ob <code>Remove(Schl&uuml;ssel, Schl&uuml;ssel)</code> verwendet wurde.</td>
        </tr>
        <tr>
          <td><b>R&uuml;ckgabe</b></td>
          <td>Der entfernte Wert, ansonsten ein leerer String.</td>
        </tr>
      </table>
      <pre class="Syntax" style="margin-top:15px">Object.Remove(IntSchl&uuml;ssel, "")</pre>
      <p><span class="ver">[AHK_L 61+]:</span> Entfernt einen Integer-Schl&uuml;ssel und gibt seinen Wert zur&uuml;ck, jedoch sind andere Integer-Schl&uuml;ssel nicht davon betroffen.</p>
    </div>
    <div class="methodShort" id="MinMaxIndex">
      <h2>MinIndex / MaxIndex <span class="ver">[AHK_L 31+]</span></h2>
      <pre class="Syntax">MinIndex := Object.MinIndex()
MaxIndex := Object.MaxIndex()</pre>
      <p>Sobald mindestens ein Integer-Schl&uuml;ssel vorhanden ist, wird MinIndex den niedrigsten und MaxIndex den h&ouml;chsten Schl&uuml;ssel zur&uuml;ckgeben.  Ansonsten wird ein leerer String zur&uuml;ckgegeben.</p>
    </div>
    <div class="methodShort" id="SetCapacity">
      <h2>SetCapacity <span class="ver">[AHK_L 31+]</span></h2>
      <p>Passt die Kapazit&auml;t eines Objekts oder eins seiner Felder an.</p>
      <pre class="Syntax">Object.SetCapacity(Elementmaximum)
Object.SetCapacity(Schl&uuml;ssel, Bytegr&ouml;&szlig;e)</pre>
      <table class="info">
        <tr>
          <td style="width: 15%;">Elementmaximum</td>
          <td style="width: 85%;">Die maximale Anzahl von Schl&uuml;ssel-Wert-Paaren, die das Objekt aufnehmen kann, bevor es automatisch erweitert werden muss.  Wenn dieser Parameterwert kleiner als die aktuelle Anzahl ist, wird das Objekt verkleinert, damit es passt.</td>
        </tr>
        <tr>
          <td>Schl&uuml;ssel</td>
          <td>Beliebiger g&uuml;ltiger Schl&uuml;ssel.</td>
        </tr>
        <tr>
          <td>Bytegr&ouml;&szlig;e</td>
          <td>Die neue String-Zwischenspeicher-Gr&ouml;&szlig;e des Feldes in Bytes, ohne den 0-Terminator.  Falls das Feld noch nicht vorhanden ist, wird es erstellt.  Falls <i>Bytegr&ouml;&szlig;e</i> eine 0 ist, wird der Zwischenspeicher freigegeben, aber das leere Feld nicht entfernt.  Wenn <i>Bytegr&ouml;&szlig;e</i> kleiner als die aktuelle Gr&ouml;&szlig;e ist, werden &uuml;bersch&uuml;ssige Daten gek&uuml;rzt; ansonsten werden alle vorhandenen Daten beibehalten.</td>
        </tr>
        <tr>
          <td><b>R&uuml;ckgabe</b></td>
          <td>Die neue Kapazit&auml;t bei Erfolg, ansonsten ein leerer String.</td>
        </tr>
      </table>
    </div>
    <div class="methodShort" id="GetCapacity">
      <h2>GetCapacity <span class="ver">[AHK_L 31+]</span></h2>
      <pre class="Syntax">Elementmaximum := Object.GetCapacity()
Bytegr&ouml;&szlig;e := Object.GetCapacity(Schl&uuml;ssel)</pre>
      <p>Gibt die Kapazit&auml;t eines Objekts oder eins seiner Felder zur&uuml;ck.</p>
    </div>
    <div class="methodShort" id="GetAddress">
      <h2>GetAddress <span class="ver">[AHK_L 31+]</span></h2>
      <pre class="Syntax">Ptr := Object.GetAddress(Schl&uuml;ssel)</pre>
      <p>Gibt die aktuelle String-Zwischenspeicher-Adresse des Feldes zur&uuml;ck, falls vorhanden.</p>
    </div>
    <div class="methodShort" id="NewEnum">
      <h2>NewEnum <span class="ver">[AHK_L 49+]</span></h2>
      <pre class="Syntax">Enum := Object._NewEnum()</pre>
      <p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zur&uuml;ck, um Schl&uuml;ssel-Wert-Paare des Objekts zu enumerieren.</p>
    </div>
    <div class="methodShort" id="HasKey">
      <h2>HasKey <span class="ver">[AHK_L 53+]</span></h2>
      <pre class="Syntax">Object.HasKey(Schl&uuml;ssel)</pre>
      <p>Gibt wahr zur&uuml;ck, wenn der <i>Schl&uuml;ssel</i> mit einem Wert (auch "") innerhalb des <i>Objekts</i> verbunden ist, ansonsten falsch.</p>
    </div>
    <div class="methodShort" id="Clone">
      <h2>Clone <span class="ver">[AHK_L 60+]</span></h2>
      <pre class="Syntax">Klon := Object.Clone()</pre>
      <p>Gibt eine oberfl&auml;chliche Kopie des Objekts zur&uuml;ck.</p>
    </div>
  </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>
