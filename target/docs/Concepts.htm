<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Konzepte und Konventionen | AutoHotkey v1</title>
<meta name="description" content="Erfahren Sie mehr über einige allgemeine Konzepte und Konventionen, die von AutoHotkey verwendet werden, wobei der Schwerpunkt eher auf Erklärungen als auf Code liegt." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
</head>
<body>
<h1>Konzepte und Konventionen</h1>
<p>Dieses Dokument behandelt einige allgemeine Konzepte und Konventionen, die von AutoHotkey verwendet werden, wobei der Schwerpunkt eher auf Erklärungen als auf Code liegt. Es wird nicht vorausgesetzt, dass der Leser Vorkenntnisse in Scripting oder Programmierung hat, aber er sollte offen für neue technische Begriffe sein.</p>
<p>Genauere Informationen zur Syntax finden Sie unter <a href="Language.htm">Skriptsprache</a>.</p>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#values">Werte</a>
  <ul>
    <li><a href="#strings">Zeichenketten (Strings)</a></li>
    <li><a href="#numbers">Zahlen</a></li>
    <li><a href="#boolean">Boolesche Werte</a></li>
    <li><a href="#nothing">Nichts</a></li>
    <li><a href="#objects">Objekte</a></li>
    <li><a href="#object-protocol">Objektorientierte Schnittstelle</a></li>
  </ul></li>
  <li><a href="#variables">Variablen</a>
  <ul>
    <li><a href="#uninitialized-variables">Uninitialisierte Variablen</a></li>
    <li><a href="#built-in-variables">Interne Variablen</a></li>
    <li><a href="#environment-variables">Umgebungsvariablen</a></li>
    <li><a href="#caching">Caching</a></li>
  </ul></li>
  <li><a href="#functions">Funktionen/Befehle</a></li>
  <li><a href="#control-flow">Kontrollfluss</a></li>
  <li><a href="#details">Details</a>
  <ul>
    <li><a href="#string-encoding">Zeichenkettenkodierung</a></li>
    <li><a href="#pure-numbers">Reine Zahlen</a></li>
    <li><a href="#names">Namen</a></li>
    <li><a href="#variable-references">Variablenreferenzen vs. Werte</a></li>
    <li><a href="#references-to-objects">Objektreferenzen</a></li>
  </ul></li>
</ul>
<!-- TODO:
Scope/declarations
Technical terms: dynamic, default
Classes
Exception handling
-->

<h2 id="values">Werte</h2>
<p>Ein <em>Wert</em> repräsentiert eine einzelne Information innerhalb eines Programms. Zum Beispiel wäre das der Name einer zu sendenden Taste oder eines zu startenden Programms, die Anzahl der Tastendrücke, der Titel eines zu aktivierenden Fensters, oder was auch immer innerhalb des Programms oder Skripts eine Bedeutung hat.</p>
<p>AutoHotkey unterstützt folgende Typen von Werten:</p>
<ul>
  <li><a href="#strings">Zeichenketten</a> (Strings)</li>
  <li><a href="#numbers">Zahlen</a> (Integer und Floating-Point-Zahlen)</li>
  <li><a href="#objects">Objekte</a></li>
</ul>
<p>Einige andere verwandte Konzepte:</p>
<ul>
  <li><a href="#boolean">Boolesche Werte</a></li>
  <li><a href="#nothing">Nichts</a></li>
</ul>

<h3 id="strings">Zeichenketten (Strings)</h3>
<p>Eine <em>Zeichenkette</em> ist einfach nur Text. Jede Zeichenkette ist eigentlich eine Sequenz, Folge oder <em>Kette</em> von Zeichen. Sie kann aber auch als eine einzelne Entität betrachtet werden. Die <em>Länge</em> einer Zeichenkette entspricht der Anzahl der Zeichen in der Sequenz, während die <em>Position</em> eines Zeichens innerhalb der Zeichenkette lediglich die fortlaufende Nummer dieses Zeichens ist. Gemäß der Konvention von AutoHotkey befindet sich das erste Zeichen auf Position 1.</p>
<p id="numeric-strings"><strong>Numerische Zeichenketten:</strong> Eine Kette von Zahlen (oder von anderen unterstützten <a href="#numbers">Zahlenformaten</a>) wird automatisch als Zahl interpretiert, wenn eine mathematische Operation oder ein Vergleich dies erfordert. In AutoHotkey v1 werden Vergleiche numerisch durchgeführt, wenn beide Werte rein numerisch oder numerische Zeichenketten sind. Eine in Anführungszeichen gesetzte Zeichenkette (oder das Ergebnis einer Verkettung mit einer in Anführungszeichen gesetzten Zeichenkette) wird allerdings nie als numerisch gewertet, wenn sie direkt in einem Ausdruck verwendet wird.</p>
<p>Wie literaler (direkt geschriebener) Text in einem Skript geschrieben werden sollte, hängt vom Kontext ab. Weitere Informationen finden Sie unter <a href="Language.htm#legacy-syntax">Legacy-Syntax</a> und <a href="Language.htm#strings">Zeichenketten (in Ausdrücken)</a>.</p>
<p>Eine genauere Erklärung der Funktionsweise von Zeichenketten finden Sie unter <a href="#string-encoding">Zeichenkettenkodierung</a>.</p>

<h3 id="numbers">Zahlen</h3>
<p>AutoHotkey unterstützt folgende Zahlenformate:</p>
<ul>
  <li>Dezimale Integer (ganze Zahlen), wie z.B. <code>123</code>, <code>00123</code> oder <code>-1</code>.</li>
  <li>Hexadezimale Integer, wie z.B. <code>0x7B</code>, <code>0x007B</code> oder <code>-0x1</code>.</li>
  <li>Dezimale Floating-Point-Zahlen (Gleitkommazahlen), wie z.B. <code>3.14159</code>.</li>
</ul>
<p>Hexadezimalzahlen müssen mit dem <code>0x</code>- oder <code>0X</code>-Präfix beginnen, sofern in der Dokumentation nichts anderes angegeben ist. Dieses Präfix muss nach einem Vorzeichen wie <code>+</code> oder <code>-</code>, falls vorhanden, und vor führenden Nullen stehen. Zum Beispiel ist <code>0x001</code> gültig, aber nicht <code class="no-highlight">000x1</code>.</p>
<p>Zahlen, die mit einem Dezimalpunkt geschrieben werden, gelten immer als Floating-Point-Zahlen, auch wenn die Dezimalstelle eine Null ist. Zum Beispiel sind <code>42</code> und <code>42.0</code> in der Regel gleich, aber nicht immer. Die wissenschaftliche Schreibweise wird ebenfalls erkannt, aber nur, wenn ein Dezimalpunkt vorhanden ist (z.B. <code>1.0e4</code> und <code>-2.1E-4</code>).</p>
<p>Das Dezimaltrennzeichen ist immer ein Punkt, auch wenn in den Ländereinstellungen des Benutzers ein Komma angegeben ist.</p>
<p>Wenn eine Zahl in eine Zeichenkette umgewandelt wird, wird sie entsprechend dem aktuellen <a href="lib/SetFormat.htm#remarks">Integer- oder Float-Format</a> formatiert. Obwohl der <a href="lib/SetFormat.htm">SetFormat</a>-Befehl verwendet werden kann, um das aktuelle Format zu ändern, sollte besser die <a href="lib/Format.htm">Format</a>-Funktion zum Formatieren einer Zeichenkette verwendet werden. Floating-Point-Zahlen können auch mit der <a href="lib/Math.htm#Round">Round</a>-Funktion formatiert werden.</p>
<p>Details über den Bereich und die Genauigkeit von numerischen Werten finden Sie unter <a href="#pure-numbers">Reine Zahlen</a>.</p>

<h3 id="boolean">Boolesche Werte</h3>
<p>Ein <em>boolescher</em> Wert kann entweder <em>True</em> (wahr) oder <em>False</em> (falsch) sein. Boolesche Werte werden verwendet, um etwas wiederzugeben, das exakt zwei mögliche Zustände hat, wie z.B. die <em>Wahrheit</em> eines Ausdrucks. Der Ausdruck <code>(x &lt;= y)</code> ist z.B. <em>True</em>, wenn x kleiner gleich y ist. Ein boolescher Wert könnte auch <em>Yes</em> oder <em>No</em>, <em>On</em> oder <em>Off</em>, <em>Down</em> oder <em>Up</em> (z.B. bei <a href="lib/GetKeyState.htm#function">GetKeyState</a>) und so weiter repräsentieren.</p>
<p>AutoHotkey hat keinen spezifischen booleschen Wertetyp und verwendet daher den Integerwert <code>0</code> für False und <code>1</code> für True. In Fällen, wo der Wert entweder True oder False sein muss, wird eine leere Zeichenkette oder 0 als False und alle anderen Werte als True angesehen. (Objekte werden immer als True angesehen.)</p>
<p>Die Wörter <code>True</code> und <code>False</code> sind <a href="#built-in-variables">interne Variablen</a>, die 1 bzw. 0 enthalten. Diese können verwendet werden, um die Lesbarkeit eines Skripts zu verbessern.</p>

<h3 id="nothing">Nichts</h3>
<p>AutoHotkey hat keinen Wert, der eindeutig <em>nichts</em>, <em>null</em>, <em>nil</em> oder <em>undefined</em> repräsentiert, wie es in anderen Sprachen der Fall ist. Stattdessen hat oft eine leere Zeichenkette (eine Zeichenkette mit der Länge 0) diese Bedeutung.</p>
<p>Wenn eine <a href="#variables">Variable</a> oder ein Parameter als "leer" bezeichnet wird, ist in der Regel eine leere Zeichenkette (eine Zeichenkette mit der Länge 0) gemeint.</p>

<h3 id="objects">Objekte</h3>
<p>Grundsätzlich können Objekte auf zwei verschiedene Arten betrachtet werden:</p>
<ul>
  <li>Ein Objekt enthält eine Gruppe von Werten, die wie ein einzelner Wert behandelt werden kann. Ein Objekt kann z.B. ein <em>Array</em> oder eine Sequenz von Elementen sein, oder ein Satz verwandter Werte, wie z.B. die X- und Y-Koordinate einer Position auf dem Bildschirm. Objekte können verwendet werden, um komplexe Strukturen zu bilden, indem sie mit anderen Objekten kombiniert werden.</li>
  <li>Ein Objekt kann ein <em>Ding</em>, einen <em>Dienst</em> oder etwas anderes darstellen und dem Skript die Möglichkeit geben, mit diesem Ding oder Dienst zu interagieren. Ein <em>BankAccount</em>-Objekt kann bspw. Eigenschaften wie Kontonummer, aktueller Kontostand und Kontoinhaber sowie Methoden zum Abheben oder Einzahlen eines Betrags haben.</li>
</ul>
<p>Die richtige Verwendung von Objekten (und insbesondere <a href="Objects.htm#Custom_Classes">Klassen</a>) kann zu <em>modularem</em> und <em>wiederverwendbarem</em> Code führen. Modularer Code ist in der Regel leichter zu testen, zu verstehen und zu pflegen. So kann z.B. ein Abschnitt des Codes verbessert oder geändert werden, ohne dass die Details anderer Abschnitte bekannt sein müssen und ohne dass entsprechende Änderungen an diesen Abschnitten vorgenommen werden müssen. Wiederverwendbarer Code spart Zeit, da das Schreiben und Testen von Code für gleiche oder ähnliche Aufgaben entfällt.</p>
<p>Beim Zuweisen eines Objektes an eine <a href="#variables">Variable</a>, wie in <code>meinObj := {}</code>, wird nicht das Objekt selbst hinterlegt, sondern eine <a href="#references-to-objects"><em>Referenz</em></a> zu diesem Objekt. Kopiert man diese Variable, wie in <code>deinObj := meinObj</code>, wird eine neue Referenz zum <em>selben</em> Objekt erstellt. Eine Änderung wie <code>meinObj.ans := 42</code> würde sich sowohl in <code>meinObj.ans</code> als auch in <code>deinObj.ans</code> widerspiegeln, da beide auf dasselbe Objekt verweisen. <code>meinObj := Object()</code> wirkt sich jedoch nur auf die <em>meinObj</em>-Variable aus, nicht auf die <em>deinObj</em>-Variable, die immer noch auf das ursprüngliche Objekt verweist.</p>

<h3 id="object-protocol">Objektorientierte Schnittstelle</h3>
<p class="note">Dieser Abschnitt baut auf folgenden Konzepten auf, die in späteren Abschnitten behandelt werden: <a href="#variables">Variablen</a>, <a href="#functions">Funktionen</a></p>
<p>Objekte arbeiten nach dem Prinzip der <em>Meldungsübermittlung</em>. Sie wissen nicht, wo sich der Code oder die Variablen eines Objekts tatsächlich befinden, also müssen Sie eine Meldung an das Objekt übergeben, wie z.B. "gib mir <em>foo</em>" oder "gehe zu <em>bar</em>", und sich darauf verlassen, dass das Objekt auf die Meldung reagiert. Objekte in AutoHotkey unterstützen die folgenden grundlegenden Meldungen:</p>
<ul>
  <li><strong>Get</strong> - Abrufen eines Wertes.</li>
  <li><strong>Set</strong> - Setzen eines Wertes via <code>:=</code>.</li>
  <li><strong>Call</strong> - Aufrufen einer Methode via <code>()</code>.</li>
</ul>
<p>Jede Meldung kann optional einen oder mehrere <a href="#parameters">Parameter</a> enthalten (und bei <strong>Set</strong> den Wert). Normalerweise gibt es mindestens einen Parameter. Dieser Parameter wird als Name einer Eigenschaft oder Methode, als Schlüssel oder als Array-Index interpretiert, je nachdem, welches Objekt vorliegt und wie man es verwendet. Die Parameter einer Meldung können auf drei verschiedene Weisen angegeben werden: <code>.Name</code>, <code>[Params]</code> und <code>(Params)</code>, wobei <em>Name</em> ein direkt geschriebener <a href="#names">Name oder Identifikator</a>, und <em>Parameter</em> eine Liste von Parametern (als Teilausdrücke) ist, die leer sein kann (<code>[]</code> oder <code>()</code>).</p>
<p>Bei <strong>Get</strong> und <strong>Set</strong> können <code>.Name</code> und <code>[Parameter]</code> synonym verwendet oder kombiniert werden:</p>
<pre>meinObj[Param1, Param2, ..., ParamN]
meinObj.Name
meinObj.Name[Param2, ..., ParamN]
</pre>
<p>Bei <strong>Call</strong> können <code>.Name</code> und <code>[Parameter]</code> synonym verwendet werden, immer gefolgt von <code>(Parameter)</code>:</p>
<pre>meinObj.Name(Param2, ..., ParamN)
meinObj[Param1](Param2, ..., ParamN)
</pre>
<p>Beachten Sie, dass <code>Name</code>, falls vorhanden, zum ersten Parameter wird. <code>meinObj.Name</code> ist äquivalent zu <code>meinObj["Name"]</code>, während <code>meinObj.123</code> äquivalent zu <code>meinObj[123]</code> ist. Dies gilt für jeden Objekttyp, daher ist es jederzeit möglich, den Namen einer Eigenschaft oder Methode während der Skriptausführung zu ermitteln, anstatt ihn manuell in das Skript zu schreiben.</p>
<p>Obwohl <em>Name</em> oder <em>Param1</em> als erster Parameter gelten, ist zu bedenken, dass es sich dabei nur um <em>Meldungen</em> handelt und es dem Objekt freisteht, wie es damit umgeht. In einem Methodenaufruf wie dem oben gezeigten verwendet das Objekt normalerweise <em>Name</em> oder <em>Param1</em>, um zu identifizieren, welche Methode aufgerufen werden soll, und <em>Param2</em> und so weiter, um sie an die Methode zu übergeben. Somit wird <em>Param2</em> der erste offensichtliche Parameter der Methode.</p>
<p>Grundsätzlich hat <strong>Set</strong> die gleiche Bedeutung wie eine Zuweisung und verwendet daher den gleichen Operator:</p>
<pre>meinObj[Param1, Param2, ..., ParamN] := Wert
meinObj.Name := Wert
meinObj.Name[Param2, ..., ParamN] := Wert
</pre>
<p>Derzeit gibt es für <strong>Set</strong> auch eine "hybride" Syntax, auf die man aber besser verzichten sollte:</p>
<pre>meinObj.Name(Param2, ..., ParamN) := Wert
</pre>
<p>Technisch gesehen wird der <code>Wert</code> als letzter Parameter der <em>Set</em>-Nachricht übergeben; dieses Detail ist jedoch für Skriptautoren fast nie relevant. Grundsätzlich kann man sich das so vorstellen, dass "der Wert zugewiesen wird".</p>

<h2 id="variables">Variablen</h2>
<p>Mithilfe einer Variable können Sie einen Namen als Platzhalter für einen Wert verwenden. Sie können diesen Wert jederzeit während der Skriptausführung ändern. Ein Hotkey könnte z.B. eine Variable <code>press_count</code> verwenden, um zu zählen, wie oft er gedrückt wurde, und jedes Mal eine andere Taste senden, wenn <code>press_count</code> ein Vielfaches von 3 ist (jeder dritte Tastendruck). Eine Variable, der nur einmal ein Wert zugewiesen wird, kann ebenfalls nützlich sein. Zum Beispiel können Sie die Variable <code>WebBrowserTitle</code> nutzen, um die Aktualisierung Ihres Codes zu erleichtern, wenn Sie Ihren bevorzugten Webbrowser ändern oder wenn sich der <a href="misc/WinTitle.htm">Titel</a> oder die <a href="misc/WinTitle.htm#ahk_class">Fensterklasse</a> aufgrund eines Software-Updates ändert.</p>
<p>In AutoHotkey werden Variablen erstellt, sobald sie verwendet werden. Jede Variable ist <em>nicht</em> dauerhaft auf einen einzigen <a href="#values">Datentyp</a> beschränkt, sondern kann stattdessen einen Wert beliebigen Typs enthalten: Zeichenkette, Zahl oder Objekt. Jede Variable ist zunächst leer; d.h. jede neue Variable enthält eine leere Zeichenkette, bis ihr ein anderer Wert zugewiesen wird.</p>
<p>Eine Variable hat drei Hauptaspekte:</p>
<ul>
  <li>Der <em>Name</em> der Variable.</li>
  <li>Die Variable selbst.</li>
  <li>Der <em>Wert</em> der Variable.</li>
</ul>
<p>Für Variablennamen gelten einige Einschränkungen - Einzelheiten finden Sie unter <a href="#names">Namen</a>. Kurz gesagt ist es am sichersten, Namen zu verwenden, die aus ASCII-Buchstaben (nicht Groß-/Kleinschreibung-sensitiv), Ziffern und Unterstrichen bestehen, und Namen zu vermeiden, die mit einer Ziffer beginnen.</p>
<p>Ein Variablenname hat einen <strong><em>Gültigkeitsbereich</em></strong>, der definiert, wo im Code dieser Name verwendet werden kann, um auf diese bestimmte Variable zu verweisen; mit anderen Worten, wo die Variable <em>sichtbar</em> ist. Wenn eine Variable in einem bestimmten Gültigkeitsbereich nicht sichtbar ist, kann derselbe Name auf eine andere Variable verweisen. Beide Variablen können gleichzeitig existieren, aber nur eine ist für jeden Teil des Skripts sichtbar. <a href="Functions.htm#Global">Globale Variablen</a> sind im "globalen Bereich" (d.h. außerhalb von Funktionen) sichtbar, müssen aber in der Regel <a href="Functions.htm#Global">deklariert</a> werden, um innerhalb einer Funktion sichtbar zu sein. <a href="Functions.htm#Local">Lokale Variablen</a> sind nur innerhalb der Funktion sichtbar, die sie erzeugt hat.</p>
<p>Eine Variable kann als Behälter oder Speicherort für einen Wert betrachtet werden. In der Dokumentation wird der Wert einer Variable häufig als <em>Inhalt der Variable</em> bezeichnet. Bei <code>x := 42</code> kann man auch sagen, dass die Variable x die Zahl 42 als Wert hat oder dass der Wert von x eine 42 ist.</p>
<p>Es ist wichtig zu wissen, dass eine Variable und ihr Wert nicht dasselbe sind. Zum Beispiel könnten wir sagen: "<code>meinArray</code> ist ein Array", aber was wir wirklich meinen, ist, dass meinArray eine Variable ist, die eine Referenz zu einem Array enthält. Wir nehmen eine Abkürzung, indem wir den Namen der Variable verwenden, um auf ihren Wert zu verweisen, aber "meinArray" ist eigentlich nur der Name der Variable; das Array-Objekt weiß nicht, dass es einen Namen hat, und könnte von vielen verschiedenen Variablen (bzw. Namen) referenziert werden.</p>

<h3 id="uninitialized-variables"><span id="uninitialised-variables"></span>Uninitialisierte Variablen</h3>
<p>Eine Variable zu <em>initialisieren</em> bedeutet, ihr einen Startwert zuzuweisen. Obwohl das Programm alle Variablen automatisch initialisiert (standardmäßig mit einer leeren Zeichenkette), sollte ein Skript seine Variablen immer initialisieren, bevor es sie verwendet. Auf diese Weise kann jeder, der das Skript liest, sehen, welche Variablen das Skript verwenden wird und welche Startwerte sie erwartungsgemäß haben werden.</p>
<p>Normalerweise muss das Skript jede Variable initialisieren, die eine Zahl enthalten soll. Zum Beispiel wird <code>x := x + 1</code> nicht funktionieren, wenn x noch nie einen Wert zugewiesen bekommen hat, da die <em>leere Zeichenkette</em> als nicht-numerisch angesehen wird. Das Skript sollte ihr einen Startwert zuweisen, wie z.B. <code>x := 0</code>. Es gibt Fälle, wo leere Werte als 0 behandelt <em>werden</em>, aber man sollte sich besser nicht darauf verlassen.</p>
<p><a href="lib/IsSet.htm">IsSet</a> kann verwendet werden, um zu prüfen, ob eine Variable initialisiert wurde, z.B. um eine globale oder statische Variable bei der ersten Verwendung zu initialisieren.</p>
<p>Skriptautoren können die <a href="lib/_Warn.htm">#Warn</a>-Direktive nutzen, um uninitialisierte Variablen in einem Skript zu finden.</p>

<h3 id="built-in-variables">Interne Variablen</h3>
<p>Eine Vielzahl von Variablen sind fest in das Programm integriert und können normal referenziert werden. Solche Variablen, außer <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Scripts.htm#cmd">Befehlszeilenparameter</a>, sind schreibgeschützt, d.h. ihr Inhalt kann nicht geändert werden. Konventionsgemäß beginnen die meisten dieser Variablen mit dem Präfix <code>A_</code>, daher ist es am besten, dieses Präfix nicht für eigene Variablen zu verwenden.</p>
<p>Einige Variablen wie <a href="Variables.htm#KeyDelay">A_KeyDelay</a> und <a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a> spiegeln Einstellungen wider, die das Verhalten des Skripts steuern, und separate Werte für jeden <a href="misc/Threads.htm">Thread</a> aufbewahren. Dadurch können Subroutinen, die von neuen Threads gestartet werden (z.B. für Hotkeys, Menüs, Timer und so weiter), Einstellungen ändern, ohne andere Threads zu beeinflussen.</p>
<p>Einige spezielle Variablen werden nicht periodisch aktualisiert, sondern ihr Wert wird abgerufen oder berechnet, wenn das Skript auf die Variable verweist. Eine solche Variable ist zum Beispiel <a href="misc/Clipboard.htm">Clipboard</a>, die den aktuellen Inhalt der Zwischenablage abruft, oder <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a>, die die Anzahl der Millisekunden berechnet, die seit dem Drücken des Hotkeys vergangen sind.</p>
<p>Siehe auch: <a href="Variables.htm#BuiltIn">Liste von internen Variablen</a>.</p>

<h3 id="environment-variables">Umgebungsvariablen</h3>
<p>Umgebungsvariablen werden vom Betriebssystem verwaltet. Sie können sich eine Liste von Umgebungsvariablen anzeigen lassen, indem Sie SET in die Windows-Konsole eingeben und ENTER drücken.</p>
<p>Mit <a href="lib/EnvSet.htm">EnvSet</a> kann eine neue Umgebungsvariable erstellt oder der Inhalt einer vorhandenen Umgebungsvariable geändert werden. Solche Ergänzungen und Änderungen sind nur für das Skript sichtbar und werden vom Rest des Systems ignoriert. Allerdings erben alle Programme oder Skripte, die das Skript über <a href="lib/Run.htm">Run</a> oder <a href="lib/Run.htm">RunWait</a> startet, in der Regel eine Kopie der Umgebungsvariablen des übergeordneten Skripts.</p>
<p>Es wird empfohlen, dass alle neuen Skripte Umgebungsvariablen wie Path über <a href="lib/EnvGet.htm">EnvGet</a> abrufen:</p>
<pre>EnvGet, AusgabeVar, Path  <em>; Zur Erklärung siehe #NoEnv.</em></pre>
<p>Fehlt die <a href="lib/_NoEnv.htm">#NoEnv</a>-Direktive in einem Skript, wird beim Lesen einer leeren Variable stattdessen der Wert der Umgebungsvariable mit diesem Namen zurückgeben, falls eine solche existiert. Dies kann zu Verwirrung führen, daher wird empfohlen, dass alle neuen Skripte #NoEnv verwenden.</p>

<h3 id="caching">Caching</h3>
<p>Obwohl eine Variable üblicherweise dazu gedacht ist, einen einzelnen Wert zu enthalten, und dieser Wert einen bestimmten Typ (Zeichenkette, Zahl oder Objekt) hat, wandelt AutoHotkey automatisch zwischen Zahlen und Zeichenketten bei Fällen wie <code>meineZkette + 1</code> und <code>MsgBox %meineZahl%</code> um. Da solche Umwandlungen sehr häufig vorkommen können, wird jedes Mal, wenn eine Variable umgewandelt wird, das Ergebnis in der Variable <em>zwischengespeichert</em>.</p>
<p>Tatsächlich kann eine Variable gleichzeitig sowohl eine Zeichenkette als auch eine Zahl enthalten. Normalerweise verbessert das die Performanz des Skripts ohne Nachteile, aber wenn eine Variable sowohl eine Zahl als auch eine Zeichenkette enthält, ist sie dann eine Zahl oder eine Zeichenkette? Diese Mehrdeutigkeit führt in mindestens zwei Fällen zu unerwartetem Verhalten:</p>
<ol>
  <li>COM-Objekte. Um Parameter an ein COM-Objekt zu übergeben, muss das Programm den Inhalt der Variable in eine Zahl <em>oder</em> Zeichenkette umwandeln. Einige COM-Objekte lösen eine Ausnahme aus, wenn der falsche Wertetyp übergeben wird. Wenn eine Variable beide Wertetypen hat, wird die Zahl verwendet. Normalerweise führt das zum richtigen Ergebnis, manchmal aber auch nicht.</li>
  <li>Objekte haben nicht die Möglichkeit, gleichzeitig sowohl eine Zahl als auch eine Zeichenkette als Schlüssel oder Wert zu speichern. Da Zahlen speichereffizienter sind, wird, wenn eine Variable beide Wertetypen hat, die Zahl verwendet (außer bei Floating-Point-Zahlen, die als Schlüssel verwendet werden).</li>
</ol>
<p>Der Slow-Modus von <a href="lib/SetFormat.htm">SetFormat</a> bewirkt, dass beim Zuweisen einer reinen Zahl diese Zahl in eine Zeichenkette umgewandelt wird. Bei Integern wird die Zahl ebenfalls gespeichert, daher hat das keine negativen Auswirkungen außer auf die Performanz. Bei Floating-Point-Zahlen wird die Zahl nicht gespeichert, da SetFormat die Genauigkeit des Wertes beeinflusst und eventuell sogar alle Dezimalstellen wegkürzt. Mit anderen Worten, der Slow-Mode von SetFormat verhindert, dass reine Floating-Point-Zahlen in Variablen gespeichert werden.</p>
<p>Wenn man die Adresse einer Variable nimmt, wird der Wert der Variable direkt in eine Zeichenkette umgewandelt und das Caching deaktiviert, bis sich die Adresse der Variable ändert (was passiert, wenn sich ihre Kapazität ändert). Das liegt zum einen an der Abwärtskompatibilität und zum anderen daran, dass das Skript den Wert jederzeit indirekt über die Adresse ändern kann, was den Cache ungenau macht.</p>

<h3 id="Related">Siehe auch</h3>
<ul>
  <li><a href="Variables.htm#Intro">Variablen</a>: Grundlegende Verwendung und Beispiele.</li>
  <li><a href="Variables.htm#cap">Kapazität und Speicher von Variablen</a>: Einzelheiten über die Limitierungen.</li>
</ul>

<h2 id="functions">Funktionen/Befehle</h2>
<p>Eine <em>Funktion</em> oder ein <em>Befehl</em> ist das Werkzeug des Skripts, um <em>etwas zu tun</em>.</p>
<p>Im Grunde sind Funktionen und Befehle dasselbe, daher gelten für beide die hier beschriebenen Konzepte. Die lange Geschichte von AutoHotkey v1 und das Streben nach Abwärtskompatibilität haben jedoch zu einer Trennung zwischen <em>Befehlen</em>, die die Legacy-Syntax erfordern, und <em>Funktionen</em>, die die Ausdruckssyntax erfordern, geführt.</p>
<p>Befehle und Funktionen können viele verschiedene Zwecke haben. Einige Funktionen könnten nur eine einfache Berechnung durchführen, während andere sofort sichtbare Effekte erzielen, wie z.B. das Verschieben eines Fensters. Eine der Stärken von AutoHotkey ist die einfache Möglichkeit, andere Programme zu automatisieren und viele andere häufige Aufgaben durch einfaches Aufrufen einiger weniger Funktionen zu erledigen. Beispiele finden Sie in der <a href="lib/index.htm">Befehls- und Funktionsliste</a>.</p>
<p>In dieser Dokumentation werden einige gebräuchliche Wörter in einer Weise verwendet, die für jemanden ohne Vorkenntnisse nicht offensichtlich ist. Nachfolgend finden Sie einige dieser Wörter/Phrasen, die häufig im Zusammenhang mit Funktionen und Befehle verwendet werden:</p>
<dl>
  <dt id="call">Befehle oder Funktionen aufrufen</dt>
  <dd><p>Der <em>Aufruf</em> von Funktionen oder Befehlen bewirkt, dass das Programm diese startet, ausführt oder auswertet. Mit anderen Worten, ein <em>Funktionsaufruf</em> überträgt vorübergehend die Kontrolle vom Skript auf die Funktion. Wenn die Funktion ihren Zweck erfüllt hat, überträgt sie die Kontrolle via <em>Return</em> wieder auf das Skript. Das heißt, dass jeglicher Code nach dem Funktionsaufruf erst dann ausgeführt wird, wenn die Funktion ihr Ende erreicht hat.</p>
  <p>Es kann jedoch vorkommen, dass Funktionen oder Befehle abgeschlossen sind, bevor ihre Auswirkungen für den Benutzer sichtbar werden. Zum Beispiel kann der <a href="lib/Send.htm">Send</a>-Befehl seine Tastendrücke bereits <em>gesendet</em> haben, bevor die Tastendrücke ihr Ziel erreicht und die gewünschte Wirkung erzielt haben.</p></dd>
  <dt id="parameters">Parameter</dt>
  <dd><p>Normalerweise akzeptieren Befehle oder Funktionen einen oder mehrere <em>Parameter</em>, die angeben, wie oder womit sie agieren sollen. Jeder Parameter ist ein <a href="#values">Wert</a>, z.B. eine Zeichenkette oder Zahl. Die Parameter von <a href="lib/WinMove.htm">WinMove</a> legen z.B. fest, welches Fenster wohin verschoben werden soll. Parameter werden auch als <em>Argumente</em> bezeichnet. Gängige Abkürzungen sind <em>Param</em> und <em>Arg</em>.</p></dd>
  <dt id="pass-parameters">Parameter übergeben</dt>
  <dd><p>Parameter werden an eine Funktion oder an einen Befehl <em>übergeben</em>, d.h. für jeden Parameter der Funktion oder des Befehls ist beim Aufrufen ein Wert angegeben. Zum Beispiel können Sie den Namen einer Taste an <a href="lib/GetKeyState.htm">GetKeyState</a> <em>übergeben</em>, um festzustellen, ob diese Taste gedrückt gehalten wird.</p></dd>
  <dt id="return-a-value">Einen Wert zurückgeben</dt>
  <dd><p>Funktionen geben einen Wert über <em>Return</em> zurück, daher wird das Ergebnis der Funktion oft als <em>Rückgabewert</em> bezeichnet. Zum Beispiel gibt <a href="lib/StrLen.htm">StrLen()</a> die Anzahl der Zeichen zurück, die in einer Zeichenkette enthalten sind. Befehle geben ihr Ergebnis nicht direkt zurück, sondern speichern es in eine <a href="#variables">Variable</a>. Funktionen können das auch tun, wenn sie z.B. mehr als ein Ergebnis zurückgeben müssen.</p></dd>
</dl>
<p>Funktionen und Befehle erwarten normalerweise ihre Parameter in einer bestimmten Reihenfolge, daher hängt die Bedeutung der einzelnen Parameterwerte von ihrer Position in der kommagetrennten Parameterliste ab. Einige Parameter können weg bzw. leer gelassen werden - in diesem Fall aber kann das darauffolgende Komma nur weggelassen werden, wenn alle übrigen Parameter ebenfalls weggelassen werden. Zum Beispiel hat <a href="lib/ControlSend.htm">ControlSend</a> die folgende Syntax:</p>
<pre class="Syntax"><span class="func">ControlSend</span>, Steuerelement, Tasten <span class="optional">, FensterTitel, FensterText, AusnahmeTitel, AusnahmeText</span></pre>
<p>Die eckigen Klammern signalisieren, dass die darin enthaltenen Parameter optional sind (die Klammern selbst müssen im eigentlichen Code weggelassen werden). ControlSend ist jedoch nur dann sinnvoll, wenn <em>Tasten</em> und ggf. das Zielfenster angegeben sind. Zum Beispiel:</p>
<pre>ControlSend, Edit1, ^{Home}, A  <em>; Korrekt. Steuerelement ist angegeben.</em>
ControlSend, ^{Home}, A         <em>; Falsch: Parameter stimmen nicht überein.</em>
ControlSend,, ^{Home}, A        <em>; Korrekt. Steuerelement wurde weggelassen.</em>
</pre>

<h3 id="methods">Methoden</h3>
<p><em>Methoden</em> sind Funktionen, die zu einem bestimmten <a href="#objects">Objekt</a> gehören. Während es zum Beispiel nur eine Funktion namens <code>Send</code> geben kann, können mehrere Objekte eine Methode namens <code>Send</code> mit unterschiedlichem Effekt haben. Aus diesem Grund wird das Zielobjekt (das eine Variable oder ein Teilausdruck sein kann) nicht in der Parameterliste, sondern links neben dem Methodennamen angegeben. Weitere Informationen finden Sie unter <a href="#object-protocol">Objektorientierte Schnittstelle</a>.</p>

<h2 id="control-flow">Kontrollfluss</h2>
<p>Der <em>Kontrollfluss</em> ist die Reihenfolge, in der die einzelnen Anweisungen ausgeführt werden. Im Normalfall werden Anweisungen der Reihe nach von oben nach unten ausgeführt, aber dieses Verhalten kann mit einer Kontrollanweisung manipuliert werden, z.B. indem Anweisungen wiederholt ausgeführt werden, oder nur ausgeführt werden, wenn eine bestimmte Bedingung erfüllt ist.</p>
<dl>
  <dt id="statement">Anweisung</dt>
  <dd><p>Eine <em>Anweisung</em> ist einfach gesagt das kleinste eigenständige Element der Sprache, das eine ausführende Aktion ausdrückt. Anweisungen in AutoHotkey sind Befehle, Zuweisungen, Funktionsaufrufe und andere Ausdrücke. Direktiven, Labels (einschließlich Hotkeys und Hotstrings) und Deklarationen ohne Zuweisungen sind dagegen keine Anweisungen; sie werden nach dem Programmstart und vor dem <em>Ausführen</em> des Skripts abgearbeitet.</p></dd>
  <dt id="execute">Ausführen</dt>
  <dd><p>Ausführen, Durchführen, Auswerten, Umsetzen und so weiter. <em>Ausführen</em> hat grundsätzlich die gleiche Bedeutung wie im normalen Sprachgebrauch.</p></dd>
  <dt id="cf-body">Körper</dt>
  <dd><p>Der <em>Körper</em> einer Kontrollanweisung ist die Anweisung oder Anweisungsgruppe, zu der sie gehört. Zum Beispiel wird der Körper einer <a href="Language.htm#if-statement">if-Anweisung</a> nur ausgeführt, wenn eine bestimmte Bedingung erfüllt ist.</p></dd>
</dl>
<p>Schauen Sie sich zum Beispiel die folgenden Instruktionen an:</p>
<ol>
  <li>Öffne Notepad</li>
  <li>Warte, bis Notepad auf dem Bildschirm erscheint</li>
  <li>Schreibe "Hallo, Welt!"</li>
</ol>
<p>Wir machen einen Schritt nach dem anderen, und wenn dieser Schritt beendet ist, gehen wir zum nächsten Schritt über. So ähnlich erfolgt auch der Kontrollfluss in einem Programm oder Skript normalerweise von einer Anweisung zur nächsten. Was aber, wenn wir etwas in ein existierendes Notepad-Fenster schreiben wollen? Schauen Sie sich die folgenden überarbeiteten Instruktionen an:</p>
<ol>
  <li>Wenn Notepad nicht läuft:
<ol>
  <li>Öffne Notepad</li>
  <li>Warte, bis Notepad auf dem Bildschirm erscheint</li>
</ol>
</li>
  <li>Andernfalls:
<ol>
  <li>Aktiviere Notepad</li>
</ol>
</li>
  <li>Schreibe "Hallo, Welt!"</li>
</ol>
<p>Wir öffnen also entweder Notepad oder aktivieren Notepad, je nachdem, ob es bereits läuft. Punkt 1 ist eine <em>bedingte Anweisung</em>, auch bekannt als <em>if-Anweisung</em>, d.h. wir führen ihren <em>Körper</em> (Punkt 1.1 bis Punkt 1.2) nur aus, wenn eine Bedingung erfüllt ist. Punkt 2 ist eine <em>else-Anweisung</em>; wir führen ihren Körper (Punkt 2.1) nur aus, wenn die Bedingung einer vorherigen <em>if-Anweisung</em> nicht erfüllt ist. Je nach Bedingung erfolgt der <em>Kontrollfluss</em> auf eine von zwei Arten: Punkt 1 (if true) → Punkt 1.1 → Punkt 1.2 → Punkt 3; oder Punkt 1 (if false) → Punkt 2 (else) → Punkt 2.1 → Punkt 3.</p>
<p>Die obigen Instruktionen können in den folgenden Code umgewandelt werden:</p>
<pre>if (not WinExist("ahk_class Notepad"))
{
    Run Notepad
    WinWait ahk_class Notepad
}
else
    WinActivate ahk_class Notepad
Send Hallo`, Welt{!}
</pre>
<p>In unseren schriftlichen Instruktionen haben wir Einrückungen und Nummerierungen verwendet, um die Anweisungen zu gruppieren. Skripte funktionieren etwas anders. Einrückungen verbessern zwar die Lesbarkeit des Codes, haben aber keinen Einfluss auf die Gruppierung von Anweisungen in AutoHotkey. Stattdessen werden Anweisungen gruppiert, indem man sie, wie oben gezeigt, mit geschweiften Klammern umschließt. Dies wird als <a href="lib/Block.htm"><em>Block</em></a> bezeichnet.</p>
<p class="note">Details zur Syntax - also wie man Kontrollanweisungen in AutoHotkey schreibt oder erkennt - finden Sie unter <a href="Language.htm#control-flow">Kontrollfluss</a>.</p>

<h2 id="details">Details</h2>

<h3 id="string-encoding">Zeichenkettenkodierung</h3>
<p>Jedes Zeichen in der Zeichenkette entspricht einer Zahl, auch <em>Ordinalzahl</em> genannt, oder einem <em>Zeichencode</em>. Zum Beispiel würde der Wert "Abc" wie folgt dargestellt werden:</p>
<table class="info" style="width: 8em; text-align: center">
  <tr><td>A</td><td>b</td><td>c</td></tr>
  <tr><td>65</td><td>98</td><td>99</td><td>0</td></tr>
</table>
<p><strong>Kodierung:</strong> Die <em>Kodierung</em> einer Zeichenkette definiert, wie Symbole mit den Ordinalzahlen und Ordinalzahlen mit den Bytes verknüpft werden. Es gibt viele verschiedene Kodierungen, aber da alle Kodierungen, die von AutoHotkey unterstützt werden, ASCII als Untermenge enthalten, haben die Zeichencodes 0 bis 127 immer die gleiche Bedeutung. So hat zum Beispiel 'A' immer den Zeichencode 65.</p>
<p id="null-termination"><strong>Nullterminierung:</strong> Jede Zeichenkette wird mit einem "Nullzeichen" terminiert; solche Zeichen haben den Binärwert Null und markieren das Ende einer Zeichenkette. Die Länge der Zeichenkette muss nicht gespeichert werden, da die Länge über die Position des Nullterminators abgeleitet werden kann. Aus Performanzgründen speichert AutoHotkey manchmal die Länge, z.B. wenn eine Zeichenkette in einer Variable enthalten ist.</p>
<p class="warning"><strong>Hinweis:</strong> Da AutoHotkey v1 auf die Nullterminierung angewiesen ist, unterstützt es grundsätzlich keine Zeichenketten mit eingebetteten Nullzeichen. Solche Zeichenketten können zwar mit <a href="lib/VarSetCapacity.htm">VarSetCapacity()</a> und <a href="lib/NumPut.htm">NumPut()</a> oder <a href="lib/DllCall.htm">DllCall()</a> erzeugt werden, führen aber meist zu inkonsistenten Ergebnissen.</p>
<p id="native-encoding"><strong>Native Kodierung:</strong> Obwohl AutoHotkey den Umgang mit Texten unterschiedlicher Kodierung ermöglicht, setzen die internen Befehle und Funktionen - und bis zu einem gewissen Grad auch die Sprache selbst - voraus, dass Zeichenkettenwerte in einer bestimmten Kodierung vorliegen. Dies wird als <em>native</em> Kodierung bezeichnet. Die native Kodierung hängt von der Version von AutoHotkey ab:</p>
<ul>
  <li>
<p>Unicode-Versionen von AutoHotkey verwenden UTF-16. Das kleinste Element in einer UTF-16-Zeichenkette ist zwei Bytes (16 Bit) groß. Unicode-Zeichen im Bereich von 0 bis 65535 (U+FFFF) werden von einer einzelnen 16-Bit-Codeeinheit des gleichen Wertes repräsentiert, während Zeichen im Bereich von 65536 (U+10000) bis 1114111 (U+10FFFF) von einem <em>Ersatzzeichenpaar</em> repräsentiert werden; also exakt zwei 16-Bit-Codeeinheiten zwischen 0xD800 und 0xDFFF. (weitere Details zu Ersatzzeichenpaaren und Methoden zu deren Kodierung bzw. Dekodierung finden Sie im Internet.)</p>
</li>
  <li>
<p>ANSI-Versionen von AutoHotkey verwenden die Standard-ANSI-Codepage des Systems, abhängig von den Sprach- und Regionseinstellungen des Systems oder von der Systemeinstellung "Sprache für Unicode-inkompatible Programme". Das kleinste Element einer ANSI-Zeichenkette ist ein Byte groß. Einige Codepages enthalten jedoch Zeichen, die von Sequenzen mehrerer Bytes repräsentiert werden (das sind immer ASCII-fremde Zeichen).</p>
</li>
</ul>
<p id="character"><strong>Zeichen:</strong> In der Regel wird in anderen Abschnitten dieser Dokumentation der Begriff "Zeichen" für die kleinste Einheit einer Zeichenkette verwendet; Bytes für ANSI-Zeichenketten und 16-Bit-Codeeinheiten für Unicode-Zeichenketten (UTF-16). Aus praktischen Gründen werden die Länge einer Zeichenkette und die Positionen innerhalb einer Zeichenkette in diesen festen Einheiten gemessen, auch wenn sie nicht immer vollständige Unicode-Zeichen sind.</p>
<p><a href="lib/FileRead.htm">FileRead</a>, <a href="lib/FileAppend.htm">FileAppend</a>, <a href="lib/FileOpen.htm">FileOpen()</a> und das <a href="lib/File.htm">File-Objekt</a> bieten Möglichkeiten, um Text mit einer bestimmten Kodierung aus/in eine Datei zu lesen/schreiben.</p>
<p>Die Funktionen <a href="lib/StrGet.htm">StrGet</a> und <a href="lib/StrPut.htm">StrPut</a> können verwendet werden, um die native Kodierung einer Zeichenkette in eine andere umzuwandeln, und umgekehrt. Diese Funktionen sind jedoch in der Regel nur in Kombination mit Datenstrukturen und der <a href="lib/DllCall.htm">DllCall</a>-Funktion sinnvoll. Zeichenketten, die direkt an oder von <a href="lib/DllCall.htm">DllCall()</a> übergeben werden, können mit den Parametertypen <code class="no-highlight">AStr</code> oder <code class="no-highlight">WStr</code> in ANSI oder UTF-16 umgewandelt werden.</p>
<p>Techniken zum Umgang mit den Unterschieden zwischen ANSI- und Unicode-Versionen von AutoHotkey finden Sie unter <a href="Compat.htm#Format">Unicode vs. ANSI</a>.</p>

<h3 id="pure-numbers">Reine Zahlen</h3>
<p>Eine <em>reine</em> oder <em>binäre</em> Zahl ist eine Zahl im Speicher, mit deren Format die CPU des Computers direkt umgehen kann, um z.B. Berechnungen durchzuführen. In den meisten Fällen wandelt AutoHotkey automatisch zwischen numerischen Zeichenketten und reinen Zahlen um, aber nur selten muss AutoHotkey zwischen den beiden Typen unterscheiden. AutoHotkey verwendet hauptsächlich zwei Datentypen für reine Zahlen:</p>
<ul>
  <li>vorzeichenfähige 64-Bit-Integer (<em>int64</em>).</li>
  <li>binäre 64-Bit-Floating-Point-Zahlen (das <em>Double</em>- oder <em>Binary64</em>-Format des internationalen Standards IEEE 754).</li>
</ul>
<p>Mit anderen Worten gelten für Skripte folgende Einschränkungen:</p>
<ul>
  <li>
<p>Integer müssen im Bereich von -9223372036854775808 (-0x8000000000000000, oder -2<sup>63</sup>) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF, oder 2<sup>63</sup>-1) sein. Obwohl größere Werte in einer Zeichenkette enthalten sein können, kann jeder Versuch, die Zeichenkette in eine Zahl umzuwandeln (z.B. in einer mathematischen Operation) zu inkonsistenten Ergebnissen führen.</p>
</li>
  <li>
<p>Floating-Point-Zahlen unterstützen in der Regel eine Genauigkeit von 15 Dezimalstellen. Bei der Umwandlung einer Floating-Point-Zahl in eine Zeichenkette wird die Zahl jedoch gemäß dem aktuellen <a href="lib/SetFormat.htm#Float">Float-Format</a> gerundet, das standardmäßig 6 Dezimalstellen verwendet. Wenn der Slow-Modus von <a href="lib/SetFormat.htm">SetFormat</a> irgendwo im Skript angegeben ist, werden Zahlen <em>immer</em> in Zeichenketten umgewandelt, wenn sie einer <a href="#variables">Variable</a> zugewiesen werden.</p>
</li>
</ul>
<p><strong>Hinweis:</strong> Es gibt einige Dezimalstellen, die das binäre Floating-Point-Format nicht exakt darstellen kann, so dass eine Zahl auf die nächstliegende darstellbare Zahl gerundet wird. Das kann zu unerwarteten Ergebnissen führen. Zum Beispiel:</p>
<pre>SetFormat FloatFast, 0.17  <em>; Zeige "übervolle" Präzision</em>
MsgBox % 0.1 + 0           <em>; 0.10000000000000001</em>
MsgBox % 0.1 + 0.2         <em>; 0.30000000000000004</em>
MsgBox % 0.3 + 0           <em>; 0.29999999999999999</em>
MsgBox % 0.1 + 0.2 = 0.3   <em>; 0 (nicht identisch)</em>
</pre>
<p>Eine Strategie zur Lösung dieses Problems besteht darin, den direkten Vergleich zu vermeiden und stattdessen die Differenz zu vergleichen. Zum Beispiel:</p>
<pre>MsgBox % Abs((0.1 + 0.2) - (0.3)) &lt; 0.0000000000000001
</pre>
<p>Eine andere Strategie besteht darin, die Zahl vor dem Vergleich immer in eine Zeichenkette umzuwandeln (und dabei Rundungen vorzunehmen). In der Regel gibt es dafür zwei Möglichkeiten unter Angabe der Genauigkeit:</p>
<pre>MsgBox % Round(0.1 + 0.2, 15) = Format("{:.15f}", 0.3)
</pre>

<h3 id="names">Namen</h3>
<p>AutoHotkey wendet die gleichen Regeln für die Benennung verschiedener Dinge an, inklusive Variablen, Funktionen, <a href="lib/GroupAdd.htm">Fenstergruppen</a>, <a href="lib/Gui.htm">GUIs</a>, Klassen und Methoden:</p>
<ul>
  <li><strong>Groß- und Kleinschreibung:</strong> Für ASCII-Zeichen nicht relevant. Zum Beispiel ist <code>AktuellesDatum</code> dasselbe wie <code>aktuellesdatum</code>. ASCII-fremde Großbuchstaben wie "Ä" sind jedoch <em>nicht</em> identisch mit ihren Kleinbuchstaben, unabhängig von den aktuellen Sprach- und Regionseinstellungen des Benutzers. Das hilft dem Skript, sich über mehrere Sprach- und Regionseinstellungen hinweg konsistent zu verhalten.</li>
  <li><strong>Maximale Länge:</strong> 253 Zeichen.</li>
  <li><strong>Erlaubte Zeichen:</strong> Buchstaben, Zahlen, ASCII-fremde Zeichen und die folgenden Symbole: _ # @ $</li>
</ul>
<p>Aufgrund von Gestaltungsrichtlinien ist es grundsätzlich besser, nur Buchstaben, Zahlen und Unterstriche zu verwenden (zum Beispiel: <em>PositionZeiger</em>, <em>Gesamt_Elemente</em> und <em>Eintrag_ist_gültig</em>). Auf diese Weise können Personen, die mit anderen Computersprachen vertraut sind, Ihr Skript besser verstehen.</p>
<p>Obwohl der Name einer <a href="#variables">Variable</a> vollständig aus Ziffern bestehen kann, sind solche Namen in der Regel nur für <a href="Scripts.htm#cmd_args_old">eingehende Befehlszeilenparameter</a> relevant. Ausdrücke dürfen keine numerischen Namen enthalten, weil sie dort nicht als Variablen, sondern als Zahlen interpretiert werden. Vermeiden Sie am besten Namen, die mit einer Ziffer beginnen, da solche Namen verwirrend sind und in AutoHotkey v2 als ungültig behandelt werden.</p>
<p>Da die folgenden Zeichen in AutoHotkey v2 eventuell für andere Zwecke reserviert werden, ist es ratsam, diese nicht zu verwenden: # @ $</p>
<p>Für Eigenschaftsnamen in Klassen gelten die gleichen Regeln und Einschränkungen wie für Variablennamen, mit der Ausnahme, dass die drei oben genannten Zeichen (# @ $) nicht erlaubt sind. Diese können zwar in einer Methodendefinition verwendet werden, aber dann kann diese Methode nur mit eckigen Klammern aufgerufen werden. Zum Beispiel ist <code>meinObjekt.@home()</code> ungültig, aber <code>meinObjekt["@home"]()</code> gültig.</p>

<h3 id="variable-references">Variablenreferenzen vs. Werte</h3>
<p>Variablen haben einige Attribute, die die Grenze zwischen einer Variable und ihrem Wert verschwimmen lassen, dennoch ist es wichtig, sie zu differenzieren. Insbesondere in Bezug auf <a href="#objects">Objekte</a> und ByRef-Parametern.</p>
<p>Obwohl wir sagen können, dass die Variable <code>meinArray</code> ein Array <em>enthält</em> (was ein Objekttyp ist), ist das, was die Variable enthält, nicht das Array selbst, sondern eher <em>eine Referenz bzw. ein Pointer</em> zum Array. Es können beliebig viele Variablen eine Referenz zum selben Objekt enthalten. In diesem Fall kann es hilfreich sein, sich eine Variable nur als Namen vorzustellen. Gibt man zum Beispiel einer Person einen Spitznamen, führt das nicht dazu, dass diese Person geklont wird.</p>
<p>Standardmäßig werden Variablen <em>via Wert</em> an benutzerdefinierte Funktionen übergeben. Das heißt, dass der in der Variable enthaltene Wert in eine Variable kopiert wird, die dem Parameter der Funktion entspricht. Ein <strong>ByRef</strong>-Parameter kann verwendet werden, um eine Variable <em>via Referenz</em> zu übergeben, oder anders gesagt, um einen Parameter der Funktion zu einem <em>Alias</em> für die Variable zu machen, so dass die Funktion der Variable einen neuen Wert zuweisen kann.</p>
<p>Da eine Variable nicht das Objekt selbst, sondern nur eine <em>Referenz</em> zu diesem Objekt enthält, empfängt die Funktion, während so eine Variable an einen ByRef-losen Parameter übergeben wird, eine Referenz zum selben Objekt. Die Funktion kann dadurch das Objekt modifizieren, aber nicht die <em>Variable</em>, die der Funktionsaufrufer übergeben hat, weil die Funktion nicht die Variable, sondern nur eine Referenz zum Objekt hat.</p>

<h3 id="references-to-objects">Objektreferenzen</h3>
<p>Skripte interagieren nur indirekt mit einem Objekt, via <em>Referenz</em> zum Objekt. Beim Erstellen eines Objekts wird es an einem Ort erstellt, den Sie nicht kontrollieren können, und Ihnen eine Referenz übergeben. Wenn Sie diese Referenz an eine Funktion übergeben oder in eine Variable oder in einem anderen Objekt speichern, wird eine neue Referenz zum <em>selben</em> Objekt erstellt. Um eine Referenz freizugeben, verwenden Sie einfach eine Zuweisung und ersetzen Sie sie mit einem anderen Wert. Ein Objekt wird erst gelöscht, wenn alle Referenzen freigegeben sind, d.h. es ist weder möglich noch sollte versucht werden, ein Objekt explizit zu löschen.</p>
<pre>Ref1 := Object()  <em>; Ein Objekt erstellen und die erste Referenz speichern</em>
Ref2 := Ref1      <em>; Eine neue Referenz zum selben Objekt erstellen</em>
Ref1 := ""        <em>; Die erste Referenz freigeben</em>
Ref2 := ""        <em>; Die zweite Referenz freigeben; Objekt wird gelöscht</em>
</pre>
<p>Sollten Sie das nicht verstehen, versuchen Sie, sich ein Objekt als Mietwohnung vorzustellen. Wenn Sie eine Wohnung mieten, erhalten Sie einen Schlüssel, mit dem sie die Wohnung betreten können. Sie können weitere Schlüssel erhalten und damit die Wohnung betreten, aber wenn Sie die Wohnung nicht mehr benötigen, müssen Sie alle Schlüssel an den Vermieter zurückgeben. In der Regel wird eine Wohnung nicht <em>gelöscht</em>, aber vielleicht muss der Vermieter jemanden beauftragen, den Müll, den Sie hinterlassen haben, zu entfernen; ähnlich dem Fall, dass die hinterlegten Werte in einem Objekt freigegeben werden, wenn das Objekt gelöscht wird.</p>

</body>
</html>
