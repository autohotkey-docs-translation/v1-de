<!DOCTYPE HTML>
<html lang="de">
<head>
<title>DllCall() - Syntax &amp; Verwendung | AutoHotkey</title>
<meta name="description" content="Die DllCall-Funktion ruft eine Funktion aus einer DLL-Datei auf, z.B. eine API-Funktion von Windows." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga4.js" type="text/javascript"></script>
</head>
<body>

<h1>DllCall()</h1>

<p>Ruft eine Funktion aus einer DLL-Datei auf, z.B. eine API-Funktion von Windows.</p>

<pre class="Syntax">Ergebnis := <span class="func">DllCall</span>("<span class="optional">DllDatei\</span>Funktion" <span class="optional">, Typ1, Arg1, Typ2, Arg2, "Cdecl RückgabeTyp"</span>)</pre>
<h2 id="Parameters">Parameter</h2>
<dl>

  <dt>[DllDatei\]Funktion</dt>
  <dd><p>Der Name einer DLL- oder EXE-Datei, gefolgt von einem umgekehrten Schrägstrich und dem Namen der Funktion. Zum Beispiel: <code>"MeineDLL\MeineFunktion"</code> (wenn die Dateiendung weggelassen wird, wird standardmäßig ".dll" verwendet). Wenn kein absoluter Pfad angegeben ist, wird <em>DllDatei</em> in einem der Pfade aus der PATH-Umgebungsvariable oder im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis vermutet. Beachten Sie, dass DllCall() einen Pfad mit umgekehrten Schrägstrichen (\) erwartet. Schrägstriche (/) werden nicht unterstützt.</p>
      <p id="std"><em>DllDatei</em> kann weggelassen werden, wenn eine Funktion aus den Systemdateien User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll aufgerufen wird. Zum Beispiel liefert <code>"User32\IsWindowVisible"</code> das gleiche Ergebnis wie <code>"IsWindowVisible"</code>.</p>
      <p>Wenn unter dem angegebenen Namen keine Funktion gefunden wird, wird automatisch ein A (ANSI) oder W (Unicode) angefügt, je nachdem, mit welcher AutoHotkey-Version das Skript ausgeführt wird. Zum Beispiel ist <code>"MessageBox"</code> dasselbe wie <code>"MessageBoxA"</code> in ANSI-Versionen und dasselbe wie <code>"MessageBoxW"</code> in Unicode-Versionen.</p>
      <p>Wenn die DLL <em>wiederholt</em> aufgerufen wird, ist es ratsam, <a href="#load">sie vorher zu laden</a>, um die Performanz dramatisch zu erhöhen.</p>
    <p><span class="ver">[v1.0.46.08+]</span>: Dieser Parameter kann auch ein reiner Integer sein, der als Adresse einer Funktion zum Aufrufen interpretiert wird. Quellen für solche Adressen sind u.a. <a href="#COM">COM</a> und <a href="RegisterCallback.htm">RegisterCallback()</a>.</p></dd>

  <dt>Typ1, Arg1</dt>
  <dd><p>Jedes dieser Paare repräsentiert einen einzelnen Parameter, der an die Funktion übergeben werden soll. Die Anzahl der Paare ist unbegrenzt. Geben Sie für <em>Typ</em> einen Typ aus der <a href="#types">Typentabelle</a> unten an. Geben Sie für <em>Arg</em> einen Wert an, der an die Funktion übergeben werden soll.</p></dd>

  <dt>Cdecl RückgabeTyp</dt>
  <dd><p id="cdecl">Das Wort <em>Cdecl</em> wird normalerweise weggelassen, da die meisten Funktionen die Standardaufrufkonvention anstelle der C-Aufrufkonvention verwenden (Funktionen wie wsprintf, die eine unterschiedliche Anzahl von Argumenten akzeptieren, sind eine Ausnahme). Wenn Cdecl weggelassen wird, aber der Aufruf <a href="#An">ErrorLevel A<strong>n</strong></a> liefert - wobei <strong>n</strong> die Gesamtgröße der übergebenen Argumente ist - muss <em>Cdecl</em> eventuell angegeben werden. Beachten Sie, dass die meisten objektorientierten C++-Funktionen die nicht unterstützte <i>thiscall</i>-Konvention verwenden.</p>
      <p>Das Wort <em>Cdecl</em> muss vor dem Rückgabetyp (falls vorhanden) stehen. Trennen Sie alle Wörter jeweils durch ein Leer- oder Tabulatorzeichen. Zum Beispiel: <code>"Cdecl Str"</code>.</p>
      <p><span class="ver">[AHK_L 53+]</span>: Da es im 64-Bit-Code keine separate C-Aufrufkonvention gibt, hat die Angabe von <i>Cdecl</i> in 64-Bit-Builds von AutoHotkey keine Wirkung.</p>
      <p><em>RückgabeTyp</em>: Wenn die Funktion einen vorzeichenfähigen 32-Bit-Integer (Int), BOOL oder nichts zurückgibt, kann <em>RückgabeTyp</em> weggelassen werden. Andernfalls geben Sie einen der Argumenttypen aus der <a href="#types">Typentabelle</a> unten an. Das <a href="#asterisk">Sternchen-Suffix</a> wird ebenfalls unterstützt.</p></dd>

</dl>

<h2 id="Return_Value">Rückgabewert</h2>
<p>DllCall gibt den Rückgabewert von <em>Funktion</em> zurück. Wenn <em>Funktion</em> keinen Rückgabewert hat, ist das Ergebnis ein undefinierter Integer. Wenn <em>Funktion</em> aufgrund eines <a href="#error">Fehlers</a> nicht aufgerufen werden kann, ist das Ergebnis eine leere Zeichenkette.</p>

<h2 id="types">Typen von Argumenten und Rückgabewerten</h2>
<table class="info">
<tr>
<th>Typ</th>
<th abbr="Beschr">Beschreibung</th>
</tr>
<tr id="str">
<td>Str</td>
<td><p>Eine Zeichenkette wie "Blau" oder MeineVar. Wenn die aufgerufene Funktion die Zeichenkette ändert und das Argument eine reine Variable ist, wird der Inhalt der Variable aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von <em>MeineVar</em> in Großbuchstaben umwandeln: <code>DllCall("CharUpper", "Str", <i>MeineVar</i>)</code>.</p>
  <p>Wenn die Funktion jedoch eine Zeichenkette zurückgibt, die größer ist als die aktuelle Kapazität einer Variable, sollten Sie vor dem Funktionsaufruf sicherstellen, dass die Variable groß genug ist. Rufen Sie hierfür <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineVar, 123)</code> auf, wobei 123 die gewünschte Kapazität für <em>MeineVar</em> ist.</p>
  <p>Ein <em>Str</em>-Argument darf kein <a href="../Variables.htm#Expressions">Ausdruck</a> sein, der nach der Auswertung eine Zahl ergibt (z.B. <code>i+1</code>). Ist dies der Fall, wird die Funktion nicht aufgerufen und ErrorLevel auf -2 gesetzt.</p>
  <p>Die <a href="#asterisk">Sternchenvariable</a> "Str*" wird unterstützt, aber selten verwendet. Sie kann für Funktionen verwendet werden, die so etwas wie "TCHAR **" oder "LPTSTR *" erwarten.</p>
  <p class="note"><strong>Hinweis:</strong> Wenn Sie eine Zeichenkette an eine Funktion übergeben, müssen Sie darauf achten, welchen <a href="../Compat.htm#DllCall"><i>Typ</i> von Zeichenkette</a> die Funktion erwartet.</p></td>
</tr>
<tr>
  <td><span id="astr"></span><span id="wstr"></span>AStr<br>WStr</td>
  <td><span class="ver">[AHK_L 42+]</span>: Eine <b>A</b>NSI- oder Unicode-Zeichenkette (<b>W</b>ide character). Weitere Informationen und äquivalente Win32-Typen finden Sie unter <a href="../Compat.htm#DllCall">Skriptkompatibilität</a>.</td>
</tr>
<tr>
  <td>Int64</td>
  <td>Ein 64-Bit-Integer im Bereich von -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</td>
</tr>
<tr id="Int">
  <td>Int</td>
  <td><p>Ein 32-Bit-Integer (der am häufigsten verwendete Integertyp) im Bereich von -2147483648 (-0x80000000) bis 2147483647 (0x7FFFFFFF). Ein Int wird manchmal auch als "Long" bezeichnet.</p>
    <p>Ein Int sollte auch für BOOL-Argumente verwendet werden (ein BOOL-Wert ist entweder 1 oder 0).</p>
    <p>Ein <a href="#unsigned">vorzeichenloser</a> Integer (UInt) ist ebenfalls recht häufig vertreten und kann zum Beispiel für DWORD-Argumente verwendet werden.</p></td>
</tr>
<tr>
  <td>Short</td>
  <td>Ein 16-Bit-Integer im Bereich von -32768 (-0x8000) bis 32767 (0x7FFF). Ein <a href="#unsigned">vorzeichenloser</a> 16-Bit-Integer (UShort) kann zum Beispiel für DWORD-Argumente verwendet werden.</td>
</tr>
<tr>
  <td>Char</td>
  <td>Ein 8-Bit-Integer im Bereich von -128 (-0x80) bis 127 (0x7F). Ein <a href="#unsigned">vorzeichenloser</a> 8-Bit-Integer (UChar) kann zum Beispiel für BYTE-Argumente verwendet werden.</td>
</tr>
<tr>
  <td>Float</td>
  <td>Eine 32-Bit-Floating-Point-Zahl mit einer Genauigkeit von 6 Dezimalstellen.</td>
</tr>
<tr>
  <td>Double</td>
  <td>Eine 64-Bit-Floating-Point-Zahl mit einer Genauigkeit von 15 Dezimalstellen.</td>
</tr>
<tr id="ptr">
  <td>Ptr</td>
  <td><p><span class="ver">[AHK_L 42+]</span>: Ein <a href="../Variables.htm#PtrSize">pointergroßer</a> Integer, äquivalent zu Int oder Int64, je nachdem, ob die EXE-Datei, die das Skript ausführt, 32-Bit oder 64-Bit ist. <i>Ptr</i> sollte für Pointer verwendet werden, die auf Arrays oder Strukturen verweisen (wie RECT* oder LPPOINT), und für fast alle Handles (wie HWND, HBRUSH oder HBITMAP). Wenn der Parameter ein Pointer ist, der auf einen einzelnen numerischen Wert verweist, wie z.B. LPDWORD oder int*, sollte grundsätzlich das *- oder P-Suffix anstelle von "Ptr" verwendet werden.</p>
  <p><i>Ptr</i> kann auch mit dem *- oder P-Suffix verwendet werden; es sollte mit Funktionen verwendet werden, die einen Pointer via LPVOID* oder ähnliches zurückgeben.</p>
  <p><i>UPtr</i> ist auch gültig, ist aber nur vorzeichenlos in 32-Bit-Builds, da AutoHotkey keine vorzeichenlosen 64-Bit-Integer unterstützt.</p>
  <p>Wenn das Skript mit älteren Versionen von AutoHotkey kompatibel sein muss, verwenden Sie einen Variablentyp wie folgt:</p>
  <pre>Ptr := A_PtrSize ? "Ptr" : "UInt" <em>; Wenn A_PtrSize nicht definiert ist, wird stattdessen UInt verwendet.</em>
DllCall("DeleteFile", Ptr, &amp;DateiName) <em>; Anführungszeichen bei Ptr weglassen.</em></pre>
  <p class="note"><strong>Hinweis:</strong> Um ein <strong>NULL</strong>-Handle oder -Pointer zu übergeben, verwenden Sie den Integer 0.</p></td>
</tr>
<tr id="asterisk">
  <td>* oder P<br>
    (Suffix)</td>
  <td><p>Fügen Sie ein Sternchen (optional mit einem Leerzeichen davor) an einen der obigen Typen an, um nicht den Wert selbst, sondern die Adresse des Arguments zu übergeben (die aufgerufene Funktion muss dafür ausgelegt sein, so etwas zu akzeptieren). Der Wert eines solchen Arguments kann von der Funktion geändert werden; d.h. jedes Mal, wenn eine reine Variable als Argument übergeben wird, wird der Inhalt dieser Variable aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von MeineVar an MeineFunktion via Adresse übergeben, aber auch den Inhalt von MeineVar aktualisieren, um alle Änderungen widerzuspiegeln, die MeineFunktion an MeineVar vorgenommen hat: <code>DllCall("MeineDLL\MeineFunktion", "Int*", MeineVar)</code>.</p>
    <p>In der Regel wird ein Sternchen verwendet, wenn eine Funktion einen Argument- oder Rückgabetyp hat, der mit "LP" beginnt. Das bekannteste Beispiel dafür ist LPDWORD (ein Pointer, der auf ein DWORD verweist). Da DWORD ein vorzeichenloser 32-Bit-Integer ist, können Sie "UInt*" oder "UIntP" für LPDWORD verwenden. Das Sternchen sollte nicht für Zeichenkettentypen wie LPTSTR, auf Strukturen verweisende Pointer wie LPRECT, oder Arrays verwendet werden; für solche Typen ist <a href="#str">"Str"</a> oder "Ptr" besser geeignet, je nachdem, ob Sie eine Variable oder ihre Adresse übergeben.</p>
    <p class="note"><strong>Hinweis:</strong> "Char*" ist nicht dasselbe wie <a href="#str">"Str"</a>, weil "Char*" die Adresse einer 8-Bit-Zahl übergibt, während <a href="#str">"Str"</a> die Adresse einer Zeichenkette übergibt, die je nach AutoHotkey-Version 8-Bit (ANSI) oder 16-Bit (Unicode) ist. Ähnlich verhält es sich mit "UInt*": Da dieser Typ die Adresse einer 32-Bit-Zahl übergibt, ist er nicht für Funktionen geeignet, die ein Array mit Werten oder eine Struktur größer als 32 Bit erwarten.</p>
    <p>Da Variablen in AutoHotkey keinen festen Typ haben, verweist eine an die Funktion übergebene Adresse auf einen temporären Speicher, nicht auf die Variable selbst. Es ist nicht notwendig, <a href="VarSetCapacity.htm">VarSetCapacity()</a> für die Variable aufzurufen, da DllCall diese Variable nach dem Funktionsaufruf korrekt aktualisieren wird.</p>
    </td>
</tr>
<tr id="unsigned">
  <td>U (Präfix)</td>
  <td><p>Stellen Sie einem der obigen Integertypen den Buchstaben U voran, um den entsprechenden Wert als vorzeichenlosen Integer (UInt64, UInt, UShort und UChar) zu interpretieren. Streng genommen ist das nur für Rückgabewerte und <a href="#asterisk">Sternchenvariablen</a> notwendig, da es keine Rolle spielt, ob ein via Wert übergebenes Argument vorzeichenfähig oder vorzeichenlos ist (außer für Int64).</p>
    <p>Wenn ein negativer Integer bei einem vorzeichenlosen Argument angegeben ist, wechselt der Integer in den vorzeichenlosen Bereich. Zum Beispiel wird -1 zu 0xFFFFFFFF, wenn es als UInt gesendet wird.</p>
    <p><em>Vorzeichenlose</em> 64-Bit-Integer, die von einer Funktion erzeugt werden, werden nicht unterstützt. Um mit Zahlen größer gleich 0x8000000000000000 zu arbeiten, verzichten Sie auf das U-Präfix und interpretieren Sie alle negativen Werte, die von der Funktion zurückgegeben werden, als große Integer (Int64). Zum Beispiel wird eine Funktion, die -1 als Int64 zurückgibt, eigentlich 0xFFFFFFFFFFFFFFFF zurückgeben, wenn sie für die Rückgabe eines UInt64 ausgelegt ist.</p>
    <p>Für Parameter vom Typ UInt64 können lange vorzeichenlose Werte als Zeichenketten übergeben werden. Für kleinere Integertypen ohne *- oder P-Suffix oder bei der Übergabe von reinen 64-Bit-Integern an eine Funktion spielt der Unterschied zwischen vorzeichenfähig und vorzeichenlos keine Rolle, weil zum Darstellen von vorzeichenfähigen Integern das Zweierkomplement verwendet wird. Aus Gründen der Übersichtlichkeit kann es jedoch sinnvoll sein, für vorzeichenlose Werte das U-Präfix zu verwenden.</p></td>
</tr>
</table>
<p class="warning"><strong>Veraltet:</strong> Bei der Angabe eines Argument- oder Rückgabetyps, der kein Leerzeichen oder Sternchen enthält, können die Anführungszeichen weggelassen werden. Zum Beispiel kann <code>Str</code> anstelle von <code>"Str"</code> und <code>CDecl</code> anstelle von <code>"CDecl"</code> verwendet werden. Dies ist nicht für neue Skripte empfohlen.</p>

<h2 id="error">Fehlerbehandlung</h2>
<p><span class="ver">[v1.1.04+]</span>: Diese Funktion ist in der Lage, bei Misserfolg eine Ausnahme auszulösen. Weitere Informationen finden Sie unter <a href="Catch.htm#RuntimeErrors">Laufzeitfehler</a>.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> wird auf einen der folgenden Werte gesetzt, um den Erfolg oder Misserfolg des Aufrufs zu kennzeichnen.</p>
<p><strong>0:</strong> Erfolgreich.</p>
<p><strong>-1</strong>: Der <em>[DllDatei\]Funktion</em>-Parameter ist eine Floating-Point-Zahl. Es wird eine Zeichenkette oder ein positiver Integer benötigt.</p>
<p><strong>-2:</strong> Der <a href="#types">Rückgabetyp</a> oder einer der angegebenen <a href="#types">Argumenttypen</a> ist ungültig. Dieser Fehler kann auch auftreten, wenn ein <a href="../Variables.htm#Expressions">Ausdruck</a>, der nach der Auswertung eine Zahl ergibt, an ein Zeichenkettenargument (<a href="#str">Str</a>) übergeben wird.</p>
<p><strong>-3:</strong> Die angegebene <em>DllDatei</em> konnte nicht gelesen oder geladen werden. Wenn kein expliziter Pfad für <em>DllDatei</em> angegeben wurde, muss die Datei in einem der Pfade aus der PATH-Umgebungsvariable oder im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis vorhanden sein. Dieser Fehler kann auch auftreten, wenn der Benutzer keine Zugriffsrechte auf die Datei hat, oder wenn man mit einem 32-Bit-Build von AutoHotkey auf eine 64-Bit-DLL zugreift (oder umgekehrt).</p>
<p><strong>-4:</strong> Die angegebene Funktion konnte in der DLL nicht gefunden werden.</p>
<p><strong>N</strong> (beliebige positive Nummer): Die Funktion wurde aufgerufen, aber mit der fatalen Ausnahme Nummer <strong>N</strong> abgebrochen (z.B. 0xC0000005 bedeutet "Zugriffsverletzung"). In solchen Fällen gibt die Funktion einen leeren Wert (leere Zeichenkette) zurück, während alle <a href="#asterisk">Sternchenvariablen</a> weiter aktualisiert werden. Eine fatale Ausnahme ist zum Beispiel die Dereferenzierung eines ungültigen Pointers wie NULL. Da eine <a href="#cdecl">Cdecl</a>-Funktion niemals den im nächsten Absatz beschriebenen <em>"An"</em>-Fehler erzeugt, löst die Funktion stattdessen eine Ausnahme aus, wenn ihr zu wenig Argumente übergeben werden.</p>
<p id="An"><strong>An</strong> (Buchstabe A gefolgt vom Integer <strong>n</strong>): Die Funktion wurde erfolgreich aufgerufen, aber ihr wurden zu viele oder zu wenig Argumente übergeben. "<strong>n</strong>" ist die Anzahl der Bytes, um wie viel die Argumentenliste inkorrekt war. Wenn <strong>n</strong> positiv ist, wurden zu viele Argumente (oder zu lange Argumente) übergeben, oder der Aufruf benötigt <a href="#cdecl">CDecl</a>. Wenn <strong>n</strong> negativ ist, wurden zu wenig Argumente übergeben. Dieser Fehler sollte behoben werden, um einen zuverlässigen Betrieb der Funktion zu gewährleisten. Dieser Fehler kann auch ein Indikator dafür sein, dass eine Ausnahme aufgetreten ist - in diesem Fall gibt die Funktion einen leeren Wert zurück. Beachten Sie, dass 64-Bit-Builds von AutoHotkey aufgrund der x64-Aufrufkonvention nicht in der Lage sind, ErrorLevel auf <b>An</b> zu setzen.</p>

<h2 id="except">Ausnahmen und A_LastError</h2>
<p>Trotz der internen Ausnahmebehandlung kann ein DllCall das Skript immer noch zum Absturz bringen. Dies kann passieren, wenn eine Funktion nicht direkt eine Ausnahme auslöst, sondern etwas Falsches zurückgibt, wie z.B. einen fehlerhaften Pointer oder eine nicht-terminierte Zeichenkette. Dies ist nicht unbedingt die Schuld der Funktion, wenn das Skript ihr einen ungeeigneten Wert übergeben hat, wie z.B. einen fehlerhaften Pointer oder ein <a href="#str">"Str"</a> mit unzureichender Kapazität. Ein Skript kann auch abstürzen, wenn es einen ungeeigneten Argument- oder Rückgabetyp spezifiziert, z.B. wenn es behauptet, dass ein gewöhnlicher Integer, der von einer Funktion zurückgegeben wird, eine <a href="#asterisk">Sternchenvariable</a> oder <a href="#str">Str</a> ist.</p>
<p id="LastError">Die interne Variable <strong>A_LastError</strong> enthält den Rückgabewert der Systemfunktion GetLastError(), die unmittelbar nach dem Aufruf der Funktion aufgerufen wird (dies hat keinen messbaren Einfluss auf die Performanz). A_LastError ist eine Zahl zwischen 0 und 4294967295 (immer dezimal, nicht hexadezimal). A_LastError ist wie <a href="../misc/ErrorLevel.htm">ErrorLevel</a> eine threadspezifische Einstellung, d.h. es kann nicht durch Unterbrechungen anderer <a href="../misc/Threads.htm">Threads</a> geändert werden. Allerdings wird A_LastError auch von <a href="Run.htm#LastError">Run/RunWait</a> gesetzt.</p>

<h2 id="load">Performanz</h2>
<p>Wenn die DLL wiederholt aufgerufen wird, ist es ratsam, sie vorher zu laden, um die Performanz dramatisch zu erhöhen (<em>das ist für eine <a href="#std">Standard-DLL</a> wie User32 nicht notwendig, da sie immer allgegenwärtig ist</em>). Dadurch wird vermieden, dass DllCall jedes Mal LoadLibrary und FreeLibrary intern aufrufen muss. Zum Beispiel:</p>
<pre>hModule := DllCall("<strong>LoadLibrary</strong>", "Str", "MeineFunktionen.dll", "Ptr")  <em>; Verhindert, dass DllCall() die Bibliothek in der Schleife laden muss.</em>
Loop, C:\Meine Dokumente\*.*, , 1
    Ergebnis := DllCall("MeineFunktionen\DateiSichern", "Str", A_LoopFileFullPath)
DllCall("<strong>FreeLibrary</strong>", "Ptr", hModule)  <em>; Um Speicherplatz zu sparen, kann die DLL nach Gebrauch wieder freigegeben werden.</em></pre>
<p><span class="ver">[v1.0.46.08+]</span>: Um die Performanz noch weiter zu erhöhen, kann die Adresse der Funktion im Voraus ermittelt werden. Zum Beispiel:</p>
<pre><em>; Verwenden Sie in der folgenden Zeile LoadLibrary anstelle von GetModuleHandle, wenn die DLL noch nicht geladen ist.</em>
<strong>MulDivProc</strong> := DllCall("GetProcAddress", "Ptr", DllCall("GetModuleHandle", "Str", "<strong>kernel32</strong>", "Ptr"), "AStr", "<strong>MulDiv</strong>", "Ptr")
Loop 500
    DllCall(<strong>MulDivProc</strong>, "Int", 3, "Int", 4, "Int", 3)</pre>
<p><span class="ver">[AHK_L 31+]</span>: Wenn der erste Parameter von DllCall eine direkt geschriebene Zeichenkette wie <code>"MulDiv"</code> ist und die DLL der entsprechenden Funktion normal vor dem Start des Skripts geladen wird, wird die Zeichenkette automatisch in eine Funktionsadresse aufgelöst. Diese interne Optimierung ist effizienter als das obige Beispiel.</p>
<p>Sie können auch <a href="_NoEnv.htm">#NoEnv</a> irgendwo im Skript einfügen, um die Performanz von DllCall zu erhöhen, wenn anführungszeichenlose Parametertypen verwendet werden (z.B. Int statt "Int").</p>
<p>Übergibt man eine Zeichenkettenvariable an eine Funktion, die die Länge der Zeichenkette nicht ändert, kann die Performanz erhöht werden, indem man die Variable <a href="../Variables.htm#amp">per Adresse</a> (z.B. &amp;MeineVar) statt als "<a href="#str">str</a>" übergibt (insbesondere dann, wenn die Zeichenkette sehr lang ist). Das folgende Beispiel wandelt alle Buchstaben einer Zeichenkette in Großbuchstaben um: <code>DllCall("CharUpper", "<strong>Ptr</strong>", <strong>&amp;</strong>MeineVar, "Ptr")</code>.</p>

<h2 id="struct">Strukturen und Arrays</h2>
<p>Eine Struktur ist eine Sammlung von <em>Elementen</em> (Feldern), die nebeneinander im Speicher abgelegt sind. Die meisten Elemente sind für gewöhnlich Integer.</p>
<p>Funktionen, die die Adresse einer Struktur (oder eines Speicherblock-Arrays) akzeptieren, können aufgerufen werden, indem man die rohen Binärdaten der Struktur in einer normalen Variable hinterlegt. In der Regel geht man wie folgt vor:</p>
<p>1) Rufen Sie <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineStrukt, 123, 0)</code> auf, um sicherzustellen, dass die Kapazität der Zielvariable groß genug für die Struktur ist. Ersetzen Sie 123 mit einer Zahl, die mindestens der Größe der Struktur entspricht. Die 0 im letzten Parameter ist optional und bewirkt, dass alle Strukturelemente mit einer binären Null initialisiert werden, um häufige Aufrufe von NumPut() zu vermeiden, wie im nächsten Schritt beschrieben.</p>
<p>2) Wenn die Zielfunktion bereits zu Beginn bestimmte Werte in der Struktur benötigt, rufen Sie <code><a href="NumPut.htm">NumPut</a>(123, MeineStrukt, 4, "UInt")</code> auf, um ein beliebiges Element auf einen Wert ungleich 0 zu setzen. Ersetzen Sie <code>123</code> mit einem Integer, auf dem das Zielelement gesetzt werden soll (oder geben Sie <code>&amp;Var</code> an, um die <a href="../Variables.htm#amp">Adresse</a> einer Variable zu hinterlegen). Ersetzen Sie <code>4</code> mit dem Offset des Zielelements (siehe Schritt #4, was ein "Offset" ist). Ersetzen Sie <code>"UInt"</code> mit dem entsprechenden Typ oder lassen Sie es weg, wenn das Element ein Pointer oder Handle ist.</p>
<p>3) Rufen Sie die Zielfunktion auf und übergeben Sie die <a href="../Variables.htm#amp">Adresse</a> von <em>MeineStrukt</em> als UInt (oder als Ptr in <span class="ver">[AHK_L 42+]</span>). Zum Beispiel <code>DllCall("MeineDLL\MeineFunk", "Ptr", <strong>&amp;</strong>MeineStrukt)</code>. Die Funktion wird einige Elemente auswerten und/oder ändern.</p>
<p>4) Verwenden Sie <code>MeinInteger := <a href="NumGet.htm">NumGet</a>(MeineStrukt, 4, "UInt")</code>, um einen beliebigen Integer aus der Struktur abzurufen. Ersetzen Sie <code>4</code> mit dem Offset des Zielelements in der Struktur. Das erste Element befindet sich immer auf Offset 0. Das zweite Element befindet sich auf Offset 0 plus der Größe des ersten Elements (typischerweise 4). Jedes nachfolgende Element befindet sich auf dem Offset des vorherigen Elements plus der Größe des vorherigen Elements. Die meisten Elemente -- wie z.B. DWORD, Int und <a href="#Int">andere Typen von 32-Bit-Integern</a> -- haben eine Größe von 4 Bytes. Ersetzen Sie <code>"UInt"</code> mit dem entsprechenden Typ oder lassen Sie es weg, wenn das Element ein Pointer oder Handle ist.</p>
<p>Beispiele für Strukturen finden Sie im <a href="#ExStruct">Beispielabschnitt</a> weiter unten.</p>
<h2 id="limits">Bekannte Einschränkungen</h2>
<p>Übergibt man die <a href="../Variables.htm#amp">Adresse einer Variable</a> (z.B. <code>&amp;MeineVar</code>) an eine Funktion, die die Länge des Variableninhalts ändert, kann es vorkommen, dass die Variable bei späterer Verwendung ein fehlerhaftes Verhalten aufweist. Um das zu verhindern, gibt es folgende Lösungsmöglichkeiten: 1) Übergeben Sie <em>MeineVar</em> als <a href="#str">"Str"</a>-Argument, nicht als Ptr/Adresse; 2) <span class="ver">[v1.0.44.03+]</span>: Rufen Sie <code><a href="VarSetCapacity.htm#neg1">VarSetCapacity</a>(MeineVar, -1)</code> auf, um die intern gespeicherte Länge der Variable nach dem Aufruf von DllCall zu aktualisieren.</p>
<p>Eine binäre Null, die von einer Funktion in einer Variable hinterlegt wurde, versteckt alle Daten rechts von der Null, d.h. die meisten Befehle und Funktionen können diese Daten weder lesen noch verändern. Allerdings können solche Daten mit dem <a href="../Variables.htm#amp">Adressoperator</a> und <a href="NumPut.htm">NumPut()</a>/<a href="NumGet.htm">NumGet()</a> oder mit DllCall selbst manipuliert werden.</p>
<p>Eine Funktion, die die Adresse einer der ihr übergebenen Zeichenketten zurückgibt, kann eine identische Zeichenkette zurückgeben, die auf einer anderen Speicheradresse liegt als erwartet. Zum Beispiel würde der Aufruf von <code>CharLower(CharUpper(MeineVar))</code> in einer anderen Programmiersprache bewirken, dass der Inhalt von <em>MeineVar</em> in Kleinbuchstaben umgewandelt wird. Aber wenn dasselbe mit DllCall() gemacht wird, wäre <em>MeineVar</em> nach dem folgenden Aufruf in Großbuchstaben, weil CharLower mit einer anderen/temporären Zeichenkette gearbeitet hat, die mit <em>MeineVar</em> identisch ist:</p>
<pre>MeineVar := "ABC"
Ergebnis := DllCall("CharLower", "<strong><u>Str</u></strong>", DllCall("CharUpper", "Str", MeineVar, "<strong><u>Str</u></strong>"), "Str")</pre>
<p>Um das zu umgehen, ersetzen Sie oben die zwei unterstrichenen "Str"-Werte mit Ptr. Dadurch wird sichergestellt, dass der Rückgabewert von CharUpper als reine Adresse interpretiert wird, die dann als Integer an CharLower übergeben wird.</p>
<p>Beim Umgang mit Zeichenketten kann es zu Einschränkungen kommen. Weitere Informationen finden Sie unter <a href="../Compat.htm#DllCall">Skriptkompatibilität</a>.</p>
<h2 id="COM">Component Object Model (COM)</h2>
<p>COM-Objekte, auf die VBScript und ähnliche Programmiersprachen zugreifen können, sind in der Regel auch für AutoHotkey über <a href="ComObjCreate.htm">ComObjCreate()</a>, <a href="ComObjGet.htm">ComObjGet()</a> oder <a href="ComObjActive.htm">ComObjActive()</a> und die interne <a href="../Objects.htm#Usage_Objects">Objektsyntax</a> zugänglich.</p>
<p>COM-Objekte, die <a href="https://learn.microsoft.com/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch</a> nicht unterstützen, können mit DllCall verwendet werden, indem die Adresse einer Funktion aus der virtuellen Funktionstabelle des Objekt-Interfaces ermittelt wird. Weitere Informationen finden Sie <a href="#ExTaskbar">im Beispiel</a> weiter unten.</p>

<h2 id="dotnet">.NET Framework</h2>
<p>.NET Framework-Bibliotheken werden von einer "virtuellen Maschine" ausgeführt, die als Common Language Runtime (CLR) bekannt ist. In diesem Fall sind .NET-DLL-Dateien anders formatiert als normale DLL-Dateien und enthalten in der Regel keine Funktionen, die von DllCall aufgerufen werden können.</p>
<p>AutoHotkey kann jedoch die CLR über <a href="https://learn.microsoft.com/dotnet/standard/native-interop/com-callable-wrapper">COM Callable Wrapper</a> nutzen. Sofern die Bibliothek nicht auch als allgemeine COM-Komponente registriert ist, muss die CLR selbst zunächst manuell über DllCall initialisiert werden. Weitere Informationen finden Sie unter <a href="https://www.autohotkey.com/boards/viewtopic.php?t=4633">.NET Framework Interop</a>.</p>

<h2 id="Related">Siehe auch</h2>
<p><a href="../Compat.htm#DllCall">Skriptkompatibilität</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity()</a>, <a href="../Functions.htm">Funktionen</a>, <a href="SysGet.htm">SysGet</a>, <a href="https://learn.microsoft.com/docs/">Microsoft Docs</a></p>
<h2 id="Examples">Beispiele</h2>
<div class="ex" id="ExMessageBox">
<p><a class="ex_number" href="#ExMessageBox"></a> Ruft die Windows-API-Funktion "MessageBox" auf und meldet, welche Schaltfläche der Benutzer gedrückt hat.</p>
<pre>WelcheSchaltfl := DllCall("MessageBox", "Int", 0, "Str", "Ja oder Nein drücken", "Str", "Titel der Box", "Int", 4)
MsgBox Sie haben die Schaltfläche #%WelcheSchaltfl% gedrückt.</pre>
</div>

<div class="ex" id="ExWallpaper">
<p><a class="ex_number" href="#ExWallpaper"></a> Ersetzt das Hintergrundbild des Desktops mit der angegebenen Bitmap-Datei (.bmp).</p>
<pre>DllCall("SystemParametersInfo", "UInt", 0x14, "UInt", 0, "Str", A_WinDir <strong>.</strong> "\winnt.bmp", "UInt", 1)</pre>
</div>

<div class="ex" id="ExIsWindowVisible">
<p><a class="ex_number" href="#ExIsWindowVisible"></a> Ruft die API-Funktion "IsWindowVisible" auf, um herauszufinden, ob ein Notepad-Fenster sichtbar ist.</p>
<pre>DetectHiddenWindows On
if not DllCall("IsWindowVisible", "Ptr", WinExist("Unbenannt - Editor"))  <em>; WinExist() gibt eine HWND-Nummer zurück.</em>
    MsgBox Das Fenster ist nicht sichtbar.</pre>
</div>

<div class="ex" id="ExWsprintf">
<p><a class="ex_number" href="#ExWsprintf"></a> Ruft die API-Funktion wsprintf() auf, um die linke Seite der Zahl 432 mit Nullen zu füllen, bis sie 10 Zeichen breit ist (0000000432).</p>
<pre>VarSetCapacity(AufgefüllteZahl, 20)  <em>; Stellt sicher, dass die Variable groß genug für die neue Zeichenkette ist.</em>
DllCall("wsprintf", "Str", AufgefüllteZahl, "Str", "%010d", "Int", 432, "Cdecl")  <em>; Benötigt die Cdecl-Aufrufkonvention.</em>
MsgBox %AufgefüllteZahl%

<em>; <span class="ver">[v1.1.17+]</span>: Dasselbe kann mit der <a href="Format.htm">Format</a>-Funktion in Verbindung mit dem Null-Flag erreicht werden:</em>
MsgBox % Format("{:010}", 432)
</pre>
</div>

<div class="ex" id="QPC">
<p><a class="ex_number" href="#QPC"></a> Zeigt, wie mit QueryPerformanceCounter() eine höhere Präzision als die 10&nbsp;ms von <a href="../Variables.htm#TickCount">A_TickCount</a> erreicht werden kann.</p>
<pre>DllCall("QueryPerformanceFrequency", "Int64*", freq)
DllCall("QueryPerformanceCounter", "Int64*", CounterDavor)
Sleep 1000
DllCall("QueryPerformanceCounter", "Int64*", CounterDanach)
MsgBox % "Die Differenz zwischen den Zeiten beträgt " . (CounterDanach - CounterDavor) / freq * 1000 " ms"</pre>
</div>

<div class="ex" id="ExMouseSpeed">
<p><a class="ex_number" href="#ExMouseSpeed"></a> Drücken Sie einen Hotkey, um die Geschwindigkeit des Mauszeigers vorübergehend zu verringern, was eine genauere Positionierung ermöglicht. Halten Sie <kbd>F1</kbd> gedrückt, um den Mauszeiger zu verlangsamen. Lassen Sie die Taste wieder los, um die originale Geschwindigkeit wiederherzustellen.</p>
<pre>F1::
SPI_GETMOUSESPEED := 0x70
SPI_SETMOUSESPEED := 0x71
<em>; Ruft die aktuelle Geschwindigkeit ab, um sie später wiederherzustellen:</em>
DllCall("SystemParametersInfo", "UInt", SPI_GETMOUSESPEED, "UInt", 0, "UIntP", OrigMausGeschw, "UInt", 0)
<em>; Verringert nun die Geschwindigkeit des Mauszeigers im vorletzten Parameter (im Bereich von 1 bis 20, 10 ist Standard):</em>
DllCall("SystemParametersInfo", "UInt", SPI_SETMOUSESPEED, "UInt", 0, "Ptr", <strong>3</strong>, "UInt", 0)
KeyWait F1  <em>; Verhindert, dass DllCall durch die Autowiederholung der Tastatur wiederholt aufgerufen wird.</em>
return

F1 up::DllCall("SystemParametersInfo", "UInt", SPI_SETMOUSESPEED, "UInt", 0, "Ptr", OrigMausGeschw, "UInt", 0)  <em>; Stellt die Originalgeschwindigkeit wieder her.</em></pre>
</div>

<div class="ex" id="ExWatchScrollBar">
<p><a class="ex_number" href="#ExWatchScrollBar"></a> Überwacht das aktive Fenster und zeigt die Position des vertikalen Scrollbalkens seines fokussierten Steuerelements an (in Echtzeit). Dieses Beispiel benötigt <span class="ver">[v1.0.43.06+]</span>, weil es <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a> verwendet.</p>
<pre>#Persistent
SetTimer, ScrollbalkenÜberwachen, 100
return

ScrollbalkenÜberwachen:
AktivesFenster := WinExist("A")
if not AktivesFenster  <em>; Kein Fenster aktiv.</em>
    return
ControlGetFocus, FokussiertesStrlmnt, ahk_id %AktivesFenster%
if not FokussiertesStrlmnt  <em>; Kein Steuerelement fokussiert.</em>
    return
<em>; Zeigt die vertikale oder horizontale Position des Scrollbalkens in einem Tooltip an:</em>
ControlGet, UnterelementHWND, Hwnd,, %FokussiertesStrlmnt%, ahk_id %AktivesFenster%
ToolTip % DllCall("GetScrollPos", "Ptr", UnterelementHWND, "Int", 1)  <em>;  Letzter Parameter kann 1 für SB_VERT und 0 für SB_HORZ sein.</em>
return</pre>
</div>

<div class="ex" id="file">
<p><a class="ex_number" href="#file"></a> Schreibt etwas Text in eine Datei und liest ihn zurück in den Speicher (benötigt <span class="ver">[v1.0.34+]</span>). Diese Methode ist performanter, wenn es darum geht, mehrere Dateien simultan zu lesen oder zu schreiben. <span class="ver">[AHK_L 42+]</span>: Dasselbe kann mit <a href="FileOpen.htm">FileOpen()</a> erreicht werden. Siehe entsprechendes <a href="FileOpen.htm#writeread">Beispiel</a>.</p>
<pre>FileSelectFile, DateiName, S16,, Neue Datei erstellen:
if (DateiName = "")
    return
GENERIC_WRITE := 0x40000000  <em>; Öffnet eine Datei zum Schreiben statt zum Lesen.</em>
CREATE_ALWAYS := 2  <em>; Erstellt eine neue Datei (überschreibt eine vorhandene Datei).</em>
hFile := DllCall("CreateFile", "Str", DateiName, "UInt", GENERIC_WRITE, "UInt", 0, "Ptr", 0, "UInt", CREATE_ALWAYS, "UInt", 0, "Ptr", 0, "Ptr")
if not hFile
{
    MsgBox Kann "%DateiName%" nicht zum Schreiben öffnen.
    return
}
TestZkette := "Das ist eine Zeichenkette.`r`n"  <em>; Wenn eine Datei auf diese Weise geschrieben wird, sollte `r`n anstelle von `n verwendet werden, um eine neue Zeile zu beginnen.</em>
ZketteLänge := StrLen(TestZkette) * (A_IsUnicode ? 2 : 1)
DllCall("WriteFile", "Ptr", hFile, "Str", TestZkette, "UInt", ZketteLänge, "UIntP", RealGeschriebeneBytes, "Ptr", 0)
DllCall("CloseHandle", "Ptr", hFile)  <em>; Schließt die Datei.</em>

<em>; Die Datei wurde geschrieben, also lese ihren Inhalt zurück in den Speicher.</em>
GENERIC_READ := 0x80000000  <em>; Öffnet die Datei zum Lesen statt zum Schreiben.</em>
OPEN_EXISTING := 3  <em>; Dieser Modus bewirkt, dass die zu öffnende Datei bereits existieren muss.</em>
FILE_SHARE_READ := 0x1 <em>; Dieser und der nächste Modus bestimmen, ob andere Prozesse die bereits geöffnete Datei öffnen dürfen.</em>
FILE_SHARE_WRITE := 0x2
hFile := DllCall("CreateFile", "Str", DateiName, "UInt", GENERIC_READ, "UInt", FILE_SHARE_READ|FILE_SHARE_WRITE, "Ptr", 0, "UInt", OPEN_EXISTING, "UInt", 0, "Ptr", 0)
if not hFile
{
    MsgBox Kann "%DateiName%" nicht zum Lesen öffnen.
    return
}
<em>; Macht die Variable aus Testgründen leer, stellt aber sicher, dass sie genügend Kapazität hat:</em>
ZuLesendeBytes := VarSetCapacity(TestZkette, ZketteLänge)
DllCall("ReadFile", "Ptr", hFile, "Str", TestZkette, "UInt", ZuLesendeBytes, "UIntP", RealGeleseneBytes, "Ptr", 0)
DllCall("CloseHandle", "Ptr", hFile)  <em>; Schließt die Datei.</em>
MsgBox Die folgende Zeichenkette wurde aus der Datei gelesen: %TestZkette%</pre>
</div>

<div class="ex" id="HideCursor">
<p><a class="ex_number" href="#HideCursor"></a> Versteckt den Mauszeiger, wenn Sie <kbd>WIN</kbd>+<kbd>C</kbd> drücken. Um den Mauszeiger wieder sichtbar zu machen, drücken Sie diesen Hotkey erneut. Dieses Skript stammt von <a href="https://www.autohotkey.com/forum/topic6107.html">www.autohotkey.com/forum/topic6107.html</a></p>
<pre>OnExit, ZeigeCursor  <em>; Stellt sicher, dass der Mauszeiger bei Beendigung des Skripts wieder sichtbar gemacht wird.</em>
return

ZeigeCursor:
SystemCursor("On")
ExitApp

#c::SystemCursor("Toggle")  <em>; WIN+C-Hotkey zum Ein- und Ausschalten des Mauszeigers.</em>

SystemCursor(OnOff=1)   <em>; INIT = "I","Init"; OFF = 0,"Off"; TOGGLE = -1,"T","Toggle"; ON = Andere</em>
{
    static AndMask, XorMask, $, h_cursor
        ,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13 <em>; System-Mauszeiger</em>
        , b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13   <em>; Leere Mauszeiger</em>
        , h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13   <em>; Handles von Standardzeigern</em>
    if (OnOff = "Init" or OnOff = "I" or $ = "")       <em>; Initialisierung bei Bedarf oder beim ersten Aufruf</em>
    {
        $ := "h"                                       <em>; Aktive Standardzeiger</em>
        VarSetCapacity( h_cursor,4444, 1 )
        VarSetCapacity( AndMask, 32*4, 0xFF )
        VarSetCapacity( XorMask, 32*4, 0 )
        system_cursors := "32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650"
        StringSplit c, system_cursors, `,
        Loop %c0%
        {
            h_cursor   := DllCall( "LoadCursor", "Ptr",0, "Ptr",c%A_Index% )
            h%A_Index% := DllCall( "CopyImage", "Ptr",h_cursor, "UInt",2, "Int",0, "Int",0, "UInt",0 )
            b%A_Index% := DllCall( "CreateCursor", "Ptr",0, "Int",0, "Int",0
                , "Int",32, "Int",32, "Ptr",&amp;AndMask, "Ptr",&amp;XorMask )
        }
    }
    if (OnOff = 0 or OnOff = "Off" or $ = "h" and (OnOff &lt; 0 or OnOff = "Toggle" or OnOff = "T"))
        $ := "b"  <em>; Leere Mauszeiger nutzen</em>
    else
        $ := "h"  <em>; Gespeicherte Mauszeiger nutzen</em>

    Loop %c0%
    {
        h_cursor := DllCall( "CopyImage", "Ptr",%$%%A_Index%, "UInt",2, "Int",0, "Int",0, "UInt",0 )
        DllCall( "SetSystemCursor", "Ptr",h_cursor, "UInt",c%A_Index% )
    }
}</pre>
</div>

<div class="ex" id="ExStruct">
<p><a class="ex_number" href="#ExStruct"></a> Strukturbeispiel. Übergibt die Adresse einer RECT-Struktur an die GetWindowRect-Funktion, die die Struktur mit den Koordinaten der linken oberen und der rechten unteren Ecke des Fensters füllt (relativ zum Bildschirm).</p>
<pre>Run Notepad
WinWait Unbenannt - Editor  <em>; Setzt auch das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" für WinExist() unten.</em>
VarSetCapacity(Rect, 16)  <em>; RECT ist eine Struktur bestehend aus vier 32-Bit-Integern (also 4*4=16).</em>
DllCall("GetWindowRect", "Ptr", WinExist(), "Ptr", &amp;Rect)  <em>; WinExist() gibt eine HWND-Nummer zurück.</em>
MsgBox % "Links " . <a href="NumGet.htm">NumGet</a>(Rect, 0, "Int") . " Oben " . NumGet(Rect, 4, "Int")
    . " Rechts " . NumGet(Rect, 8, "Int") . " Unten " . NumGet(Rect, 12, "Int")</pre>
</div>

<div class="ex" id="ExStructRect">
<p><a class="ex_number" href="#ExStructRect"></a> Strukturbeispiel. Übergibt FillRect() die Adresse einer RECT-Struktur, die einen Bereich des Bildschirms definiert, der kurzzeitig rot gefärbt werden soll.</p>
<pre>VarSetCapacity(Rect, 16, 0)  <em>; Setzt die Kapazität zum Speichern von vier 4-Byte-Integern und initialisiert sie alle mit Null.</em>
<a href="NumPut.htm">NumPut</a>(A_ScreenWidth//2, Rect, 8, "Int")  <em>; Der dritte Integer in der Struktur ist "rect.right".</em>
NumPut(A_ScreenHeight//2, Rect, 12, "Int") <em>; Der vierte Integer in der Struktur ist "rect.bottom".</em>
hDC := DllCall("GetDC", "Ptr", 0, "Ptr")  <em>; Übergibt Null, um den Gerätekontext des Desktops abzurufen.</em>
hBrush := DllCall("CreateSolidBrush", "UInt", 0x0000FF, "Ptr")  <em>; Erstellt einen roten Pinsel (0x0000FF ist im BGR-Format).</em>
DllCall("FillRect", "Ptr", hDC, "Ptr", &amp;Rect, "Ptr", hBrush)  <em>; Färbt das angegebene Rechteck mit dem obigen Pinsel.</em>
DllCall("ReleaseDC", "Ptr", 0, "Ptr", hDC)  <em>; Gibt Speicher frei.</em>
DllCall("DeleteObject", "Ptr", hBrush)  <em>; Gibt Speicher frei.</em></pre>
</div>

<div class="ex" id="ExSystemTime">
<p><a class="ex_number" href="#ExSystemTime"></a> Strukturbeispiel. Setzt die Systemuhr auf ein bestimmtes Datum und eine bestimmte Uhrzeit. Seien Sie vorsichtig, wenn Sie ein zukünftiges Datum setzen, da dies dazu führen kann, dass geplante Tasks vorzeitig ausgeführt werden!</p>
<pre>SetzeSystemuhr("20051008142211")  <em>; Übergeben Sie einen <a href="FileSetTime.htm#YYYYMMDD">Zeitstempel</a> (lokal, nicht UTC).</em>

SetzeSystemuhr(YYYYMMDDHHMISS)
<em>; Setzt die Systemuhr auf ein bestimmtes Datum und eine bestimmte Uhrzeit.
; Der Aufrufer muss sicherstellen, dass der eingehende Parameter ein gültiger Zeitstempel ist
; (lokale Zeit, nicht UTC). Gibt bei Erfolg ungleich 0 zurück.</em>
{
    <em>; Konvertiert die im Parameter angegebene lokale Zeit in UTC für SetSystemTime().</em>
    UTC_Delta -= A_NowUTC, Seconds  <em>; Sekunden sind genauer, um Rundungsfehler zu vermeiden.</em>
    UTC_Delta := Round(-UTC_Delta/60)  <em>; Rundet auf die nächste Minute für höhere Genauigkeit.</em>
    YYYYMMDDHHMISS += UTC_Delta, Minutes  <em>; Wendet den Offset für die Konvertierung zu UTC an.</em>

    VarSetCapacity(Systemuhr, 16, 0)  <em>; Diese Struktur besteht aus 8 UShorts (also 8*2=16).</em>

    Int := SubStr(YYYYMMDDHHMISS, 1, 4)  <em>; YYYY (Jahr)</em>
    <a href="NumPut.htm">NumPut</a>(Int, Systemuhr, 0, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 5, 2)  <em>; MM (Monat des Jahres, 1-12)</em>
    NumPut(Int, Systemuhr, 2, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 7, 2)  <em>; DD (Tag des Monats)</em>
    NumPut(Int, Systemuhr, 6, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 9, 2)  <em>; HH (Stunden im 24-Stunden-Format)</em>
    NumPut(Int, Systemuhr, 8, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 11, 2) <em>; MI (Minuten)</em>
    NumPut(Int, Systemuhr, 10, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 13, 2) <em>; SS (Sekunden)</em>
    NumPut(Int, Systemuhr, 12, "UShort")

    return DllCall("SetSystemTime", "Ptr", &amp;Systemuhr)
}</pre>
<p>Weitere Strukturbeispiele:</p>
<ul>
  <li>Das <a href="../scripts/index.htm#WinLIRC">WinLIRC-Client-Skript</a> zeigt, wie mit DllCall() eine Netzwerkverbindung zu einem TCP/IP-Server aufgebaut kann und Daten von diesem empfangen werden können.</li>
  <li>Das Betriebssystem stellt Standard-Dialogfenster bereit, die der Benutzer zum Auswählen einer Farbe, einer Schrift oder eines Symbols verwenden kann. Solche Dialogfenster verwenden Strukturen und werden auf <a href="https://github.com/majkinetor/mm-autohotkey/tree/master/Dlg">GitHub</a> vorgestellt.</li>
</ul>
</div>

<div class="ex" id="ExTaskbar">
<p><a class="ex_number" href="#ExTaskbar"></a> Entfernt mittels COM das aktive Fenster temporär aus der Taskleiste.</p>
<pre><em>/*
  Methoden in der <a href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nn-shobjidl_core-itaskbarlist">ITaskbarList</a>-VTable:
    IUnknown:
      0 QueryInterface  -- nutze stattdessen <a href="ComObjQuery.htm">ComObjQuery()</a>
      1 AddRef          -- nutze stattdessen <a href="ObjAddRef.htm">ObjAddRef()</a>
      2 Release         -- nutze stattdessen <a href="ObjAddRef.htm">ObjRelease()</a>
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Erstellt ein TaskbarList-Objekt und speichert dessen Adresse in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

activeHwnd := WinExist("A")

DllCall(vtable(tbl,3), "ptr", tbl)                     <em>; tbl.<a href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-hrinit">HrInit</a>()</em>
DllCall(vtable(tbl,5), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-deletetab">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
DllCall(vtable(tbl,4), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-itaskbarlist-addtab">AddTab</a>(activeHwnd)</em>

<em>; Nicht-Dispatch-Objekte müssen immer manuell freigegeben werden.</em>
ObjRelease(tbl)

vtable(ptr, n) {
    <em>; NumGet(ptr+0) gibt die Adresse der virtuellen Funktionstabelle
    ; des Objekts (kurz: vtable) zurück. Der Rest des Ausdrucks ruft
    ; die Adresse der n-ten Funktionsadresse aus der vtable ab.</em>
    return NumGet(NumGet(ptr+0), n*A_PtrSize)
}
</pre>
</div>

</body>
</html>
