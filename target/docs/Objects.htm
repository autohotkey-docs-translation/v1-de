<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Objekte - Definition &amp; Verwendung | AutoHotkey v1</title>
<meta name="description" content="Erfahren Sie mehr über die grundlegende Verwendung von Objekten, die erweiterte Verwendung von Objekten, benutzerdefinierte Objekte, Standardbasisobjekte und die Implementierung von Objekten." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> in AutoHotkey ist ein abstrakter Datentyp, der drei Grundfunktionen bereitstellt:</p>
<ul>
  <li>GET – Abrufen eines Wertes.</li>
  <li>SET – Setzen eines Wertes.</li>
  <li>CALL – Aufrufen einer Methode (also einer Funktion, die etwas mit dem Zielobjekt macht).</li>
</ul>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung von Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
</ul>

<p>Mit <b>IsObject()</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Eine Liste von Standardobjekttypen finden Sie unter <em>Objekttypen</em> in der Seitenleiste der Dokumentation. Es gibt drei Grundtypen:</p>
<ul>
  <li><a href="lib/Object.htm"><b>Objekt</b></a>: Der Basistyp für alle benutzerdefinierten Objekte, einfache Arrays und assoziative Arrays.</li>
  <li><strong>Interne Objekte</strong> wie z.B. <a href="lib/File.htm">File</a>. Interne Objekte haben einen festen Satz von Eigenschaften und Methoden und erlauben nicht das Hinzufügen neuer Eigenschaften oder Methoden.</li>
  <li><strong>COM-Wrapper-Objekte</strong>. Diese repräsentieren typischerweise ein COM- oder "Automation"-Objekt, das die <a href="https://learn.microsoft.com/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch-Schnittstelle</a> implementiert, werden aber auch verwendet, um <a href="lib/ComObjActive.htm">Werte bestimmter Typen zu wrappen</a>, die an COM-Objekte und -Funktionen übergeben werden sollen. COM-Objekte sind von externen Bibliotheken implementiert und haben daher oft ein anderes Verhalten als AutoHotkey-Objekte. </li>
</ul>
<p>Objekte werden ab <span class="ver">[AHK_L 31]</span> unterstützt, einige Features erfordern jedoch eine neuere Version.</p>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlegende Verwendung</a> – <a href="#Usage_Simple_Arrays">Einfache Arrays</a>, <a href="#Usage_Associative_Arrays">Assoziative Arrays</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Objekte freigeben</a>, <a href="#Usage_Remarks">Bemerkungen</a></li>
  <li><a href="#Extended_Usage">Erweiterte Verwendung</a> – <a href="#Function_References">Funktionsreferenzen</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>, <a href="#Usage_Arrays_of_Functions">Arrays mit Funktionen</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> – <a href="#Custom_Prototypes">Prototypen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Metafunktionen</a></li>
  <li><a href="#Default_Base_Object">Standardbasisobjekt</a> – <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
  <li><a href="#Implementation">Implementierung</a> – <a href="#Reference_Counting">Referenzzählung</a>, <a href="#Implementation_Pointers">Objektpointer</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlegende Verwendung</h2>
<h3 id="Usage_Simple_Arrays">Einfache Arrays <span class="ver">[v1.1.21+]</span></h3>
<p>Erstellen eines Arrays:</p>
<pre>Array := [Element1, Element2, ..., ElementN]
Array := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Index]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Index] := Wert</pre>
<p>Einfügen eines oder mehrerer Elemente ab einem bestimmten Index via <a href="lib/Object.htm#InsertAt">InsertAt</a>-Methode:</p>
<pre>Array.InsertAt(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder mehrerer Elemente via <a href="lib/Object.htm#Push">Push</a>-Methode:</p>
<pre>Array.Push(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements via <a href="lib/Object.htm#RemoveAt">RemoveAt</a>-Methode:</p>
<pre>EntfernterWert := Array.RemoveAt(Index)</pre>
<p>Entfernen eines Elements via <a href="lib/Object.htm#Pop">Pop</a>-Methode:</p>
<pre>EntfernterWert := Array.Pop()</pre>
<p><a href="lib/Object.htm#MinMaxIndex">MinIndex</a> und <a href="lib/Object.htm#MinMaxIndex">MaxIndex</a>/<a href="lib/Object.htm#Length">Length</a> geben den niedrigsten bzw. höchsten Index eines nicht-leeren Arrays zurück. Da der niedrigste Index fast immer 1 ist, gibt MaxIndex üblicherweise die Anzahl der Elemente zurück. Wenn jedoch keine Integerschlüssel vorhanden sind, gibt MaxIndex eine leere Zeichenkette zurück, während Length 0 zurückgibt. Um die Elemente eines Arrays einzeln durchzugehen, verwenden Sie entweder A_Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>Array := ["eins", "zwei", "drei"]

<em>; Von 1 bis zum Ende des Arrays iterieren:</em>
<a href="lib/Loop.htm">Loop</a> % Array.Length()
    MsgBox % Array[A_Index]

<em>; Den Inhalt des Arrays enumerieren:</em>
<a href="lib/For.htm">For</a> Index, Wert in Array
    MsgBox % "Element " Index " ist '" Wert "'"
</pre>

<span id="Arrays"></span><h3 id="Usage_Associative_Arrays">Assoziative Arrays <span class="ver">[v1.1.21+]</span></h3>
<p>Ein assoziatives Array ist ein Objekt, das eine Sammlung von eindeutigen Schlüsseln und eine Sammlung von Werten enthält, wobei jeder Schlüssel mit einem Wert verbunden ist. Schlüssel können Zeichenketten, Integer oder Objekte sein, während Werte von beliebigem Typ sein können. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>Array := {SchlüsselA: WertA, SchlüsselB: WertB, ..., SchlüsselZ: WertZ}
Array := Object("SchlüsselA", WertA, "SchlüsselB", WertB, ..., "SchlüsselZ", WertZ)</pre>
<p>Wenn die <code>{Schlüssel:Wert}</code>-Schreibweise verwendet wird, sind die Anführungszeichen für Schlüssel optional, solange die Schlüssel nur aus Wortzeichen bestehen. Der Schlüssel kann ein beliebiger Ausdruck sein, aber um eine Variable als Schlüssel zu verwenden, muss sie in runde Klammern gesetzt werden. Zum Beispiel wären sowohl <code>{(SchlüsselVar): Wert}</code> als auch <code>{GetKey(): Wert}</code> gültig.</p>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Schlüssel]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Schlüssel] := Wert</pre>
<p>Entfernen eines Elements via <a href="lib/Object.htm#Delete">Delete</a>-Methode:</p>
<pre>EntfernterWert := Array.Delete(Schlüssel)</pre>
<p>Enumerieren von Elementen:</p>
<pre>array := {zehn: 10, zwanzig: 20, dreißig: 30}
<a href="lib/For.htm">For</a> Schlüssel, Wert in Array
    MsgBox %Schlüssel% = %Wert%</pre>
<p>Assoziative Arrays können lückenhaft gefüllt sein – z.B. enthält <code>{1: "a", 1000: "b"}</code> nur zwei Schlüssel-Wert-Paare, nicht 1000.</p>
<p id="same_thing">In AutoHotkey v1.x sind einfache Arrays und assoziative Arrays dasselbe. Die Behandlung von <code>[]</code> als einfaches lineares Array dient jedoch der Übersichtlichkeit und erhöht die Chance, dass Ihr Skript auch mit einer zukünftigen Version von AutoHotkey funktioniert, die möglicherweise zwischen einfachen Arrays und assoziativen Arrays unterscheidet.</p>

<h3 id="Usage_Objects">Objekte <span class="ver">[AHK_L 31+]</span></h3>
<p>Für alle Objekttypen kann die Schreibweise <code>Objekt.DirektGeschriebenerSchlüssel</code> verwendet werden, um auf eine Eigenschaft, ein Array oder eine Methode zuzugreifen, wobei <em>DirektGeschriebenerSchlüssel</em> ein Identifikator oder Integer und <em>Objekt</em> ein beliebiger Ausdruck ist. Identifikatoren sind anführungszeichenlose Zeichenketten, die aus alphanumerischen Zeichen, Unterstrichen und in <span class="ver">[v1.1.09+]</span> aus ASCII-fremden Zeichen bestehen können. Zum Beispiel ist <code>match.Pos</code> äquivalent zu <code>match["Pos"]</code>, während <code>arr.1</code> äquivalent zu <code>arr[1]</code> ist. Nach dem Punkt darf kein Leerzeichen stehen.</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen einer Eigenschaft:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<p>Setzen einer Eigenschaft:</p>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Aufrufen einer Methode:</p>
<pre>RückgabeWert := Objekt.Methode(Params)</pre>
<p>Aufrufen einer Methode mit einem generierten Methodennamen:</p>
<pre>RückgabeWert := Objekt[MethodeName](Params)</pre>
<p>Einige Eigenschaften von COM-Objekten und benutzerdefinierten Objekten können Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Params]
Objekt.Eigenschaft[Params] := Wert</pre>
<p><strong>Siehe auch:</strong> <a href="lib/Object.htm">Objekt</a>, <a href="lib/File.htm">File-Objekt</a>, <a href="lib/Func.htm">Func-Objekt</a>, <a href="lib/ComObjCreate.htm">COM-Objekt</a></p>
<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Derzeit wird <code><span class="dull">x</span>.y[z]<span class="dull">()</span></code> wie <code><span class="dull">x</span>["y", z]<span class="dull">()</span></code> behandelt, aber nicht unterstützt. Als Workaround kann <code><span class="red">(</span><span class="dull">x.y</span><span class="red">)</span>[z]()</code> verwendet werden, um zuerst <code>x.y</code> auswerten zu lassen und dann das Ergebnis als Ziel des Methodenaufrufs zu verwenden. Beachten Sie, dass <code>x.y[z].Call()</code> diese Einschränkung nicht hat, da es genauso wie <code>(x.y[z]).Call()</code> ausgewertet wird.</li></ul>

<h3 id="Usage_Freeing_Objects">Objekte freigeben</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald die letzte Referenz zu einem Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Eine Referenz, die in einer Variable gespeichert ist, wird automatisch freigegeben, sobald dieser Variable ein anderer Wert zugewiesen wird. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt die letzte Referenz frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Gleichermaßen wird eine Referenz, die in einem Feld eines anderen Objekts gespeichert ist, freigegeben, wenn dieses Feld einen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird. Dies gilt auch für Arrays, weil sie praktisch dasselbe sind wie Objekte.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt das zweite Objekt und gibt es frei.</em></pre>
<p id="Circular_References">Da alle Referenzen zu einem Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn z.B. <code>x.child</code> auf <code>y</code> und <code>y.parent</code> auf <code>x</code> verweist, genügt es nicht, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch eine Referenz zum Child-Objekt enthält, und umgekehrt. Um diese Situation zu lösen, entfernen Sie den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Zwei Objekte erstellen.</em>
x.child := y, y.parent := x  <em>; Einen Zirkelbezug erstellen.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Ohne die obige Zeile würde dies die Objekte nicht freigeben.</em>
</pre>
<p>Eine ausführlichere Verwendung und Informationen finden Sie unter <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h3 id="Usage_Remarks">Bemerkungen</h3>

<h4 id="Remarks_Syntax">Syntax</h4>
<p>Alle Objekttypen unterstützen sowohl die Arraysyntax (eckige Klammern) als auch die Objektsyntax (Punkte).</p>
<p>Außerdem können Objektreferenzen selbst in Ausdrücken verwendet werden:</p>
<ul>
  <li>Beim Vergleich einer Objektreferenz mit einem anderen Wert via <code>=</code>, <code>==</code>, <code>!=</code> oder <code>&lt;&gt;</code> werden diese nur dann als gleich gewertet, wenn beide Werte auf dasselbe Objekt verweisen.</li>
  <li>Objekte werden immer als <i>True</i> behandelt, wenn ein boolescher Wert erforderlich ist, wie z.B. in <code>if obj</code>, <code>!obj</code> oder <code>obj ? x : y</code>.</li>
  <li>Eine Objektadresse kann mit dem <code>&amp;</code>-Operator abgerufen werden. Dies identifiziert eindeutig das Objekt, vom Zeitpunkt seiner Erstellung bis zum Zeitpunkt der <a href="#Refs">Freigabe</a> seiner letzten Referenz.</li>
</ul>
<p>Wenn ein Objekt in einem Kontext verwendet wird, wo kein Objekt erwartet wird, wird es als leere Zeichenkette behandelt. Zum Beispiel bewirkt <code>MsgBox %Objekt%</code>, dass ein leeres Mitteilungsfenster angezeigt wird, und <code>Objekt + 1</code>, dass eine leere Zeichenkette zurückgegeben wird. Verlassen Sie sich nicht auf dieses Verhalten, da es sich in einer zukünftigen Version ändern kann.</p>
<p>Wenn unmittelbar nach einem Methodenaufruf ein Zuweisungsoperator folgt, entspricht dies dem Setzen einer Eigenschaft mit Parametern. Zum Beispiel sind die folgenden Zeilen funktionsgleich:</p>
<pre>obj.item(x) := y
obj.item[x] := y</pre>
<p id="cassign">Verbundzuweisungen wie <code>x.y += 1</code> und <code>--arr[1]</code> werden unterstützt.</p>
<p><span class="ver">[v1.1.20+]</span>: Parameter können beim Abrufen oder Setzen von Eigenschaften weggelassen werden. Zum Beispiel <code>x[,2]</code>. Skripte können damit Standardwerte für Parameter in <a href="#Custom_Classes_property">Eigenschaften</a> und <a href="#Meta_Functions">Metafunktionen</a> definieren. Der Methodenname kann zudem komplett weggelassen werden, wie z.B. in <code>x[](a)</code>. Skripte können damit einen Standardwert für den ersten Parameter der __Call-<a href="#Meta_Functions">Metafunktion</a> definieren, um zu verhindern, dass dieser ohne Wert übergeben wird. Beachten Sie, dass sich dies von <code>x.(a)</code> unterscheidet, das äquivalent zu <code>x[""](a)</code> ist. Wenn beim Aufruf eines COM-Objekts der Eigenschafts- oder Methodenname weggelassen wird, wird dessen "Standardelement" indirekt aufgerufen.</p>

<h4 id="Keys">Schlüssel (Keys)</h4>
<p>Es gibt einige Einschränkungen, welche Werte als Schlüssel innerhalb von Objekten, die mit <code>[]</code>, <code>{}</code> oder dem <code>new</code>-Operator erstellt wurden, verwendet werden können:</p>
<ul>
  <li>Integerschlüssel werden unter Verwendung des nativen vorzeichenfähigen Integertyps gespeichert. AutoHotkey 32-Bit unterstützt Integerschlüssel im Bereich von -2147483648 bis 2147483647 und kürzt Werte außerhalb dieses Bereichs. AutoHotkey unterstützt 64-Bit-Integer, aber nur AutoHotkey 64-Bit unterstützt den vollen Bereich als Schlüssel in einem Objekt.</li>
  <li>Das Zeichenkettenformat von Integerwerten wird nicht beibehalten. Zum Beispiel erzeugt AutoHotkey v1 zwei verschiedene Zeichenketten für <code>0x10</code> und <code>16</code> (im Gegensatz zu <a href="https://www.autohotkey.com/v2/">AutoHotkey v2</a>), während <code>x[0x10]</code>, <code>x[16]</code> und <code>x[00016]</code> äquivalent sind, da nur der numerische Wert verwendet wird.</li>
  <li>Numerische Zeichenketten, die keinen Dezimalpunkt enthalten, werden in reine Integer umgewandelt und unterliegen daher den oben beschriebenen Einschränkungen. Numerische Zeichenketten außerhalb des 64-Bit-Bereichs können zu inkonsistenten Ergebnissen führen.</li>
  <li>In Anführungszeichen gesetzte Zeichenketten werden in v1.x als rein nicht-numerisch behandelt, d.h. <code>x[1]</code> und <code>x["1"]</code> sind <i>nicht</i> äquivalent. Die Verkettung einer in Anführungszeichen gesetzten Zeichenkette mit einem anderen Wert (z.B. <code>"0x" x</code>) wird ebenfalls als rein nicht-numerisch behandelt. Dies gilt jedoch nicht für Variablen, d.h. <code>x[1]</code> und <code>x[y:="1"]</code> sind äquivalent. Dieses Problem wird in <a href="https://www.autohotkey.com/v2/">AutoHotkey v2</a> behoben, daher sollte man vermeiden, in Anführungszeichen gesetzte Zahlen als Schlüssel zu verwenden.</li>
  <li>Floating-Point-Zahlen werden nicht als Schlüssel unterstützt – stattdessen werden sie in Zeichenketten umgewandelt. In v1.x behalten direkt geschriebene Floating-Point-Zahlen ihr ursprüngliches Format, während reine Floating-Point-Zahlen (wie z.B. das Ergebnis von <code>0+1.0</code> oder <code>Sqrt(y)</code>) in das aktuelle <a href="lib/SetFormat.htm">Float-Format</a> gezwungen werden. Aus Gründen der Konsistenz und Übersichtlichkeit sollten Sie vermeiden, direkt geschriebene Floating-Point-Zahlen als Schlüssel zu verwenden.</li>
  <li id="base-key">Standardmäßig bezieht sich der Zeichenkettenschlüssel "base" auf die <a href="lib/Object.htm#Base">Base</a>-Eigenschaft des Objekts, so dass er nicht für die Speicherung gewöhnlicher Werte mit einer normalen Zuweisung verwendet werden kann. Jede Eigenschaft kann jedoch überschrieben werden, wenn ein Wert auf andere Weise gespeichert wird, z.B. <code><a href="lib/Object.htm#RawSet">ObjRawSet</a>(Objekt, "base", "")</code> oder <code><a href="lib/Object.htm#SetCapacity">Objekt.SetCapacity</a>("base", 0)</code>. Danach verhält sich der Schlüssel "base" wie jede andere Zeichenkette.</li>
  <li>Obwohl die Namen von <a href="lib/Object.htm">internen Methoden</a> wie "Length" als Schlüssel verwendet werden können, verhindert das Speichern eines Wertes, dass die entsprechende Methode aufgerufen werden kann (es sei denn, der Wert selbst verweist auf die entsprechende Funktion, wie z.B. <em>ObjLength</em>).</li>
</ul>

<h2 id="Extended_Usage">Erweiterte Verwendung</h2>
<h3 id="Function_References">Funktionsreferenzen <span class="ver">[v1.1.00+]</span></h3>
<p>Wenn die folgende Variable <i>Funk</i> den Namen einer Funktion enthält, kann die Funktion wie folgt aufgerufen werden: <code>%Funk%()</code> oder <code>Funk.()</code>. Dies erfordert jedoch, dass der Funktionsname jedes Mal aufgelöst werden muss, was ineffizient ist, wenn die Funktion mehr als einmal aufgerufen wird. Zur Verbesserung der Performanz kann das Skript die Funktionsreferenz abrufen und für die spätere Verwendung speichern:</p>
<pre>Funk := Func("MeineFunk")</pre>
<p>Mit der folgenden Syntax kann eine Funktion via Referenz aufgerufen werden:</p>
<pre>
RückWert := %Funk%(<i>Params</i>)     <em>; Benötigt <span class="ver">[v1.1.07+]</span></em>
RückWert := Funk.Call(<i>Params</i>)  <em>; Benötigt <span class="ver">[v1.1.19+]</span></em>
RückWert := Funk.(<i>Params</i>)      <em>; Nicht empfohlen</em>
</pre>
<p>Weitere Eigenschaften von Funktionsreferenzen finden Sie unter <a href="lib/Func.htm">Func-Objekt</a>.</p>

<span id="JaggedArrays"></span><h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>AutoHotkey unterstützt "mehrdimensionale" Arrays durch transparentes Speichern von Arrays in andere Arrays. Zum Beispiel kann eine Tabelle als ein Array von Zeilen dargestellt werden, wobei jede Zeile selbst ein Array von Spalten ist. In diesem Fall kann der Inhalt der Spalte <code>y</code> von der Zeile <code>x</code> mit einer der folgenden Methoden gesetzt werden:</p>
<pre>Tabelle[x][y] := Inhalt  <em>; A</em>
Tabelle[x, y] := Inhalt  <em>; B</em></pre>
<p>Wenn <code>Tabelle[x]</code> nicht existiert, unterscheiden sich <span class="Code"><em>A</em></span> und <span class="Code"><em>B</em></span> wie folgt:</p>
<ul>
  <li><span class="Code"><em>A</em></span> schlägt fehl, während <span class="Code"><em>B</em></span> automatisch ein Objekt erstellt und in <code>Tabelle[x]</code> speichert.</li>
  <li>Wenn die <a href="#Custom_Objects">Basis</a> von <code>Tabelle</code> <a href="#Meta_Functions">Metafunktionen</a> definiert, werden diese wie folgt indirekt aufgerufen:
  <pre>Tabelle.base.__Get(Tabelle, x)<span class="dull">[y] := Inhalt</span>   <em>; A</em>
Tabelle.base.__Set(Tabelle, x, y, Inhalt)     <em>; B</em></pre>
  Folglich erlaubt <span class="Code"><em>B</em></span> dem Objekt, ein benutzerdefiniertes Verhalten für die gesamte Zuweisung zu definieren.</li>
</ul>
<p>Mehrdimensionale Zuweisungen wie <code>Tabelle[a, b, c, d] := Wert</code> werden wie folgt behandelt:</p>
<ul>
  <li>Wenn nur ein Schlüssel übrig ist, die Zuweisung ausführen und zurückgeben. Andernfalls:</li>
  <li>Im Objekt nach dem ersten Schlüssel in der Liste suchen.</li>
  <li>Wenn ein Nicht-Objekt gefunden wird, fehlschlagen.</li>
  <li>Wenn kein Objekt gefunden wird, eines erstellen und speichern.</li>
  <li>Das Unterobjekt rekursiv indirekt aufrufen und dabei die restlichen Schlüssel und den Wert übergeben – von vorne beginnen.</li>
</ul>
<p>Dieses Verhalten gilt nur für Objekte, die per Skript erstellt wurden, nicht für spezielle Objekttypen wie COM-Objekte oder COM-Arrays.</p>

<span id="FuncArrays"></span><h3 id="Usage_Arrays_of_Functions">Arrays mit Funktionen</h3>
<p>Ein Array mit Funktionen ist im Prinzip ein Array, das Funktionsnamen oder -referenzen enthält. Zum Beispiel:</p>
<pre>Array := [Func("ErsteFunk"), Func("ZweiteFunk")]

<em>; Jede Funktion aufrufen und "foo" als Parameter übergeben:</em>
Loop 2
    Array[A_Index].Call("foo")

<em>; Jede Funktion aufrufen und implizit das Array selbst als Parameter übergeben:</em>
Loop 2
    Array[A_Index]()

ErsteFunk(Param) {
    MsgBox % A_ThisFunc ": " (IsObject(Param) ? "Objekt" : Param)
}
ZweiteFunk(Param) {
    MsgBox % A_ThisFunc ": " (IsObject(Param) ? "Objekt" : Param)
}</pre>
<p>Aus Gründen der Abwärtskompatibilität wird die zweite Form <i>Array</i> nicht als Parameter übergeben, wenn <code>Array[A_Index]</code> einen Funktionsnamen anstelle einer Funktionsreferenz enthält. Wenn jedoch <code>Array[A_Index]</code> von <code>Array.base[A_Index]</code> <a href="#Custom_Objects">geerbt</a> wurde, wird <i>Array</i> als Parameter übergeben.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Objekte, die per Skript erstellt wurden, müssen nicht zwingend eine vordefinierte Struktur haben. Stattdessen kann jedes Objekt Eigenschaften und Methoden von seinem <em>Basisobjekt</em>, auch "Prototyp" oder "Klasse" genannt, erben. Einem Objekt können jederzeit Eigenschaften und Methoden hinzugefügt (oder entfernt) werden; solche Änderungen wirken sich auf alle abgeleiteten Objekte aus. Für komplexere oder speziellere Fälle kann ein Basisobjekt das Standardverhalten von jedem abgeleiteten Objekt überschreiben, indem <a href="#Meta_Functions"><i>Metafunktionen</i></a> definiert werden.</p>
<p><em>Basisobjekte</em> sind ganz normale Objekte, die wie folgt erstellt werden können:</p>
<pre>class Basisobjekt {
    static foo := "bar"
}
<em>; ODER</em>
Basisobjekt := {foo: "bar"}</pre>
<p>Um ein Objekt zu erstellen, das von einem anderen Objekt abgeleitet wurde, können Skripte diesem Objekt die <a href="lib/Object.htm#Base">Base-Eigenschaft</a> zuweisen oder das <a href="#Custom_NewDelete"><code>new</code>-Schlüsselwort</a> verwenden:</p>
<pre>obj1 := Object(), obj1.base := Basisobjekt
obj2 := {base: Basisobjekt}
obj3 := new Basisobjekt
MsgBox % obj1.foo " " obj2.foo " " obj3.foo</pre>
<p>Es ist jederzeit möglich, einem Objekt eine neue <em>Basis</em> zuzuweisen, um alle Eigenschaften und Methoden, die das Objekt geerbt hat, nachhaltig zu ersetzen.</p>

<h3 id="Custom_Prototypes">Prototypen</h3>
<p>Prototypen oder <em>Basisobjekte</em> können wie jedes andere Objekt konstruiert und manipuliert werden. Das folgende Beispiel zeigt, wie ein gewöhnliches Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Ein Objekt erstellen.</em>
obj := {}
<em>; Einen Wert speichern.</em>
obj.foo := "bar"
<em>; Eine Methode durch Speichern einer Funktionsreferenz erstellen.</em>
obj.test := Func("obj_test")
<em>; Die Methode aufrufen.</em>
obj.test()

obj_test(this) {
    MsgBox % this.foo
}</pre>
<p>Beim Aufruf von <code>obj.test()</code> wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Allerdings geschieht dies aus Gründen der Abwärtskompatibilität nicht, wenn eine Funktion direkt per Name (statt per Referenz) in das Objekt gespeichert wird (statt von einem Basisobjekt geerbt zu werden). Konventionsgemäß setzt sich der Name der Funktion aus dem "Typ" des Objekts und dem Namen der Methode zusammen.</p>
<p>Ein Objekt gilt als <i>Prototyp</i> oder <i>Basis</i>, wenn ein anderes Objekt von ihm ableitet:</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p><i>anderesObj</i> erbt in diesem Fall <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch, d.h. wenn <code>obj.foo</code> geändert wird, wird diese Änderung durch <code>anderesObj.foo</code> widergespiegelt. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Effekt auf <code>anderesObj.foo</code>. Beim Aufruf von <code>anderesObj.test()</code> enthält dessen <i>this</i>-Parameter eine Referenz zu <i>anderesObj</i> statt zu <i>obj</i>.</p>

<h3 id="Custom_Classes">Klassen <span class="ver">[v1.1.00+]</span></h3>
<p>Eine "Klasse" ist im Grunde eine Gruppe oder Kategorie von Dingen, die gemeinsame Eigenschaften oder Attribute haben. Da ein <a href="#Custom_Objects">Basisobjekt</a> oder <a href="#Custom_Prototypes">Prototypobjekt</a> Eigenschaften und Verhaltensweisen für eine Gruppe von Objekten definiert, kann es auch als <em>Klassenobjekt</em> bezeichnet werden. Das folgende Beispiel zeigt, wie Basisobjekte einfach mit dem Schlüsselwort "class" definiert werden können:</p>
<pre>class KlasseName extends BasisklasseName
{
    InstanzVar := Ausdruck
    static KlasseVar := Ausdruck

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }

    Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
    {
        get {
            return ...
        }
        set {
            return ... := value
        }
    }
}
</pre>
<p>Dies bewirkt, dass beim Laden des Skripts ein Objekt konstruiert und in die globale (oder in <span class="ver">[v1.1.05+]</span> in die <a href="Functions.htm#SuperGlobal">superglobale</a>) Variable <i>KlasseName</i> gespeichert wird. Um diese Klasse innerhalb einer <a href="Functions.htm#ForceLocal">Force-Local</a>-Funktion (oder vor <span class="ver">[v1.1.05]</span> innerhalb einer Assume-Local- oder Assume-Static-Funktion) zu referenzieren, ist eine Deklaration wie <code>global KlasseName</code> erforderlich. Wenn <code class="no-highlight">extends BasisklasseName</code> vorhanden ist, muss <i>BasisklasseName</i> der vollständige Name einer anderen Klasse sein (in <span class="ver">[v1.1.11+]</span> spielt die Reihenfolge ihrer Definition keine Rolle mehr). Der vollständige Name jeder Klasse ist in <code><i>Objekt</i>.__Class</code> gespeichert.</p>
<p>Da die Klasse via Variable referenziert wird, kann der Klassenname nicht verwendet werden, um im selben Kontext sowohl die Klasse zu referenzieren als auch eine separate Variable zu erstellen (um z.B. eine Instanz der Klasse zu enthalten). Zum Beispiel würde <code>box := new Box</code> das Klassenobjekt in <em>Box</em> mit einer Instanz von sich selbst ersetzen. <span class="ver">[v1.1.27+]</span>: <a href="lib/_Warn.htm#ClassOverwrite">#Warn ClassOverwrite</a> kann verwendet werden, um eine Warnung anzuzeigen, wenn versucht wird, eine Klasse zu überschreiben.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen <span class="ver">[v1.1.01+]</span></h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse (also jedes Objekt, das von der Klasse abgeleitet wurde) eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert, aber ohne Angabe des Präfixes <code>this.</code> (nur direkt im Körper der Klasse):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit dem <a href="#Custom_NewDelete">new</a>-Schlüsselwort erstellt wird. Für diesen Zweck ist der Methodenname <code>__Init</code> reserviert, der aber nicht vom Skript verwendet werden sollte. Die <a href="#Custom_NewDelete">__New()</a>-Methode wird aufgerufen, nachdem alle Deklarationen dieser Art (auch solche, die in Basisklassen definiert wurden) ausgewertet wurden. <em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, aber alle anderen Variablenreferenzen werden als global betrachtet.</p>
<p>Um auf eine Instanzvariable zuzugreifen (auch innerhalb einer Methode), geben Sie immer das Zielobjekt an, z.B. <code><b>this</b>.InstanzVar</code>.</p>
<p><span class="ver">[v1.1.08+]</span>: Deklarationen wie <code>x.y := z</code> werden ebenfalls unterstützt, sofern vorher <code>x</code> in dieser Klasse deklariert wurde. Zum Beispiel bewirkt <code>x := {}, x.y := 42</code>, dass <code>x</code> deklariert und außerdem <code>this.x.y</code> initialisiert wird.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen <span class="ver">[v1.1.00.01+]</span></h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, können aber von abgeleiteten Objekten (einschließlich Unterklassen) geerbt werden. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlasseVar := Ausdruck</pre>
<p>Statische Deklarationen werden nur einmal ausgewertet, vor dem <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a>, in der Reihenfolge ihres Erscheinens im Skript. Jede Deklaration speichert einen Wert in das Klassenobjekt. Alle Variablenreferenzen in <i>Ausdruck</i> werden als global betrachtet.</p>
<p>Um einer Klassenvariable etwas zuzuweisen, geben Sie immer das Klassenobjekt an, z.B. <code><b>KlasseName</b>.KlasseVar := Wert</code>. Wenn ein Objekt <em>x</em> von <em>KlasseName</em> abgeleitet wurde und wenn <em>x</em> selbst nicht den Schlüssel "KlasseVar" enthält, kann auch <code>x.KlasseVar</code> verwendet werden, um dynamisch den Wert von <code>KlasseName.KlasseVar</code> abzurufen. Allerdings würde <code>x.KlasseVar := y</code> den Wert in <em>x</em> speichern, nicht in <em>KlasseName</em>.</p>
<p><span class="ver">[v1.1.08+]</span>: Deklarationen wie <code>static x.y := z</code> werden ebenfalls unterstützt, sofern vorher <code>x</code> in dieser Klasse deklariert wurde. Zum Beispiel bewirkt <code>static x := {}, x.y := 42</code>, dass <code>x</code> deklariert und außerdem <code><i>KlasseName</i>.x.y</code> initialisiert wird.</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelte Klassendefinitionen ermöglichen es, ein Klassenobjekt innerhalb eines anderen Klassenobjekts zu speichern, anstatt eine separate globale Variable zu verwenden. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein Objekt und speichert es in <code>KlasseName.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code>new this.VerschachtelteKlasse</code> die entsprechende Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der üblicherweise eine Referenz zu einem Objekt enthält, das von der Klasse abgeleitet wurde. Allerdings kann dieser Parameter auch eine Referenz zu der Klasse selbst oder zu einer abgeleiteten Klasse enthalten, je nachdem, wie die Methode aufgerufen wurde. Methoden werden <a href="#Function_References">per Referenz</a> in das Klassenobjekt gespeichert.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p id="Custom_Classes_base">Innerhalb einer Methode kann das Pseudoschlüsselwort <code>base</code> verwendet werden, um auf Superklassenversionen von Methoden oder Eigenschaften zuzugreifen, die in einer abgeleiteten Klasse überschrieben werden. Zum Beispiel würde <code>base.Methode()</code> in der oben definierten Klasse eine Version von <em>Methode</em> aufrufen, die durch <em>BasisklasseName</em> definiert ist. <a href="#Meta_Functions">Metafunktionen</a> werden nicht aufgerufen; andernfalls verhält sich <code>base.Methode()</code> wie <code>BaseKlasseName.Methode.Call(this)</code>. Das heißt,</p>
<ul>
  <li>dass <code>base.Methode()</code> immer dort die Basis der Klasse indirekt aufruft, wo die aktuelle Methode definiert wurde, auch dann, wenn <code>this</code> von einer <em>Unterklasse</em> dieser Klasse oder von einer ganz anderen Klasse abgeleitet wurde.</li>
  <li>dass <code>base.Methode()</code> implizit <code>this</code> als ersten (versteckten) Parameter übergibt.</li>
</ul>
<p><code>base</code> hat nur eine besondere Bedeutung, wenn dahinter ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> steht, daher wird so etwas wie <code>obj := base, obj.Methode()</code> nicht funktionieren. Skripte können das spezielle Verhalten von <i>base</i> deaktivieren, indem sie diesem einen nicht-leeren Wert zuweisen; dies wird jedoch nicht empfohlen. Da die Variable <i>base</i> leer sein muss, kann die Leistung beeinträchtigt sein, wenn das Skript ohne <a href="lib/_NoEnv.htm">#NoEnv</a> verwendet wird.</p>

<h4 id="Custom_Classes_property">Eigenschaften <span class="ver">[v1.1.16+]</span></h4>
<p>Eigenschaftsdefinitionen ermöglichen die Ausführung einer Methode, wann immer das Skript einen bestimmten Schlüssel abruft oder setzt.</p>
<pre>Eigenschaft[]
{
    get {
        return ...
    }
    set {
        return ... := value
    }
}</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, der für ihren indirekten Aufruf verwendet wird. Zum Beispiel bewirkt <code>obj.Eigenschaft</code>, dass <em>get</em> aufgerufen wird, und <code>obj.Eigenschaft := Wert</code>, dass <em>set</em> aufgerufen wird. Innerhalb von <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das gerade indirekt aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der gerade zugewiesen wird.</p>
<p>Parameter können übergeben werden, indem sie in eckige Klammern rechts vom Eigenschaftsnamen gesetzt werden, sowohl bei der Definition der Eigenschaft als auch bei ihrem Aufruf. Abgesehen von der Verwendung eckiger Klammern werden die Parameter von Eigenschaften genauso definiert wie die Parameter von Methoden – optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Der Rückgabewert von <em>get</em> oder <em>set</em> ist das Ergebnis eines Teilausdrucks, der die Eigenschaft indirekt aufgerufen hat. Zum Beispiel speichert <code>Wert := obj.Eigenschaft := 42</code> den Rückgabewert von <em>set</em> in <code>Wert</code>.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_base">base.Eigenschaft</a></code> verwenden, um auf die von ihrer Basisklasse definierte Eigenschaft zuzugreifen. Wenn <em>get</em> oder <em>set</em> nicht definiert ist, kann es von einer Basisklasse behandelt werden. Wenn <em>set</em> nicht definiert ist und nicht von einer Metafunktion oder Basisklasse behandelt wird, speichert die Zuweisung eines Wertes diesen in das Objekt, wodurch die Eigenschaft effektiv deaktiviert wird.</p>
<p>Intern sind <em>get</em> und <em>set</em> zwei separate Methoden, die keine Variablen gemeinsam nutzen können (es sei denn, sie werden in <code>this</code> gespeichert).</p>
<p><a href="#Meta_Functions">Metafunktionen</a> bieten eine größere Auswahl an Möglichkeiten für den kontrollierten Zugriff auf Eigenschaften und Methoden eines Objekts, sind jedoch komplizierter und fehleranfälliger.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Jedes Mal, wenn ein abgeleitetes Objekt mit dem Schlüsselwort <code>new</code> in <span class="ver">[v1.1.00+]</span> erstellt wird, wird die von seinem Basisobjekt definierte __New-Methode aufgerufen. Diese Methode kann Parameter akzeptieren, das Objekt initialisieren und das Ergebnis des <code>new</code>-Operators durch Rückgabe eines Wertes überschreiben. Bei Zerstörung des Objekts wird __Delete aufgerufen. Zum Beispiel:</p>
<pre>m1 := new GMem(0, 20)
m2 := {base: GMem}.__New(0, 30)

class GMem
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            return ""
        MsgBox % "Neues GMem von " aGröße " Bytes auf Adresse " this.ptr "."
        return this  <em>; Diese Zeile kann weggelassen werden, wenn der Operator 'new' verwendet wird.</em>
    }

    __Delete()
    {
        MsgBox % "GMem auf Adresse " this.ptr " löschen."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht für Objekte aufgerufen, die den Schlüssel "__Class" haben. <a href="#Custom_Classes">Klassenobjekte</a> haben diesen Schlüssel standardmäßig.</p>
<p>Wenn die Klasse eine Superklasse hat, die diese Methoden definiert, sollte üblicherweise <code>base.__New()</code> (ggf. mit Parametern) und <code>base.__Delete()</code> aufgerufen werden. Andernfalls wird nur die am weitesten abgeleitete Definition der Methode aufgerufen, mit Ausnahme von Definitionen innerhalb des Zielobjekts selbst.</p>
<p><span class="ver">[v1.1.28+]</span>: Wenn ein Ausnahme- oder Laufzeitfehler bei der Ausführung von __Delete ausgelöst und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen worden. Das heißt, dass ein Fehlerdialogfenster angezeigt wird und __Delete zurückkehrt, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet). Vor v1.1.28 führten unbehandelte Ausnahmen zu inkonsistentem Verhalten.</p>
<p>Wenn das Skript auf irgendeine Weise direkt terminiert wird, z.B. über das Tray-Menü, <a href="lib/ExitApp.htm">ExitApp</a> oder <a href="lib/Exit.htm">Exit</a> (wenn das Skript nicht <a href="lib/_Persistent.htm">persistent</a> ist), bekommen alle Funktionen, die noch nicht zu ihrem Aufrufer zurückgekehrt sind, keine Chance, dies jemals zu tun. Daher werden alle Objekte, die von lokalen Variablen dieser Funktionen referenziert werden, nicht freigegeben, was dazu führt, dass __Delete nicht aufgerufen wird.</p>
<p>Bei Beendigung des Skripts werden Objekte, die in globalen und statischen Variablen enthalten sind, automatisch in einer willkürlichen, von der Implementierung festgelegten Reihenfolge freigegeben. Wenn __Delete während dieses Vorgangs aufgerufen wird, können einige globale oder statische Variablen bereits freigegeben worden sein, aber alle Referenzen, die das Objekt selbst enthält, sind noch gültig. Daher ist es am besten, wenn __Delete völlig eigenständig ist und nicht auf globale oder statische Variablen angewiesen ist.</p>

<h3 id="Meta_Functions">Metafunktionen</h3>
<pre class="Syntax">
<strong>Methodensyntax:</strong>
class <i>KlasseName</i> {
    __Get([Schlüssel, Schlüssel2, ...])
    __Set([Schlüssel, Schlüssel2, ...], Wert)
    __Call(Name [, Parameter...])
}

<strong>Funktionssyntax:</strong>
<i>MeinGet</i>(this [, Schlüssel, Schlüssel2, ...])
<i>MeinSet</i>(this [, Schlüssel, Schlüssel2, ...], Wert)
<i>MeinCall</i>(this, Name [, Parameter...])

<i>KlasseName</i> := { __Get: Func("<i>MeinGet</i>"), __Set: Func("<i>MeinSet</i>"), __Call: Func("<i>MeinCall</i>") }
</pre>
<p>Metafunktionen definieren, was passieren soll, wenn ein Schlüssel angefordert, aber nicht im Zielobjekt gefunden wird. Wenn z.B. <code>obj.Schlüssel</code> keinen Wert zugewiesen bekommen hat, ruft es indirekt die <i>__Get</i>-Metafunktion auf. <code>obj.Schlüssel := Wert</code> bewirkt dagegen den indirekten Aufruf von <i>__Set</i> und <code>obj.Schlüssel()</code> den indirekten Aufruf von <i>__Call</i>. Diese Metafunktionen (oder Methoden) müssten in <code>obj.base</code>, <code>obj.base.base</code> oder ähnlichem definiert werden.</p>
<p>Metafunktionen werden in der Regel wie Methoden definiert, folgen aber nicht den gleichen Regeln (es sei denn, sie werden explizit vom Skript aufgerufen). Sie müssen in einem Basisobjekt definiert werden; eine Definition im Zielobjekt selbst wird ignoriert. Jede auf das Zielobjekt anwendbare Definition von __Get, __Set und __Call wird automatisch gemäß den folgenden Regeln aufgerufen und sollte nicht <code>base.__Get(Schlüssel)</code> oder ähnlich aufrufen. <a href="#Custom_NewDelete">__New</a> und <a href="#Custom_NewDelete">__Delete</a> müssen in einem Basisobjekt definiert werden, verhalten sich aber ansonsten wie Methoden.</p>
<p class="note"><strong>Hinweis:</strong> AutoHotkey v2 ersetzt Metafunktionen mit konventionelleren Methoden.</p>
<p>Wenn das Skript einen nicht vorhandenen Schlüssel im Zielobjekt abruft (get), setzt (set) oder aufruft (call), wird das Basisobjekt wie folgt indirekt aufgerufen:</p>
<ul class="list_of_p">
  <li>Wenn dieses Basisobjekt die entsprechende Metafunktion definiert, diese aufrufen. Wenn die Metafunktion etwas explizit via <code>return</code> zurückgibt, den Rückgabewert als Ergebnis der Operation verwenden (was auch immer den Aufruf der Metafunktion verursacht hat) und die Kontrolle an das Skript zurückgeben. Andernfalls wie unten beschrieben fortfahren.
    <p><i>Set</i>: Wenn die Metafunktion eine Zuweisung behandelt hat, sollte sie den zugewiesenen Wert zurückgeben. Auf diese Weise können Zuweisungen verkettet werden, wie in <code>a.x := b.y := z</code>. Der Rückgabewert kann vom ursprünglichen Wert <code>z</code> abweichen (z.B. wenn Einschränkungen auferlegt wurden, welche Werte zugewiesen werden können).</p></li>
  <li>Nach einem passenden Schlüssel in den Feldern des Basisobjekts suchen.</li>
  <li><span class="ver">[v1.1.16+]</span>: Wenn ein Schlüssel, der zu einer Eigenschaft gehört, gefunden wurde und <em>get</em> oder <em>set</em> implementiert (falls zutreffend), die Eigenschaft indirekt aufrufen und zurückkehren. Wenn dies ein Methodenaufruf ist, <em>get</em> indirekt aufrufen.</li>
  <li>Wenn kein Schlüssel gefunden wurde, die Basis dieses Basisobjekts indirekt und rekursiv aufrufen (dabei jeden dieser Schritte anwenden, beginnend am Anfang der Liste). Wenn wir noch nicht fertig sind, erneut nach einem passenden Schlüssel in diesem Basisobjekt suchen, falls einer via Metafunktion hinzugefügt wurde.
    <p>Aus Gründen der Abwärtskompatibilität wird dieser Schritt für <em>set</em>-Operationen durchgeführt, selbst wenn ein Schlüssel gefunden wurde (es sei denn, es definiert eine Eigenschaft, die <em>set</em> implementiert).</p></li>
  <li>Wenn mehrere Parameter für <i>get</i> oder <i>set</i> angegeben wurden und ein Schlüssel gefunden wurde, seinen Wert prüfen. Wenn dieser Wert ein Objekt ist, die restlichen Parameter durch indirekten Aufruf behandeln und nichts weiter unternehmen.</li>
  <li>Wenn ein Schlüssel gefunden wurde,<br>
    <i>Get</i>: Den Wert zurückgeben.<br>
    <i>Call</i>: Den Wert versuchsweise aufrufen und dabei das Zielobjekt als ersten Parameter (<code>this</code>) übergeben. Der Wert sollte ein Funktionsname oder <a href="misc/Functor.htm">Funktionsobjekt</a> sein.</li>
</ul>
<p>Wenn eine Metafunktion einen passenden Schlüssel in das Objekt speichert, aber nicht via <code>return</code> zurückkehrt, verhält sie sich so, als wäre der Schlüssel von Anfang an im Objekt vorhanden gewesen. Ein Beispiel zur Verwendung von __Set finden Sie unter <a href="#Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</a>.</p>
<p>Wenn die Operation immer noch nicht behandelt wurde, prüfen, ob es sich um eine interne Methode oder Eigenschaft handelt:</p>
<ul>
  <li><i>Get</i>: Wenn es sich bei dem Schlüssel um "base" handelt, die Basis des Objekts zurückgeben.</li>
  <li><i>Set</i>: Wenn es sich bei dem Schlüssel um "base" handelt, die Basis des Objekts setzen (oder entfernen, wenn der Wert kein Objekt ist).</li>
  <li><i>Call</i>: Eine <a href="lib/Object.htm">interne Methode</a> aufrufen, falls möglich.</li>
</ul>
<p>Wenn die Operation immer noch nicht behandelt wurde,</p>
<ul>
  <li><i>Get</i> und <i>Call</i>: Eine leere Zeichenkette zurückgeben.</li>
  <li><i>Set</i>: Wenn nur ein Schlüsselparameter angegeben wurde, den Schlüssel und Wert in das Zielobjekt speichern und den zugewiesenen Wert zurückgeben. Wenn mehrere Parameter angegeben wurden, ein neues Objekt erstellen und speichern, wobei der erste Parameter als Schlüssel verwendet wird, und dann die restlichen Parameter durch indirekten Aufruf des neuen Objekts behandeln. (Siehe <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>.)</li>

</ul>

<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Die Verwendung von <code>return</code> ohne Wert ist äquivalent zu <code>return ""</code>. Dies könnte sich in einer zukünftigen Version ändern, so dass <code>return</code> verwendet werden kann, um aus einer Metafunktion "auszubrechen", ohne das Standardverhalten zu überschreiben.</li></ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> ermöglicht die Definition von Eigenschaften, die bei jeder Auswertung einen Wert ermitteln, allerdings muss jede Eigenschaft im Voraus bekannt und im Skript einzeln definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die nicht im Voraus bekannt sein müssen.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Selbst wenn der Name jeder Eigenschaft im Voraus bekannt wäre, würde es keinen Sinn machen, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe bewirkt (eine Netzwerkanfrage senden). Metafunktionen empfangen den Namen der Eigenschaft als Parameter und sind daher eine gute Lösung für dieses Problem.</p>
<p>Eine andere Verwendung von <em>__Get</em> und <em>__Set</em> ist die Implementierung einer Reihe von verwandten Eigenschaften, die sich Code teilen. Im folgenden Beispiel werden sie verwendet, um ein "Farbe"-Objekt mit R, G, B und RGB-Eigenschaften zu implementieren, wobei tatsächlich nur der RGB-Wert gespeichert wird:</p>
<pre>rot  := new Farbe(0xff0000), rot.R -= 5
cyan := new Farbe(0), cyan.G := 255, cyan.B := 255

MsgBox % "rot: " rot.R "," rot.G "," rot.B " = " rot.RGB
MsgBox % "cyan: " cyan.R "," cyan.G "," cyan.B " = " cyan.RGB

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    static Shift := {R:16, G:8, B:0}

    __Get(aName)
    {
        <em>; <span class="red">HINWEIS:</span> this.Shift würde hier eine Endlosschleife erzeugen!</em>
        shift := Farbe.Shift[aName]  <em>; Die Anzahl der zu verschiebenden Bits abrufen.</em>
        if (shift != "")  <em>; Ist es eine bekannte Eigenschaft?</em>
            return (this.RGB &gt;&gt; shift) &amp; 0xff
        <em>; <span class="red">HINWEIS:</span> Ein 'return' würde hier this.RGB unbrauchbar machen.</em>
    }

    __Set(aName, aWert)
    {
        if ((shift := Farbe.Shift[aName]) != "")
        {
            aWert &amp;= 255  <em>; Auf eine geeignete Länge kürzen.

            ; Den neuen RGB-Wert berechnen und speichern.</em>
            this.RGB := (aWert &lt;&lt; shift) | (this.RGB &amp; ~(0xff &lt;&lt; shift))

            <em>; 'return' ist notwendig, um anzugeben, dass kein neues Schlüssel-Wert-Paar erstellt werden soll.
            ; Dies definiert auch, was in das 'x' in 'x := clr[name] := val' gespeichert wird:</em>
            return aWert
        }
        <em>; <span class="red">HINWEIS:</span> Ein 'return' würde hier this.gespeichertes_RGB und this.RGB unbrauchbar machen.</em>
    }

    <em>; Metafunktionen können mit Eigenschaften vermischt werden:</em>
    RGB {
        get {
            <em>; Als Hex-Wert zurückgeben:</em>
            return format("0x{:06x}", this.gespeichertes_RGB)
        }
        set {
            return this.gespeichertes_RGB := value
        }
    }
}</pre>
<p>In diesem Fall hätte man jedoch stattdessen die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> verwenden können, bei der der Code gemeinsam genutzt wird, indem jede Eigenschaft einfach eine zentrale Methode aufruft. Metafunktionen sollten, wenn möglich, vermieden werden, da ein hohes Risiko besteht, dass sie falsch verwendet werden (siehe die roten Hinweise oben).</p>

<h4 id="Objects_as_Functions">Objekte als Funktionen</h4>
<p>Eine Übersicht über die Erstellung von Objekten, die als Funktionen fungieren können, finden Sie unter <a href="misc/Functor.htm#User-Defined">Funktionsobjekte</a>.</p>
<p>Ein Funktionsobjekt kann auch als Metafunktion fungieren, um z.B. dynamische Eigenschaften zu definieren, die denen im vorherigen Abschnitt ähneln. Obwohl es ratsam ist, stattdessen die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> zu verwenden, zeigt das folgende Beispiel das Potenzial von Metafunktionen zur Implementierung neuer Konzepte oder Verhaltensmuster, oder die Änderung der Struktur des Skripts.</p>
<pre><em>; Dieses Beispiel benötigt die <a href="misc/Functor.htm#class_FunctionObject">FunktionObjekt-Klasse</a>, um zu funktionieren.</em>
blau := new Farbe(0x0000ff)
MsgBox % blau.R "," blau.G "," blau.B

class Eigenschaften extends FunktionObjekt
{
    Call(aZiel, aName, aParams*)
    {
        <em>; Wenn dieses Eigenschaften-Objekt eine Definition für diese Teileigenschaft enthält, diese aufrufen.</em>
        if ObjHasKey(this, aName)
            return this[aName].Call(aZiel, aParams*)
    }
}

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    class __Get extends Eigenschaften
    {
        R() {
            return (this.RGB &gt;&gt; 16) &amp; 255
        }
        G() {
            return (this.RGB &gt;&gt; 8) &amp; 255
        }
        B() {
            return this.RGB &amp; 255
        }
    }

    <em>;...</em>
}</pre>

<h4 id="Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</h4>
<p>Wenn eine <a href="#Usage_Arrays_of_Arrays">Multi-Parameter-Zuweisung</a> wie <code>Tabelle[x, y] := Inhalt</code> implizit dazu führt, dass ein neues Objekt erstellt wird, hat das neue Objekt üblicherweise keine Basis und daher keine benutzerdefinierten Methoden oder spezielle Verhaltensweisen. Mit <code class="no-highlight">__Set</code> können solche Objekte wie folgt initialisiert werden.</p>
<pre>x := {base: {addr: Func("x_Addr"), __Set: Func("x_Setter")}}

<em>; Wert zuweisen, was implizit x_Setter aufruft, um Unterobjekte zu erstellen.</em>
x[1,2,3] := "..."

<em>; Wert abrufen und Beispielmethode aufrufen.</em>
MsgBox % x[1,2,3] "`n" x.addr() "`n" x[1].addr() "`n" x[1,2].addr()

x_Setter(x, p1, p2, p3) {
    x[p1] := new x.base
}

x_Addr(x) {
    return &amp;x
}</pre>
<p><code class="no-highlight">x_Setter</code> hat vier Pflichtparameter und kann daher nur aufgerufen werden, wenn zwei oder mehr Schlüsselparameter vorhanden sind. Wenn die obige Zuweisung erfolgt, geschieht folgendes:</p>
<ul>
  <li><code>x[1]</code> existiert nicht, daher wird <code>x_Setter(x,1,2,3)</code> aufgerufen (<code>"..."</code> wird nicht übergeben, da zu wenig Parameter vorhanden sind).
  <ul>
    <li><code>x[1]</code> bekommt ein neues Objekt mit derselben Basis wie <code>x</code> zugewiesen.</li>
    <li>Kein Rückgabewert – die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2]</code> existiert nicht, daher wird <code>x_Setter(x[1],2,3,"...")</code> aufgerufen.
  <ul>
    <li><code>x[1][2]</code> bekommt ein neues Objekt mit derselben Basis wie <code>x[1]</code> zugewiesen.</li>
    <li>Kein Rückgabewert – die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2][3]</code> existiert nicht, aber da <code class="no-highlight">x_Setter</code> vier Parameter benötigt und nur drei zur Verfügung stehen (<code>x[1][2], 3, "..."</code>), wird es nicht aufgerufen und die Zuweisung normal beendet.</li>
</ul>

<h2 id="Default_Base_Object">Standardbasisobjekt</h2>
<p>Wenn ein Nicht-Objekt-Wert mit der Objektsyntax verwendet wird, wird indirekt das <i>Standardbasisobjekt</i> aufgerufen. Dies kann verwendet werden, um das Skript zu debuggen oder um global objektähnliche Verhaltensweisen für Zeichenketten, Zahlen und/oder Variablen zu definieren. Um auf die Standardbasis zuzugreifen, verwenden Sie <code>.base</code> mit einem Nicht-Objekt-Wert, z.B. <code>"".base</code>. Obwohl die Standardbasis nicht <i>gesetzt</i> werden kann, wie in <code>"".base := Object()</code>, kann die Standardbasis selbst eine Basis haben, wie in <code>"".base.base := Object()</code>.</p>

<h3 id="Automatic_Var_Init">Automatische Variableninitialisierung</h3>
<p>Wenn eine leere Variable als Ziel einer <i>Set</i>-Operation verwendet wird, wird sie direkt an die __Set-Metafunktion übergeben, was ihr die Möglichkeit gibt, ein neues Objekt in die Variable einzufügen. Aus Platzgründen unterstützt dieses Beispiel nicht mehr als einen Parameter, was aber mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> möglich wäre.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox % empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    if (var = "")
        var := Object(key, value)
}</pre>

<h3 id="Pseudo_Properties">Pseudo-Eigenschaften</h3>
<p>Diese Art von Syntax kann auch auf Zeichenketten und Zahlen angewendet werden.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox % A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox % A_AhkPath.length.is("integer")

Default_Get_PseudoProperty(nonobj, key)
{
    if (key = "length")
        return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    if nonobj is %type%
        return true
    return false
}</pre>
<p>Beachten Sie, dass interne Funktionen auch verwendet werden können, aber in diesem Fall dürfen die runden Klammern nicht weggelassen werden:</p>
<pre>"".base.length := Func("StrLen")
MsgBox % A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h3 id="Default__Warn">Debugging</h3>
<p>Wenn es unerwünscht ist, die Behandlung eines Wertes als Objekt zu erlauben, kann eine Warnung angezeigt werden, wann immer ein Nicht-Objekt-Wert indirekt aufgerufen wird:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1="", p2="", p3="", p4="")
{
    ListLines
    MsgBox Ein Nicht-Objekt-Wert wurde unsachgemäß indirekt aufgerufen.`n`nSpeziell: %nonobj%
}</pre>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählmechanismus, um belegte Ressourcen eines Objekts automatisch freizugeben, wenn es nicht länger im Skript referenziert wird. Skriptautoren sollten diesen Mechanismus nicht explizit aufrufen, es sei denn, sie arbeiten direkt mit unverwalteten <a href="#Implementation_Pointers">Objektpointern</a>.</p>
<p>In AutoHotkey v1.1 werden temporäre Referenzen, die innerhalb eines Ausdrucks erstellt (aber nirgendwo gespeichert) werden, sofort nach ihrer Verwendung freigegeben. Zum Beispiel übergibt <code>Fn(&amp;{})</code> eine ungültige Adresse an die Funktion, da die temporäre Referenz, zurückgegeben von <code>{}</code>, sofort nach der Auswertung des <a href="Variables.htm#amp">Adresse-von</a>-Operators freigegeben wird.</p>
<p>Um Code beim Freigeben der letzten Referenz zu einem Objekt auszuführen, implementieren Sie die <a href="#Custom_NewDelete">__Delete</a>-Metafunktion.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Weitere Informationen und ein Beispiel finden Sie unter <a href="#Circular_References">Objekte freigeben</a>.</li>
  <li>Referenzen in statischen und globalen Variablen werden bei Beendigung des Programms automatisch freigegeben. Dies gilt jedoch nicht für Referenzen in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel. Solche Referenzen werden erst freigegeben, wenn die Funktion oder der Ausdruck regulär beendet werden kann.</li>
</ul>
<p>Obwohl das Betriebssystem den vom Objekt belegten Speicher bei Beendigung des Programms zurückfordern wird, wird <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen, wenn alle Referenzen zum Objekt freigegeben wurden. Dies kann wichtig sein, wenn es andere Ressourcen freigibt, die nicht automatisch vom Betriebssystem zurückgefordert werden, wie z.B. temporäre Dateien.</p>

<span id="AddressCast"></span><h3 id="Implementation_Pointers">Objektpointer</h3>
<p>In seltenen Fällen kann es erforderlich sein, dass ein Objekt via DllCall() an einen externen Code übergeben werden muss oder dass ein Objekt in eine binäre Datenstruktur für späteren Gebrauch gespeichert werden muss. Die Adresse eines Objekts kann via <code>Adresse := &amp;Objekt</code> abgerufen werden, allerdings werden dadurch effektiv zwei Referenzen zum Objekt erzeugt, während das Programm selbst nur die eine Referenz in <em>Objekt</em> kennt. Das Objekt wird gelöscht, sobald die letzte <em>bekannte</em> Referenz zum Objekt freigegeben wird. Folglich muss das Skript dem Objekt mitteilen, dass es eine Referenz erhalten hat. Es gibt zwei Wege, um das zu erreichen:</p>
<pre><em>; Methode #1: Referenzanzahl explizit um 1 erhöhen.</em>
Adresse := &amp;Objekt
<a href="lib/ObjAddRef.htm">ObjAddRef</a>(Adresse)

<em>; Methode #2: Object() verwenden, das die Referenzanzahl um 1 erhöht und eine Adresse zurückgibt.</em>
Adresse := Object(Objekt)</pre>
<p>Mit dieser Funktion ist es auch möglich, eine Adresse wieder in eine Referenz umzuwandeln:</p>
<pre>Objekt := Object(Adresse)</pre>
<p>In jedem Fall muss das Objekt informiert werden, wenn das Skript mit dieser Referenz fertig ist:</p>
<pre><em>; Referenzanzahl des Objekts um 1 verringern, damit es freigegeben werden kann:</em>
<a href="lib/ObjAddRef.htm">ObjRelease</a>(Adresse)
</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separate Referenz zum Objekt behandelt werden, d.h. das Skript sollte <a href="lib/ObjAddRef.htm">ObjAddRef()</a> aufrufen, wenn es eine Kopie erhält, und sofort <a href="lib/ObjAddRef.htm">ObjRelease()</a> aufrufen, bevor es eine Kopie verliert. Zum Beispiel sollte immer <a href="lib/ObjAddRef.htm">ObjAddRef()</a> aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript <a href="lib/ObjAddRef.htm">ObjRelease()</a> aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist, den Wert von <em>x</em> zu überschreiben).</p>
<p>Beachten Sie, dass die Object-Funktion auch auf Objekte angewendet werden kann, die nicht von ihr selbst erzeugt wurden, wie z.B. <a href="lib/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="lib/File.htm">File-Objekte</a>.</p>

</body>
</html>
