<!DOCTYPE HTML>
<html lang="de">
<head>
<title>InputHook - Syntax &amp; Verwendung | AutoHotkey</title>
<meta name="description" content="Die InputHook-Funktion erstellt ein Objekt, das zum Erfassen oder Abfangen von Tastatureingaben genutzt werden kann." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>InputHook() <span class="ver">[v1.1.31+]</span></h1>

<p>Erstellt ein Objekt, das zum Erfassen oder Abfangen von Tastatureingaben genutzt werden kann.</p>

<pre class="Syntax">InputHook := <span class="func">InputHook</span>(<span class="optional">Optionen, Endtasten, Vergleichsliste</span>)</pre>
<h2>Parameter</h2>
<dl>

  <dt>Optionen</dt>
  <dd>
    <p><u>Eine Zeichenkette mit null oder mehreren der folgenden Buchstaben (in beliebiger Reihenfolge, optional mit Leerzeichen getrennt):</u></p>
    <p id="option-b"><strong>B</strong>: Setzt <a href="#BackspaceIsUndo">BackspaceIsUndo</a> auf False, um zu bewirken, dass <kbd>Backspace</kbd> ignoriert wird.</p>
    <p id="option-c"><strong>C</strong>: Setzt <a href="#CaseSensitive">CaseSensitive</a> auf True, um <em>Vergleichsliste</em> Groß-Kleinschreibung-sensitiv zu machen.</p>
    <p id="option-i"><strong>I</strong>: Setzt <a href="#MinSendLevel">MinSendLevel</a> auf 1 oder den angegebenen Wert, um Eingaben zu ignorieren, deren <a href="SendLevel.htm">Sendestufe</a> kleiner als dieser Wert ist. <code>I2</code> beispielsweise würde Eingaben mit einer Stufe von 0 (Standardwert) oder 1 ignorieren, aber Eingaben der Stufe 2 erfassen.</p>
    <p id="option-l"><strong>L</strong>: Längenbegrenzung (z. B. <code>L5</code>). Die maximal erlaubte Länge der Eingabe. Wenn der Text diese Länge erreicht, wird die Eingabeerfassung beendet und EndReason auf das Wort Max gesetzt (es sei denn, der Text stimmt mit einem der Elemente in der <em>Vergleichsliste</em> überein, dann wird EndReason auf das Wort Match gesetzt). Wenn diese Option nicht verwendet wird, ist die Länge auf 1023 Zeichen begrenzt.</p>
    <p>Die Angabe von <code>L0</code> deaktiviert die Texterfassung und Längenlimitierung, hat aber keinen Einfluss darauf, welche Tasten tatsächlich Text erzeugen (siehe <a href="#VisibleText">VisibleText</a>). Dies kann in Zusammenhang mit <a href="#OnChar">OnChar</a>, <a href="#OnKeyDown">OnKeyDown</a>, <a href="#KeyOpt">KeyOpt</a> oder <em><a href="#EndKeys">EndKeys</a></em> nützlich sein.</p>
    <p id="option-m"><strong>M</strong>: Modifizierte Tastendrücke wie <kbd>Strg</kbd>+<kbd>A</kbd> bis <kbd>Strg</kbd>+<kbd>Z</kbd> werden erkannt und in echte ASCII-Zeichen umgewandelt, falls möglich. Das folgende Beispiel zeigt, wie <kbd>Strg</kbd>+<kbd>C</kbd> erkannt werden kann:</p>
    <pre>StrgC := Chr(3) <em>; Speichert das Zeichen für STRG+C in die Variable StrgC.</em>
ih := InputHook("L1 M")
ih.Start()
ih.Wait()
if (ih.Input = StrgC)
    MsgBox, Sie haben STRG+C gedrückt.</pre>
    <p class="note"><strong>Hinweis</strong>: <kbd>Strg</kbd>+<kbd>A</kbd> bis <kbd>Strg</kbd>+<kbd>Z</kbd> sind die Zeichen von <a href="Chr.htm">Chr(1)</a> bis <a href="Chr.htm">Chr(26)</a>. Außerdem ist es möglich, dass die <strong>M</strong>-Option einige Tastenkürzel wie <kbd>Strg</kbd>+<kbd>←</kbd> dazu bringen kann, sich während einer Eingabeerfassung falsch zu verhalten.</p>
    <p id="option-t"><strong>T</strong>: Setzt <a href="#Timeout">Timeout</a> (z. B. <code>T3</code> oder <code>T2.5</code>).</p>
    <p id="vis"><strong>V</strong>: Setzt <a href="#VisibleText">VisibleText</a> und <a href="#VisibleNonText">VisibleNonText</a> auf True. Normalerweise wird die Eingabe des Benutzers blockiert (unsichtbar für das Betriebssystem gemacht). Nutzen Sie diese Option, damit die Tastendrücke des Benutzers direkt an das aktive Fenster gesendet werden.</p>
    <p id="asterisk"><strong>*</strong>: Platzhalter. Setzt <a href="#FindAnywhere">FindAnywhere</a> auf True, damit überall Übereinstimmungen innerhalb dessen, was der Benutzer eingibt, gefunden werden können.</p>
    <p id="E"><strong>E</strong>: Behandelt Einzelzeichen-Endungstasten als Zeichencode anstatt als Tastencode. Diese Änderung ermöglicht konsistentere Ergebnisse, wenn das Tastaturlayout des aktiven Fensters sich vom Tastaturlayout des Skripts unterscheidet. Es verhindert auch Tastenkombinationen, die die angegebenen Endungszeichen bei der Eingabe eigentlich nicht erzeugen können; wenn <code>@</code> beispielsweise eine Endungstaste wäre, würde sie auf einem US-Layout via <kbd>Umschalt</kbd>+<kbd>2</kbd> ausgelöst werden, aber nicht via <kbd>Strg</kbd>+<kbd>Umschalt</kbd>+<kbd>2</kbd> (wenn die E-Option verwendet wird). Wenn zusätzlich noch die <strong>C</strong>-Option angegeben ist, ist das Endungszeichen Groß-/Kleinschreibung-sensitiv.</p>
  </dd>

  <dt id="EndKeys">Endtasten</dt>
  <dd>
    <p>Eine optionale Liste mit ein oder mehr Tasten, die, wenn gedrückt, die Eingabeerfassung beenden können (die Endtaste selbst wird nicht in den Eingabepuffer geschrieben). Wenn eine Eingabeerfassung auf diese Weise beendet wird, wird EndReason auf das Wort EndKey und die <a href="#EndKey">EndKey</a>-Eigenschaft auf den Namen der Taste gesetzt.</p>
    <p>Die <em>Endtasten</em>-Liste verwendet ein Format, das Ähnlichkeit zum verwendeten Format des <a href="Send.htm">Send</a>-Befehls hat. Zum Beispiel würde <code>{Enter}.{Esc}</code> bewirken, dass <kbd>Enter</kbd>, <kbd>.</kbd> oder <kbd>Esc</kbd> die Eingabeerfassung beenden können. Damit die geschweiften Klammern selbst Endtasten sein können, gibt man <code>{{}</code> und/oder <code>{}}</code> an.</p>
    <p>Um <kbd>Strg</kbd>, <kbd>Alt</kbd> oder <kbd>Umschalt</kbd> als Endtasten zu verwenden, gibt man die linke und/oder rechte Version der Taste an, nicht die neutrale Version. Zum Beispiel müsste <code>{LControl}{RControl}</code> anstelle von <code>{Control}</code> angegeben werden.</p>
    <p>Obwohl modifizierte Tasten wie <kbd>Alt</kbd>+<kbd>C</kbd> (!c) nicht unterstützt werden, setzen nicht-alphanumerische Zeichen wie <code>?!:@&amp;{}</code> standardmäßig voraus, dass UMSCHALT gedrückt oder nicht gedrückt sein muss, je nachdem, wie das Zeichen normalerweise eingegeben wird. Wenn die <strong>E</strong>-Option vorhanden ist, werden die Namen von Einzelzeichentasten stattdessen als Zeichen interpretiert - in solchen Fällen müssen die Modifikatortasten im richtigen Zustand sein, um dieses Zeichen zu erzeugen.  Wenn sowohl die <strong>E</strong>- als auch <strong>M</strong>-Option vorhanden sind, werden Tastenkombinationen von <kbd>Strg</kbd>+<kbd>A</kbd> bis <kbd>Strg</kbd>+<kbd>Z</kbd> unterstützt, indem man die entsprechenden ASCII-Steuerzeichen in <em>Endtasten</em> einfügt.</p>
    <p>Ein eindeutiger Tastencode wie <code>{vkFF}</code> oder <code>{sc001}</code> kann auch angegeben werden. Diese Angabe ist in Ausnahmefällen nützlich, wo eine Taste keinen Namen hat und keine sichtbaren Zeichen beim Drücken erzeugt. Der virtuelle Tastencode einer solchen Taste kann durch Befolgen der Schritte am unteren Ende der <a href="../KeyList.htm#SpecialKeys">Tastenliste</a> ermittelt werden.</p>
  </dd>

  <dt id="MatchList">Vergleichsliste</dt>
  <dd>
    <p>Eine kommagetrennte Liste mit Stichwörtern, die die Eingabeerfassung beenden können (in diesem Fall wird EndReason auf das Wort Match gesetzt). Alles, was der Benutzer eingibt, muss exakt mit einem Element aus der Liste übereinstimmen, um eine Übereinstimmung zu bewirken (sofern die <a href="#asterisk">*-Option</a> nicht vorhanden ist). <strong>Alle Leer- und Tabulatorzeichen an den angrenzenden Kommas sind von Bedeutung</strong> - das heißt, dass sie ein Teil der Übereinstimmungszeichenkette sind. Wenn <em>Vergleichsliste</em> beispielsweise <code>ABC , XYZ</code> wäre, kann eine Übereinstimmung nur erfolgen, wenn der Benutzer ein Leerzeichen nach ABC oder vor XYZ eingibt.</p>
    <p>Zwei aufeinanderfolgende Kommas ergeben ein direkt geschriebenes Komma. Zum Beispiel würde die folgende Zeile ein direkt geschriebenes Komma nach dem Wort Zeichenkette1 erzeugen: <code>Zeichenkette1,,,Zeichenkette2</code>. Im Vergleich dazu würde die folgende Liste nur ein einzelnes Element mit einem direkt geschriebenen Komma dazwischen enthalten: <code>einzelnes,,Element</code>.</p>
    <p>Da die Elemente in <em>Vergleichsliste</em> nicht als einzelne Parameter behandelt werden, kann die Liste komplett in einer Variable enthalten sein. Diese Methode ist sowieso notwendig, wenn die Liste eine Länge von 16383 Zeichen überschreitet (die maximale Länge einer Skriptzeile). Zum Beispiel könnte <em>Vergleichsliste</em> aus <code>%Liste1%,%Liste2%,%Liste3%</code> bestehen, von der jede Unterliste eine lange Liste mit Elementen enthält.</p>
  </dd>

</dl>

<h2 id="stack">Input-Stapel</h2>
<p>Es können beliebig viele InputHook-Objekte erstellt werden und zur selben Zeit aktiv sein, allerdings hat die Reihenfolge, in der sie gestartet werden, Einfluss darauf, wie die Eingaben erfasst werden.</p>
<p>Wenn eine Eingabeerfassung gestartet wird (via <a href="#Start">Start</a>-Methode oder <a href="Input.htm">Input</a>-Befehl), wird sie ganz oben auf den Stapel geschoben, und aus diesem Stapel entfernt, wenn die Eingabeerfassung beendet wird. Die Reihenfolge, in der die Tastaturereignisse an eine Eingabeerfassung übergeben werden, geht vom neuesten zum ältesten. Wenn eine Eingabeerfassung ein bestimmtes Tastaturereignis unterdrückt, wird er nicht weiter im Stapel nach unten verschoben.</p>
<p><a href="Send.htm">Gesendete</a> Tastendrücke werden ignoriert, wenn die <a href="SendLevel.htm">Sendestufe</a> des Tastendrucks unterhalb des InputHook's <a href="#MinSendLevel">MinSendLevel</a> liegt. In solchen Fällen kann der Tastendruck immer noch von einer Eingabeerfassung verarbeitet werden, der niedriger auf dem Stapel liegt.</p>
<p>Es können mehrere InputHooks in Kombination mit <a href="#MinSendLevel">MinSendLevel</a> genutzt werden, um sowohl gesendete als auch reale Tastendrücke separat zu erfassen.</p>
<p>Der Aufruf des <a href="Input.htm">Input</a>-Befehls beendet jede vorherige via Input-Befehl gestartete Eingabeerfassung, lässt aber alle InputHooks aktiv. Wenn die Eingabeerfassung nicht <a href="Input.htm#vis">sichtbar</a> ist, werden alle InputHooks, die davon unterbrochen werden, grundsätzlich keine Eingaben erfassen, bis der Input-Befehl fertig ist.</p>

<h2 id="object">InputHook-Objekt</h2>
<p>Die InputHook-Funktion gibt ein InputHook-Objekt zurück, das die folgenden Methoden und Eigenschaften hat.</p>
<p>Methoden:</p>
<ul>
  <li><a href="#KeyOpt">KeyOpt</a>: Setzt Optionen für eine Taste oder Tastenliste.</li>
  <li><a href="#Start">Start</a>: Beginnt die Eingabeerfassung.</li>
  <li><a href="#Stop">Stop</a>: Beendet die Eingabeerfassung und setzt EndReason auf das Wort Stopped.</li>
  <li><a href="#Wait">Wait</a>: Wartet, bis die Eingabeerfassung beendet wird (InProgress ist False).</li>
</ul>
<p>Allgemeine Eigenschaften:</p>
<ul>
  <li><a href="#EndKey">EndKey</a>: Gibt den Namen der <a href="#EndKeys">Endtaste</a> zurück, die zum Beenden der Eingabeerfassung gedrückt wurde.</li>
  <li><a href="#EndMods">EndMods</a>: Gibt eine Zeichenkette mit Modifikatoren zurück, die logisch unten waren, während die Eingabeerfassung beendet wurde.</li>
  <li><a href="#EndReason">EndReason</a>: Gibt eine <a href="#EndReasons">EndReason-Zeichenkette</a> zurück, die angibt, wie die Eingabeerfassung beendet wurde.</li>
  <li><a href="#InProgress">InProgress</a>: Gibt True zurück, wenn die Eingabeerfassung im Gange ist, ansonsten False.</li>
  <li><a href="#Input">Input</a>: Gibt den erfassten Text seit dem letzten Start der Eingabeerfassung zurück.</li>
  <li><a href="#Match">Match</a>: Gibt das Element der <em>Vergleichsliste</em> zurück, mit der die Eingabeerfassung beendet wurde.</li>
  <li><a href="#OnEnd">OnEnd</a>: Ermittelt oder setzt das <a href="../objects/Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, wenn die Eingabeerfassung beendet wird.</li>
  <li><a href="#OnChar">OnChar</a>: Ermittelt oder setzt das <a href="../objects/Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, nachdem ein Zeichen zum Eingabepuffer hinzugefügt wurde.</li>
  <li><a href="#OnKeyDown">OnKeyDown</a>: Ermittelt oder setzt das <a href="../objects/Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, wenn eine benachrichtigungsfähige Taste gedrückt wird.</li>
</ul>
<p>Optionseigenschaften:</p>
<ul>
  <li><a href="#BackspaceIsUndo">BackspaceIsUndo</a>: Legt fest, ob <kbd>Backspace</kbd> das zuletzt gedrückte Zeichen am Ende des Eingabepuffers entfernen soll.</li>
  <li><a href="#CaseSensitive">CaseSensitive</a>: Legt fest, ob <em>Vergleichsliste</em> Groß-/Kleinschreibung-sensitiv sein soll.</li>
  <li><a href="#FindAnywhere">FindAnywhere</a>: Legt fest, ob alle Übereinstimmungen ein Teil des Eingabetexts sein sollen.</li>
  <li><a href="#MinSendLevel">MinSendLevel</a>: Ermittelt oder setzt die minimale <a href="SendLevel.htm">Sendestufe</a> der zu erfassenden Eingabe.</li>
  <li><a href="#NotifyNonText">NotifyNonText</a>: Legt fest, ob der <a href="#OnKeyDown">OnKeyDown</a>-Callback jedes Mal aufgerufen werden soll, wenn eine Nicht-Text-Taste gedrückt wird.</li>
  <li><a href="#Timeout">Timeout</a>: Ermittelt oder setzt den Timeout-Wert in Sekunden.</li>
  <li><a href="#VisibleNonText">VisibleNonText</a>: Legt fest, ob Tasten oder Tastenkombinationen, die keinen Text erzeugen, sichtbar sein (blockiert werden) sollen.</li>
  <li><a href="#VisibleText">VisibleText</a>: Legt fest, ob Tasten oder Tastenkombinationen, die Text erzeugen, sichtbar sein (blockiert werden) sollen.</li>
</ul>

<div class="methodShort" id="KeyOpt"><h2>KeyOpt</h2>
<p>Setzt Optionen für eine Taste oder Tastenliste.</p>
<pre class="Syntax">InputHook.<span class="func">KeyOpt</span>(Tasten, Tastenoptionen)</pre>
<dl>
  <dt>Tasten</dt>
  <dd><p>Eine Liste mit Tasten. Geschweifte Klammern werden genutzt, um Tastennamen, virtuelle Tastencodes oder Scancodes zu umschließen, ähnlich dem <a href="Send.htm">Send</a>-Befehl. <code>{Enter}.{{}</code> beispielsweise gilt für die Tasten <kbd>Enter</kbd>, <kbd>.</kbd> und <kbd>{</kbd>. Die Angabe einer Taste via Name, <code>{vkNN}</code> oder <code>{scNNN}</code> kann zu drei verschiedenen Ergebnissen führen; siehe unten für Details.</p>
  <p id="all-keys">Geben Sie nur die Zeichenkette <code>{All}</code> an (nicht Groß-/Kleinschreibung-sensitiv), um <em>Tastenoptionen</em> auf alle VK und SC anzuwenden. KeyOpt kann dann ein zweites Mal aufgerufen werden, um Optionen von bestimmten Tasten zu entfernen.</p></dd>
  <dt>Tastenoptionen</dt>
  <dd><p>Eine oder mehrere der folgenden einstelligen Optionen (Leer- und Tabulatorzeichen werden ignoriert).</p>
  <p id="KeyOpt-minus"><strong>-</strong> (minus): Entfernt alle Optionen nach dem <code>-</code>, bis zum nächsten <code>+</code>.</p>
  <p id="KeyOpt-plus"><strong>+</strong> (plus): Bricht alle vorherigen <code>-</code> ab, ansonsten kein Effekt.</p>
  <p id="KeyOpt-e"><strong>E</strong>: Endtaste. Wenn diese Option aktiv ist, wird beim Drücken der Taste die Eingabeerfassung beendet, <a href="#EndReason">EndReason</a> auf das Wort EndKey gesetzt und die <a href="#EndKey">EndKey</a>-Eigenschaft auf den normalisierten Namen der Taste gesetzt. Im Gegensatz zum <em>EndKeys</em>-Parameter wird der Zustand von UMSCHALT ignoriert. Zum Beispiel sind <code>@</code> und <code>2</code> im US-amerikanischen Tastaturlayout äquivalent zu <code>{vk32}</code>.</p>
  <p id="KeyOpt-i"><strong>I</strong>: Text ignorieren. Jeglicher Text, den diese Taste normalerweise erzeugt, wird ignoriert, außerdem wird die Taste als Nicht-Text-Taste behandelt (siehe <a href="#VisibleNonText">VisibleNonText</a>). Hat keine Wirkung, wenn die Taste von sich aus keinen Text erzeugt.</p>
  <p id="KeyOpt-n"><strong>N</strong>: Benachrichtigen. Bewirkt, dass jedes Mal der <a href="#OnKeyDown">OnKeyDown</a>-Callback aufgerufen wird, wenn die Taste gedrückt wird.</p>
  <p id="KeyOpt-s"><strong>S</strong>: Unterdrückt (blockiert) die Taste, nachdem sie verarbeitet wurde. Dies überschreibt  <a href="#VisibleText">VisibleText</a> oder <a href="#VisibleNonText">VisibleNonText</a>, bis <code>-S</code> verwendet wird. <code>+S</code> beinhaltet <code>-V</code>.</p>
  <p id="KeyOpt-v"><strong>V</strong>: Sichtbar. Verhindert, dass die Taste unterdrückt (blockiert) werden kann. Dies überschreibt <a href="#VisibleText">VisibleText</a> oder <a href="#VisibleNonText">VisibleNonText</a>, bis <code>-V</code> verwendet wird. <code>+V</code> beinhaltet <code>-S</code>.</p>
  </dd>
</dl>
<p id="KeyOpt-remarks">Optionen können sowohl via virtuellen Tastencode als auch Scancode gesetzt werden und sind kumulativ.</p>
<p>Wenn eine Taste via Name spezifiziert ist, werden die Optionen entweder via VK oder SC gesetzt. Wenn zwei physische Tasten dieselben VK, aber unterschiedliche SC haben (zum Beispiel <kbd>Up</kbd> und <kbd>NumpadUp</kbd>), werden sie via SC behandelt. Wenn dagegen eine VK-Nummer verwendet wird, gilt sie für alle physischen Tasten, die diese VK erzeugen (aber das kann mit der Zeit variieren, da es vom aktiven Tastaturlayout abhängt).</p>
<p>Das Entfernen einer Option via VK-Nummer hat keinen Einfluss auf Optionen, die via SC gesetzt wurden, oder umgekehrt. Wenn allerdings eine Option via Tastenname entfernt wird und dieser Name via VK behandelt wird, wird die Option auch für den entsprechenden SC entfernt (gemäß dem Tastaturlayout des Skripts). Dies ermöglicht es, Tasten via Name auszuschließen, nachdem eine Option auf <a href="#all-keys">alle Tasten</a> angewendet wurde.</p>
<p>Wenn <code>+V</code> via VK und <code>+S</code> via SC gesetzt ist (oder umgekehrt), hat <code>+V</code> Vorrang.</p>
</div>

<div class="methodShort" id="Start"><h2>Start</h2>
<p>Beginnt die Eingabeerfassung.</p>
<pre class="Syntax">InputHook.<span class="func">Start</span>()</pre>
<p>Hat keine Wirkung, wenn die Eingabeerfassung bereits im Gange ist.</p>
<p>Die neu gestartete Eingabeerfassung wird ganz oben auf dem <a href="#stack">InputHook-Stapel</a> platziert, damit diese jede zuvor gestartete Eingabeerfassung überschreiben kann.</p>
<p>Diese Methode installiert den <a href="_InstallKeybdHook.htm">Tastatur-Hook</a> (falls noch nicht geschehen).</p>
</div>

<div class="methodShort" id="Wait"><h2>Wait</h2>
<p>Wartet, bis die Eingabeerfassung beendet wird (<a href="#InProgress">InProgress</a> ist False).</p>
<pre class="Syntax">InputHook.<span class="func">Wait</span>(<span class="optional">MaxZeit</span>)</pre>
<dl>
  <dt>MaxZeit</dt>
  <dd><p>Die maximale Wartezeit in Sekunden. Wenn die Eingabeerfassung nach <em>MaxZeit</em> Sekunden immer noch im Gange ist, wird die Methode aufhören zu warten und die Eingabeerfassung nicht beenden.</p></dd>
</dl>
<p><strong>Rückgabewert</strong>: <a href="#EndReason">EndReason</a>.</p>
</div>

<div class="methodShort" id="Stop"><h2>Stop</h2>
<p>Beendet die Eingabeerfassung und setzt <a href="#EndReason">EndReason</a> auf das Wort Stopped.</p>
<pre class="Syntax">InputHook.<span class="func">Stop</span>()</pre>
<p>Hat keine Wirkung, wenn die Eingabeerfassung nicht im Gange ist.</p>
</div>

<div class="methodShort" id="EndKey"><h2>EndKey</h2>
<p>Gibt den Namen der <a href="#EndKeys">Endtaste</a> zurück, die zum Beenden der Eingabeerfassung gedrückt wurde.</p>
<pre class="Syntax">Tastenname := InputHook.EndKey</pre>
<p>Beachten Sie, dass EndKey den "normalisierten" Namen der Taste zurückgibt, egal wie sie in <em>Endtasten</em> geschrieben wurde. <code>{Esc}</code> und <code>{vk1B}</code> beispielsweise erzeugen beide <code>Escape</code>. Mit <a href="GetKey.htm">GetKeyName()</a> kann der normalisierte Name abgerufen werden.</p>
<p>Wenn die <a href="#E">E-Option</a> verwendet wurde, wird EndKey das tatsächlich eingegebene Zeichen zurückgegeben (falls zutreffend). Ansonsten wird der Name auf Basis des aktiven Tastaturlayouts vom Skript bestimmt.</p>
<p>EndKey gibt eine leere Zeichenkette zurück, wenn <a href="#EndReason">EndReason</a> nicht "EndKey" ist.</p>
</div>

<div class="methodShort" id="EndMods"><h2>EndMods</h2>
<p>Gibt eine Zeichenkette mit Modifikatoren zurück, die logisch unten waren, während die Eingabeerfassung beendet wurde.</p>
<pre class="Syntax">Mods := InputHook.EndMods</pre>
<p>Wenn alle Modifikatoren logisch unten (gedrückt) waren, erhält man die folgende Zeichenkette:</p>
<pre>&lt;^&gt;^&lt;!&gt;!&lt;+&gt;+&lt;#&gt;#</pre>
<p>Diese Modifikatoren haben die gleiche Bedeutung wie  die der <a href="../Hotkeys.htm">Hotkeys</a>. Jeder Modifikator ist immer mit &lt; (links) oder &gt; (rechts) gekennzeichnet. Die zugehörigen Tastennamen sind: LCtrl, RCtrl, LAlt, RAlt, LShift, RShift, LWin, RWin.</p>
<p>Mit <a href="InStr.htm">InStr()</a> kann überprüft werden, ob ein bestimmter Modifikator (z. B. <code>&gt;!</code> oder <code>^</code>) vorhanden ist. Die folgende Zeile kann genutzt werden, um <em>Mods</em> in neutrale Modifikatoren umzuwandeln, wie z. B. <code>^!+#</code>:</p>
<pre>Mods := RegExReplace(Mods, "[&lt;&gt;](.)(?:&gt;\1)?", "$1")</pre>
<p>Aufgrund des sehr präzisen Timings ist diese Eigenschaft grundsätzlich zuverlässiger als <a href="GetKeyState.htm">GetKeyState</a>, sogar wenn diese unmittelbar nach Beendigung der Eingabeerfassung oder im <a href="#OnEnd">OnEnd</a>-Callback verwendet wird.</p>
</div>

<div class="methodShort" id="EndReason"><h2>EndReason</h2>
<p>Gibt eine <a href="#EndReasons">EndReason-Zeichenkette</a> zurück, die angibt, wie die Eingabeerfassung beendet wurde.</p>
<pre class="Syntax">Grund := InputHook.EndReason</pre>
<p>Gibt eine leere Zeichenkette zurück, wenn die Eingabeerfassung noch im Gange ist.</p>
</div>

<div class="methodShort" id="InProgress"><h2>InProgress</h2>
<p>Gibt True zurück, wenn die Eingabeerfassung im Gange ist, ansonsten False.</p>
<pre class="Syntax">BoolescherWert := InputHook.InProgress</pre>
</div>

<div class="methodShort" id="Input"><h2>Input</h2>
<p>Gibt den erfassten Text seit dem letzten Start der Eingabeerfassung zurück.</p>
<pre class="Syntax">Zeichenkette := InputHook.Input</pre>
<p>Diese Eigenschaft kann genutzt werden, während die Eingabeerfassung im Gange ist oder nachdem sie beendet wurde.</p>
</div>

<div class="methodShort" id="Match"><h2>Match</h2>
<p>Gibt das Element der <em><a href="#MatchList">Vergleichsliste</a></em> zurück, mit der die Eingabeerfassung beendet wurde.</p>
<pre class="Syntax">Zeichenkette := InputHook.Match</pre>
<p><strong>Rückgabewert</strong>: Das gefundene Element mit originaler Groß-/Kleinschreibung, die sich von dem unterscheiden kann, was der Benutzer eingegeben hat, wenn die <strong>C</strong>-Option weggelassen wurde. Gibt eine leere Zeichenkette zurück, wenn <a href="#EndReason">EndReason</a> nicht "Match" ist.</p>
</div>

<div class="methodShort" id="OnEnd"><h2>OnEnd</h2>
<p>Ermittelt oder setzt das <a href="../objects/Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, wenn die Eingabeerfassung beendet wird.</p>
<pre class="Syntax">MeinFunk := InputHook.OnEnd</pre>
<pre class="Syntax">InputHook.OnEnd := MeinFunk</pre>
<p>Typ: <a href="../objects/Functor.htm">Funktionsobjekt</a> oder <a href="../Concepts.htm#nothing">leere Zeichenkette</a>. Standard: leere Zeichenkette.</p>
<p>Die Funktion akzeptiert einen Parameter: eine Referenz zum InputHook-Objekt.</p>
<p>Die Funktion wird als neuer <a href="../misc/Threads.htm">Thread</a> aufgerufen, demzufolge verwendet sie zu Beginn die Standardwerte von Einstellungen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>.</p>
</div>

<div class="methodShort" id="OnChar"><h2>OnChar</h2>
<p>Ermittelt oder setzt das <a href="../objects/Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, nachdem ein Zeichen zum Eingabepuffer hinzugefügt wurde.</p>
<pre class="Syntax">MeineFunk := InputHook.OnChar</pre>
<pre class="Syntax">InputHook.OnChar := MeineFunk</pre>
<p>Typ: <a href="../objects/Functor.htm">Funktionsobjekt</a> oder <a href="../Concepts.htm#nothing">leere Zeichenkette</a>. Standard: leere Zeichenkette.</p>
<p>Die Funktion akzeptiert folgende Parameter: <code>InputHook, Char</code>. <em>Char</em> ist eine Zeichenkette, die das oder die Zeichen enthält.</p>
<p>Mehrere Zeichen sind ein Hinweis darauf, dass vor dem letzten Tastendruck eine tote Taste verwendet wurde, aber die beiden Tasten nicht zu einem einzigen Zeichen transliteriert (umgewandelt) werden konnten. Auf einigen Tastaturlayouts erzeugt <kbd>`</kbd><kbd>e</kbd> beispielsweise <code>è</code>, während <kbd>`</kbd><kbd>z</kbd> <code>`z</code> erzeugt.</p>
<p>Die Funktion wird nie aufgerufen, wenn eine Endtaste gedrückt wird.</p>
</div>

<div class="methodShort" id="OnKeyDown"><h2>OnKeyDown</h2>
<p>Ermittelt oder setzt das <a href="../objects/Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, wenn eine benachrichtigungsfähige Taste gedrückt wird.</p>
<pre class="Syntax">MeineFunk := InputHook.OnKeyDown</pre>
<pre class="Syntax">InputHook.OnKeyDown := MeineFunk</pre>
<p>Typ: <a href="../objects/Functor.htm">Funktionsobjekt</a> oder <a href="../Concepts.htm#nothing">leere Zeichenkette</a>. Standard: leere Zeichenkette.</p>
<p>Taste-Unten-Benachrichtigungen müssen zuerst via <a href="#KeyOpt">KeyOpt</a> oder <a href="#NotifyNonText">NotifyNonText</a> aktiviert werden.</p>
<p>Die Funktion akzeptiert folgende Parameter: <code>InputHook, VK, SC</code>. <em>VK</em> und <em>SC</em> sind Integer. Zum Abrufen des Tastennamens (sofern vorhanden) können Sie <code>GetKeyName(Format("vk{:x}sc{:x}", VK, SC))</code> nutzen.</p>
<p>Die Funktion wird als neuer <a href="../misc/Threads.htm">Thread</a> aufgerufen, demzufolge verwendet sie zu Beginn die Standardwerte von Einstellungen wie <a href="SendMode.htm">SendMode</a> und <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>.</p>
<p>Die Funktion wird nie aufgerufen, wenn eine Endtaste gedrückt wird.</p>
</div>

<div class="methodShort" id="BackspaceIsUndo"><h2>BackspaceIsUndo</h2>
<p>Legt fest, ob <kbd>Backspace</kbd> das zuletzt gedrückte Zeichen am Ende des Eingabepuffers entfernen soll.</p>
<pre class="Syntax">BoolescherWert := InputHook.BackspaceIsUndo</pre>
<pre class="Syntax">InputHook.BackspaceIsUndo := BoolescherWert</pre>
<p>Typ: <a href="../Concepts.htm#boolean">Integer (boolescher Wert)</a>. Standard: True. Die <strong>B</strong>-Option setzt den Wert auf False.</p>
<p>Wenn <kbd>Backspace</kbd> als "rückgängig machen" agiert, wird die Taste als Texteingabetaste behandelt. Ob die Taste unterdrückt wird, ist insbesondere abhängig von <a href="#VisibleText">VisibleText</a>, nicht von <a href="#VisibleNonText">VisibleNonText</a>.</p>
<p><kbd>Backspace</kbd> wird immer ignoriert, wenn die Taste zusammen mit einer Modifikatortaste wie <kbd>Strg</kbd> gedrückt wird (es wird nicht der physische, sondern der logische Modifikatorstatus geprüft).</p>
<p class="warning"><strong>Hinweis:</strong> Wenn der Eingabetext sichtbar ist (wie z. B. in einem Texteditor) und werden die Pfeiltasten oder andere Mittel zum Navigieren innerhalb des Textes verwendet, wird <kbd>Backspace</kbd> weiterhin das letzte Zeichen entfernen, nicht das Zeichen nach der Einfügemarke.</p>
</div>

<div class="methodShort" id="CaseSensitive"><h2>CaseSensitive</h2>
<p>Legt fest, ob <em>Vergleichsliste</em> Groß-/Kleinschreibung-sensitiv sein soll.</p>
<pre class="Syntax">BoolescherWert := InputHook.CaseSensitive</pre>
<pre class="Syntax">InputHook.CaseSensitive := BoolescherWert</pre>
<p>Typ: <a href="../Concepts.htm#boolean">Integer (boolescher Wert)</a>. Standard: False. Die <strong>C</strong>-Option setzt den Wert auf True.</p>
</div>

<div class="methodShort" id="FindAnywhere"><h2>FindAnywhere</h2>
<p>Legt fest, ob alle Übereinstimmungen ein Teil des Eingabetexts sein sollen.</p>
<pre class="Syntax">BoolescherWert := InputHook.FindAnywhere</pre>
<pre class="Syntax">InputHook.FindAnywhere := BoolescherWert</pre>
<p>Typ: <a href="../Concepts.htm#boolean">Integer (boolescher Wert)</a>. Standard: False. Die <strong>*</strong>-Option setzt den Wert auf True.</p>
<p>Wenn diese Eigenschaft auf True gesetzt wird, kann eine Übereinstimmung überall innerhalb dessen gefunden werden, was der Benutzer eingibt (die Übereinstimmung kann eine Teilzeichenkette des Eingabetexts sein). Wenn diese Eigenschaft auf False gesetzt wird, muss alles, was der Benutzer eingibt, mit eines der Elemente in <em>Vergleichsliste</em> übereinstimmen. In beiden Fällen muss eines der Elemente in <em>Vergleichsliste</em> vollständig eingegeben werden.</p>
</div>

<div class="methodShort" id="MinSendLevel"><h2>MinSendLevel</h2>
<p>Ermittelt oder setzt die minimale <a href="SendLevel.htm">Sendestufe</a> der zu erfassenden Eingabe.</p>
<pre class="Syntax">Stufe := InputHook.MinSendLevel</pre>
<pre class="Syntax">InputHook.MinSendLevel := Stufe</pre>
<p>Typ: <a href="../Concepts.htm#numbers">Integer</a>. Standard: 0. Die <strong>I</strong>-Option setzt den Wert auf 1 (oder den angegebenen Wert).</p>
<p><em>Stufe</em> sollte ein Integer im Bereich von 0 bis 101 sein. Ereignisse, die eine Sendestufe <em>kleiner</em> als dieser Wert haben, werden ignoriert. Ein Wert von 101 bewirkt beispielsweise, dass alle via <a href="Send.htm">SendEvent</a> erzeugten Eingaben ignoriert werden, während ein Wert von 1 nur Eingaben mit der Standardsendestufe (0) ignoriert.</p>
<p><a href="Send.htm#SendInput">SendInput</a> und <a href="Send.htm#SendPlay">SendPlay</a> werden immer ignoriert, egal ob diese Einstellung aktiv ist oder nicht. Eingaben, die von einer anderen Quelle stammen, können niemals über diese Einstellung ignoriert werden.</p>
</div>

<div class="methodShort" id="NotifyNonText"><h2>NotifyNonText</h2>
<p>Legt fest, ob der <a href="#OnKeyDown">OnKeyDown</a>-Callback jedes Mal aufgerufen werden soll, wenn eine Nicht-Text-Taste gedrückt wird.</p>
<pre class="Syntax">BoolescherWert := InputHook.NotifyNonText</pre>
<pre class="Syntax">InputHook.NotifyNonText := BoolescherWert</pre>
<p>Typ: <a href="../Concepts.htm#boolean">Integer (boolescher Wert)</a>. Standard: False.</p>
<p>Wenn diese Eigenschaft auf True gesetzt wird, werden Benachrichtigungen für alle Tastendrücke aktiviert, die keinen Text erzeugen, wie z. B. <kbd>←</kbd> oder <kbd>Alt</kbd>+<kbd>F</kbd>. Das Setzen dieser Eigenschaft hat keinen Einfluss auf die <a href="#KeyOpt">Optionen</a> einer Taste, da die Texterzeugung vom Tastaturlayout des aktiven Fensters zum Zeitpunkt des Tastendrucks abhängt. </p>
<p>Informationen darüber, welche Tasten als Texterzeuger eingestuft werden, finden Sie unter <a href="#VisibleText">VisibleText</a>.</p>
</div>

<div class="methodShort" id="Timeout"><h2>Timeout</h2>
<p>Ermittelt oder setzt den Timeout-Wert in Sekunden.</p>
<pre class="Syntax">Sekunden := InputHook.Timeout</pre>
<pre class="Syntax">InputHook.Timeout := Sekunden</pre>
<p>Typ: <a href="../Concepts.htm#numbers">Float</a>. Standard: 0.0 (kein Timeout). Die <strong>T</strong>-Option setzt auch den Timeout-Wert.</p>
<p>Die Timeout-Periode beginnt normalerweise mit dem Aufruf von <a href="#Start">Start</a>. Wenn aber diese Eigenschaft ein Wert zugewiesen bekommt, während die Eingabeerfassung im Gange ist, wird die Timeout-Periode neu gestartet. Wenn die Eingabeerfassung nach Ablauf der Timeout-Periode noch im Gange ist, wird diese beendet und <a href="#EndReason">EndReason</a> auf das Wort Timeout gesetzt.</p>
</div>

<div class="methodShort" id="VisibleNonText"><h2>VisibleNonText</h2>
<p>Legt fest, ob Tasten oder Tastenkombinationen, die keinen Text erzeugen, sichtbar sein (blockiert werden) sollen.</p>
<pre class="Syntax">BoolescherWert := InputHook.VisibleNonText</pre>
<pre class="Syntax">InputHook.VisibleNonText := BoolescherWert</pre>
<p>Typ: <a href="../Concepts.htm#boolean">Integer (boolescher Wert)</a>. Standard: True. Die <strong>V</strong>-Option setzt den Wert auf True.</p>
<p>Wenn diese Eigenschaft auf True gesetzt wird, können Tasten und Tastenkombinationen, die keinen Text erzeugen, Hotkeys auslösen oder an das aktive Fenster weitergeleitet werden. Wenn diese Eigenschaft auf False gesetzt wird, werden diese blockiert.</p>
<p>Informationen darüber, welche Tasten als Texterzeuger eingestuft werden, finden Sie unter <a href="#VisibleText">VisibleText</a>.</p>
</div>

<div class="methodShort" id="VisibleText"><h2>VisibleText</h2>
<p>Legt fest, ob Tasten oder Tastenkombinationen, die Text erzeugen, sichtbar sein (blockiert werden) sollen.</p>
<pre class="Syntax">BoolescherWert := InputHook.VisibleText</pre>
<pre class="Syntax">InputHook.VisibleText := BoolescherWert</pre>
<p>Typ: <a href="../Concepts.htm#boolean">Integer (boolescher Wert)</a>. Standard: False. Die <strong>V</strong>-Option setzt den Wert auf True.</p>
<p>Wenn diese Eigenschaft auf True gesetzt wird, können Tasten und Tastenkombinationen, die Text erzeugen, Hotkeys auslösen oder an das aktive Fenster weitergeleitet werden. Wenn diese Eigenschaft auf False gesetzt wird, werden diese blockiert.</p>
<p>Alle Tastendrücke, die dazu führen, dass Text an den Eingabepuffer angehängt wird, werden als Texterzeuger eingestuft, auch wenn sie dies in anderen Anwendungen normalerweise nicht tun. <kbd>Strg</kbd>+<kbd>A</kbd> beispielsweise erzeugt Text, wenn die <a href="#option-m"><strong>M</strong>-Option</a> vorhanden ist, und <kbd>Escape</kbd> erzeugt das Steuerzeichen <code>Chr(27)</code>.</p>
<p>Tote Tasten werden als Texterzeuger eingestuft, obwohl sie in der Regel keinen unmittelbaren Effekt haben. Das Drücken einer toten Taste kann auch dazu führen, dass die folgende Taste Text erzeugt (wenn auch nur das Zeichen der toten Taste).</p>
<p><kbd>Backspace</kbd> wird nur als Texterzeuger eingestuft, wenn es <a href="#BackspaceIsUndo">als "rückgängig machen"</a> fungiert.</p>
<p>Die <a href="../KeyList.htm#modifier">Standardmodifikatortasten</a> und CapsLock, NumLock und ScrollLock sind immer sichtbar (nicht blockiert).</p>
</div>

<h2 id="EndReasons">EndReason</h2>
<p>Die EndReason-Eigenschaft gibt eine der folgenden Zeichenketten zurück:</p>
<table class="info">
  <tr>
    <td>Stopped</td>
    <td>Die Stop-Methode wurde aufgerufen oder Start wurde bisher noch nicht aufgerufen.</td>
  </tr>
  <tr>
    <td>Max</td>
    <td>Die Eingabeerfassung hat die maximal erlaubte Länge erreicht und stimmt mit keinem der Elemente in <em>Vergleichsliste</em> überein.</td>
  </tr>
  <tr>
    <td>Timeout</td>
    <td>Die Eingabeerfassung hat die Zeit überschritten.</td>
  </tr>
  <tr>
    <td>Match</td>
    <td>Die Eingabeerfassung stimmt mit einem der Elemente in <em>Vergleichsliste</em> überein. Die <a href="#Match">Match</a>-Eigenschaft enthält das gefundene Element.</td>
  </tr>
  <tr>
    <td>EndKey</td>
    <td>
      <p>Eine der <em>Endtasten</em> wurde gedrückt, um die Eingabeerfassung zu beenden. Die <a href="#EndKey">EndKey</a>-Eigenschaft enthält den Namen oder das Zeichen (ohne geschweifte Klammern) der entsprechenden Endtaste.</p>
    </td>
  </tr>
  <tr>
    <td></td>
    <td>Wenn die Eingabeerfassung im Gange ist, ist EndReason leer.</td>
  </tr>
</table>

<h2 id="Remarks">Bemerkungen</h2>
<p>Die <a href="#Start">Start</a>-Methode kann nur aufgerufen werden, wenn die Eingabeerfassung nicht im Gange ist.</p>
<p>InputHook ist so konzipiert, dass verschiedene Teile des Skripts die Eingabe mit geringem Konfliktpotenzial überwachen können. Es kann kontinuierlich laufen, um z. B. auf <a href="#ExSac">willkürliche Wörter</a> oder andere Muster zu reagieren. Es kann auch zeitweise genutzt werden, um z. B. Benutzereingaben zu erfassen oder vorübergehend bestimmte (oder <a href="#ExKeyWaitAny">unbestimmte</a>) Tasten zu überschreiben, ohne Hotkeys zu beeinträchtigen.</p>
<p>Tastatur-<a href="../Hotkeys.htm">Hotkeys</a> bleiben wirksam, während eine Eingabeerfassung im Gange ist, aber können nicht von Tasten ausgelöst werden, die von der Eingabeerfassung unterdrückt werden.</p>
<p>Tasten werden entweder unterdrückt (blockiert) oder nicht, abhängig von den folgenden Faktoren (in dieser Reihenfolge):</p>
<ul>
  <li>Wenn die <a href="#KeyOpt-v">V-Option</a> bei diesen VK oder SC  wirksam ist, wird sie nicht unterdrückt.</li>
  <li>Wenn die <a href="#KeyOpt-s">S-Option</a> bei diesen VK oder SC wirksam ist, wird sie unterdrückt.</li>
  <li>Wenn die Taste eine <a href="../KeyList.htm#modifier">Standardmodifikatortaste</a> oder CapsLock, NumLock oder ScrollLock ist, wird sie nicht unterdrückt.</li>
  <li><a href="#VisibleText">VisibleText</a> oder <a href="#VisibleNonText">VisibleNonText</a> wird herangezogen, je nachdem, ob die Taste Text erzeugt oder nicht. Wenn die Eigenschaft False ist, wird die Taste unterdrückt. Informationen darüber, welche Tasten als Texterzeuger eingestuft werden, finden Sie unter <a href="#VisibleText">VisibleText</a>.</li>
</ul>
<p>Der <a href="_InstallKeybdHook.htm">Tastatur-Hook</a> wird benötigt, während eine Eingabeerfassung im Gange ist, wird aber automatisch deinstalliert, wenn er nach Beendigung der Eingabeerfassung nicht mehr benötigt wird. Der Tastatur-Hook (sofern installiert) bewirkt, dass das Skript vorübergehend <a href="_Persistent.htm">persistent</a> wird; das heißt, dass das Skript nur noch mit <a href="ExitApp.htm">ExitApp</a> beendet werden kann.</p>
<p>AutoHotkey unterstützt keine Input Method Editors (IME). Der Tastatur-Hook fängt Tastaturereignisse ab und wandelt sie mithilfe von <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-tounicodeex">ToUnicodeEx</a> oder ToAsciiEx in Text um (außer im Falle von <a href="https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes#vk_packet">VK_PACKET</a>-Ereignissen, die ein einzelnes Zeichen beinhalten).</p>
<p>Wenn Sie mehrere Sprachen oder Tastaturlayouts verwenden, greift die Eingabeerfassung auf das Tastaturlayout des aktiven Fensters statt auf die des Skripts zurück (egal ob die Eingabeerfassung <a href="#vis">sichtbar</a> ist oder nicht).</p>
<p>Trotz ihrer geringeren Flexibilität sind <a href="../Hotstrings.htm">Hotstrings</a> in der Regel einfacher zu bedienen.</p>

<h2 id="comparison">InputHook vs. Input</h2>
<p>InputHook und der <a href="Input.htm">Input</a>-Befehl sind zwei verschiedene Schnittstellen, die im Grunde die gleiche Funktionalität bieten. Die folgenden zwei Beispiele sind funktionsgemäß nahezu identisch:</p>
<pre>
Input, AusgabeVar, %Optionen%, %Endtasten%, %Vergleichsliste%
</pre><pre>
ih := InputHook(Optionen, Endtasten, Vergleichsliste)
ih.Start()
ErrorLevel := ih.Wait()
if (ErrorLevel = "EndKey")
    ErrorLevel .= ":" ih.EndKey
AusgabeVar := ih.Input
</pre>
<p>Der Input-Befehl beendet jede vorher von ihm gestartete Eingabeerfassung, während InputHook <a href="#stack">mehrere Eingabeerfassungen</a> gleichzeitig erlaubt.</p>
<p><em>Optionen</em> wird gleichermaßen interpretiert, allerdings gibt es Unterschiede bei den Standardeinstellungen:</p>
<ul>
  <li>Der Input-Befehl limitiert die Länge der Eingabe auf 16383, während InputHook diese auf 1023 limitiert. Dies kann mit der <a href="#option-l">L-Option</a> überschrieben werden (ohne absoluten Maximum).</li>
  <li>Der Input-Befehl blockiert standardmäßig sowohl Text- als auch Nicht-Text-Tastendrücke, und blockiert keine der beiden, wenn die <a href="Input.htm#vis">V-Option</a> vorhanden ist. InputHook dagegen blockiert standardmäßig nur Text-Tastendrücke (<a href="#VisibleNonText">VisibleNonText</a> ist standardmäßig True), dadurch können die meisten Hotkeys verwendet werden, während eine Eingabeerfassung im Gange ist.</li>
</ul>
<p>Der Input-Befehl blockiert den <a href="../misc/Threads.htm">Thread</a>, während eine Eingabeerfassung im Gange ist, wohingegen InputHook dem Thread erlaubt, fortzufahren oder sogar beendet zu werden (wodurch jeder von ihm unterbrochene Thread fortgesetzt werden kann). Anstatt zu warten, kann das Skript eine <a href="#OnEnd">OnEnd</a>-Funktion registrieren, die aufgerufen wird, wenn die Eingabeerfassung beendet wird.</p>
<p>Der Input-Befehl gibt die Eingabe des Benutzers erst zurück, nachdem die Eingabeerfassung beendet wurde, während mit der <a href="Input.htm">Input</a>-Eigenschaft von InputHook die aktuelle Eingabe des Benutzers jederzeit abgerufen werden kann. Anstatt ständig die Input-Eigenschaft zu prüfen, kann das Skript eine <a href="#OnChar">OnChar</a>-Funktion registrieren, die jedes Mal aufgerufen wird, wenn ein Zeichen hinzugefügt wird.</p>
<p>InputHook ermöglicht deutlich mehr Kontrolle über einzelne Tasten via <a href="#KeyOpt">KeyOpt</a>-Methode. Dazu gehört das Hinzufügen oder Entfernen von Endtasten, das Unterdrücken oder Nicht-Unterdrücken bestimmter Tasten oder das Ignorieren von Texterzeugnissen bestimmter Tasten.</p>
<p>Im Gegensatz zum Input-Befehl kann InputHook genutzt werden, um Tasten zu erkennen, die keinen Text erzeugen, <em>ohne</em> die Eingabeerfassung zu beenden. Hierzu wird eine <a href="#OnKeyDown">OnKeyDown</a>-Funktion registriert und <a href="#KeyOpt">KeyOpt</a> oder <a href="#NotifyNonText">NotifyNonText</a> verwendet, um die zu betreffenden Tasten anzugeben.</p>
<p>Wenn eines der Elemente in <em>Vergleichsliste</em> die Eingabeerfassung beendet hat, kann die <a href="#Match">Match</a>-Eigenschaft herangezogen werden, um genau zu bestimmen, welche Übereinstimmung eingetreten ist (vor allem dann, wenn die <a href="#asterisk">*-Option</a> vorhanden ist).</p>
<p>Obwohl das Skript <a href="GetKeyState.htm">GetKeyState</a> nach einem Input-Befehl heranziehen kann, spiegelt es manchmal nicht genau wider, welche Tasten gedrückt wurden, nachdem die Eingabeerfassung beendet wurde. Die <a href="#EndMods">EndMods</a>-Eigenschaft von InputHook spiegelt den logischen Zustand der Modifikatortasten zum Zeitpunkt der Beendigung der Eingabeerfassung wider.</p>
<p>Es gibt einige Unterschiede in Bezug auf die Abwärtskompatibilität:</p>
<ul>
  <li>Der Input-Befehl speichert Endtasten <kbd>A</kbd>-<kbd>Z</kbd> in Großbuchstaben, obwohl andere Buchstaben auf einigen Tastaturlayouts kleingeschrieben sind. Übergibt man den Wert an <a href="Send.htm">Send</a>, würde es ungewollt einen UMSCHALT-modifizierten Tastendruck erzeugen. Die <a href="#EndKeys">EndKeys</a>-Eigenschaft von InputHook gibt dagegen immer den normalisierten Namen zurück; also das Zeichen, das die Taste erzeugen würde, wenn kein <kbd>Umschalt</kbd> oder andere Modifikatoren gedrückt gehalten werden.</li>
  <li><p>Wenn ein Tastenname in <em>Endtasten</em> einem VK entspricht, der von zwei physischen Tasten verwendet wird (z. B. <kbd>NumpadUp</kbd> und <kbd>Up</kbd>), wird der Input-Befehl die primäre Taste via VK und die sekundäre Taste via SC behandeln, während InputHook beide via SC behandelt. Mit der Schreibweise <code>{vkNN}</code> kann die Taste via VK behandelt werden.</p>
  <p>Wenn die Endtaste via VK behandelt wird, können beide physikalischen Tasten die Eingabeerfassung beenden. <code>{NumpadUp}</code> beispielsweise würde bewirken, dass der Input-Befehl mit <kbd>Up</kbd> beendet werden kann, allerdings würde ErrorLevel <code>EndKey:NumpadUp</code> enthalten, da nur der VK berücksichtigt wird.</p>
  <p>Wenn eine Endtaste via SC behandelt wird, erzeugt der Input-Befehl immer Namen für den bekannten sekundären SC eines bestimmten VKs, und für alle anderen Tasten immer <code>sc<i>NNN</i></code> (selbst wenn sie einen Namen hat). InputHook dagegen erzeugt einen Namen, wenn die Tasten einen hat.</p></li>
</ul>

<h2>Siehe auch</h2>
<p><a href="Input.htm">Input</a>, <a href="KeyWait.htm">KeyWait</a>, <a href="../Hotstrings.htm">Hotstrings</a>, <a href="InputBox.htm">InputBox</a>, <a href="_InstallKeybdHook.htm">#InstallKeybdHook</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="IfIn.htm">if Var in/contains Vergleichsliste</a></p>

<h2>Beispiele</h2>
<div class="ex" id="ExKeyWaitAny">
<p><a href="#ExKeyWaitAny">#1</a>: Wartet darauf, dass der Benutzer eine einzelne Taste drückt.</p>
<pre>
MsgBox % KeyWaitAny()

<em>; Das Gleiche nochmal, aber ohne dass die Taste blockiert wird.</em>
MsgBox % KeyWaitAny("V")

KeyWaitAny(Optionen:="")
{
    ih := InputHook(Optionen)
    ih.KeyOpt("{All}", "ES")  <em>; End und Suppress</em>
    ih.Start()
    ErrorLevel := ih.Wait()  <em>; EndReason in ErrorLevel speichern</em>
    return ih.EndKey  <em>; Tastenname zurückgeben</em>
}
</pre>
</div>
<div class="ex" id="ExKeyWaitCombo">
<p><a href="#ExKeyWaitCombo">#2</a>: Wartet auf eine Taste in Kombination mit Strg/Alt/Umschalt/Win.</p>
<pre>
MsgBox % KeyWaitCombo()

KeyWaitCombo(Optionen:="")
{
    ih := InputHook(Optionen)
    ih.KeyOpt("{All}", "ES")  <em>; End und Suppress</em>
    <em>; Modifikatoren ausschließen</em>
    ih.KeyOpt("{LCtrl}{RCtrl}{LAlt}{RAlt}{LShift}{RShift}{LWin}{RWin}", "-ES")
    ih.Start()
    ErrorLevel := ih.Wait()  <em>; EndReason in ErrorLevel speichern</em>
    return ih.EndMods . ih.EndKey  <em>; Eine Zeichenkette wie &lt;^&lt;+Esc zurückgeben</em>
}
</pre>
</div>
<div class="ex" id="ExSac">
<p><a href="#ExSac">#3</a>: Einfache Auto-Vervollständigung eines beliebigen Wochentages. Dies ist ein voll funktionsfähiges Beispiel. Starten Sie einfach das Skript und beginnen Sie, den Namen eines Tages zu schreiben. Drücken Sie <kbd>Tab</kbd>, um den Namen zu vervollständigen, oder drücken Sie <kbd>Escape</kbd>, um das Skript zu beenden.</p>
<pre>global Wortliste := "Montag`nDienstag`nMittwoch`nDonnerstag`nFreitag`nSamstag`nSonntag"

global Suffix := "", SacHook

SacHook := InputHook("V", "{Esc}")
SacHook.OnChar := Func("SacChar")
SacHook.OnKeyDown := Func("SacKeyDown")
SacHook.OnEnd := Func("SacEnd")
SacHook.KeyOpt("{Backspace}", "N")
SacHook.Start()

SacChar(ih, char)  <em>; Wird aufgerufen, wenn ein Zeichen zu SacHook.Input hinzugefügt wird.</em>
{
    Suffix := ""
    if RegExMatch(ih.Input, "`nm)\w+$", prefix)
        RegExMatch(Wortliste, "`nmi)^" prefix "\K.*", Suffix)
    
    ToolTip % Suffix, % A_CaretX + 15, % A_CaretY    
    
    <em>; Tab nur abfangen, während ein ToolTip angezeigt wird.</em>
    ih.KeyOpt("{Tab}", Suffix = "" ? "-NS" : "+NS")
}

SacKeyDown(ih, vk, sc)
{
    if (vk = 8) <em>; Backspace</em>
        SacChar(ih, "")
    else if (vk = 9) <em>; Tab</em>
        Send % "{Text}" Suffix
}

SacEnd()
{
    ExitApp
}
</pre>
</div>

</body>
</html>
