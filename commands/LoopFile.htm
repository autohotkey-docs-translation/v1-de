<!DOCTYPE HTML>
<html>
<head>
<title>Loop (Dateien & Ordner)</title>
<meta name="keywords" content="Befehl, Ablaufsteuerung, Datei, Ordner, Schleife">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <article>
      <h1>Loop (Dateien & Ordner)</h1>
      <p>Ermittelt nacheinander die angegebenen Dateien oder Ordner.</p>
      <pre class="Syntax">Loop, Dateimuster [, OrdnerEinbeziehen?, Rekursiv?] </pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Dateimuster</td>
          <td style="width: 85%;"><p>Der Name einer Datei, eines Ordners oder einer musterbasierten Suche wie C:\Temp\*.tmp. <em>Dateimuster</em> befindet sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist.</p>
            <p>Sowohl Sternchen als auch Fragezeichen werden als Platzhalter unterst&uuml;tzt. Eine &Uuml;bereinstimmung erfolgt, wenn das Muster mit dem langen/normalen oder <a href="#LoopFileShortName">8.3-kurzen</a> Dateinamen &uuml;bereinstimmt.</p>
            <p>Wenn dieser Parameter eine Datei oder einen Ordner enth&auml;lt (also ohne Platzhalter) und <em>Rekursiv</em> auf 1 gesetzt ist, werden mehrere &Uuml;bereinstimmungen gefunden, sobald der angegebene Dateiname in mehreren Ordnern vorkommt.</p></td>
        </tr>
        <tr>
          <td>OrdnerEinbeziehen?</td>
          <td><p>Eine der folgenden Ziffern, oder leer lassen, um den Standardwert zu verwenden:<br>
              0 (Standard) Ordner werden nicht ermittelt (nur Dateien).<br>
              1 Alle Dateien und Ordner, die der musterbasierten Suche entsprechen, werden ermittelt.<br>
              2 Nur Ordner werden ermittelt (keine Dateien).</p></td>
        </tr>
        <tr>
          <td>Rekursiv?</td>
          <td>Eine der folgenden Ziffern, oder leer lassen, um den Standardwert zu verwenden:<br>
            0 (Standard) Unterordner werden nicht durchsucht.<br>
            1 Unterordner werden auch durchsucht, so dass darin enthaltene Dateien und Unterordner ermittelt werden, die mit <em>Dateimuster</em> &uuml;bereinstimmen. Alle Unterordner werden durchsucht, nicht nur solche, deren Namen mit <em>Dateimuster</em> &uuml;bereinstimmen. </td>
        </tr>
      </table>
      <h3>Spezielle Variablen innerhalb einer Datei-Schleife</h3>
      <p>Folgende Variablen existieren innerhalb einer dateilesenden Schleife. Wenn eine innere Datei-Schleife von einer &auml;u&szlig;eren Datei-Schleife umschlossen ist, hat die Datei von der innersten Schleife Vorrang.</p>
      <table class="info">
        <tr>
          <td>A_LoopFileName</td>
          <td id="LoopFileName">Der aktuell ermittelte Datei- oder Ordnername (ohne Pfad).</td>
        </tr>
        <tr>
          <td id="LoopFileExt">A_LoopFileExt</td>
          <td>Die Dateierweiterung (z. B. TXT, DOC oder EXE). Der Punkt (.) ist nicht inbegriffen.</td>
        </tr>
        <tr>
          <td>A_LoopFileFullPath</td>
          <td id="LoopFileFullPath">Der aktuell ermittelte Datei- oder Ordnername mit vollst&auml;ndigem Pfad. Wenn <em>Dateimuster</em> allerdings anstelle eines absoluten Pfads einen relativen Pfad enth&auml;lt, ist dieser Pfad hier auch relativ. Dar&uuml;ber hinaus werden kurze (8.3) Ordnernamen in <em>Dateimuster</em> weiterhin kurz sein (siehe n&auml;chsten Punkt, um die lange Version zu erhalten). </td>
        </tr>
        <tr>
          <td>A_LoopFileLongPath</td>
          <td id="LoopFileLongPath"><p>Diese Variable unterscheidet sich von A_LoopFileFullPath wie folgt:</p>
            <ul>
              <li>Sie enth&auml;lt immer den absoluten/kompletten Pfad der Datei, auch dann, wenn <em>Dateimuster</em> einen relativen Pfad enth&auml;lt</li>
              <li>Jeder kurze (8.3) Ordnername in <em>Dateimuster</em> wird in einem langen Namen umgewandelt</li>
              <li>Die Zeichen in <em>Dateimuster</em> werden an die Gro&szlig;- oder Kleinschreibung angepasst, wie sie aktuell im Dateisystem gespeichert sind. Das ist n&uuml;tzlich, um Dateinamen (die zum Beispiel als Befehlszeilenparameter &uuml;bergeben wurden) in ihre exakten Pfadnamen umzuwandeln, wie sie vom Explorer angezeigt werden.</li>
            </ul></td>
        </tr>
        <tr>
          <td>A_LoopFileShortPath</td>
          <td><p id="LoopFileShortPath">Der aktuell ermittelte Datei- oder Ordnername mit Pfad im 8.3-Format. Zum Beispiel: C:\EIGENE~1\ADRESS~1.TXT. Wenn <em>Dateimuster</em> allerdings anstelle eines absoluten Pfads einen relativen Pfad enth&auml;lt, ist dieser Pfad hier auch relativ.</p>
            <p>Um den kompletten Pfad und Namen im 8.3-Format von einer einzelnen Datei oder Ordners abzurufen, muss deren Name wie folgt in <em>Dateimuster</em> angegeben werden:</p>
            <pre>Loop, C:\Eigene Dokumente\Adressliste.txt
    KurzerPfadname = %A_LoopFileShortPath%</pre>
            <p>HINWEIS: Diese Variable wird <strong>leer</strong> sein, wenn die Datei keinen kurzen Namen hat. Das passiert zum Beispiel, wenn NtfsDisable8dot3NameCreation in der Registrierung vorhanden ist. Sie ist auch leer, wenn <em>Dateimuster</em> einen relativen Pfad enth&auml;lt und der Schleifenk&ouml;rper <a href="SetWorkingDir.htm">SetWorkingDir</a> verwendet, um vom eigentlichen Arbeitsverzeichnis der Schleife selbst wegzuschalten.</p></td>
        </tr>
        <tr>
          <td>A_LoopFileShortName</td>
          <td id="LoopFileShortName">Der 8.3-Kurzname, oder alternative Name der Datei. Falls die Datei keinen Kurznamen hat (weil der lange Name k&uuml;rzer als der 8.3-Name ist oder die Kurznamengenerierung auf einem NTFS-Dateisystem deaktiviert ist), wird stattdessen <em>A_LoopFileName</em> abgerufen. </td>
        </tr>
        <tr>
          <td>A_LoopFileDir</td>
          <td id="LoopFileDir">Der vollst&auml;ndige Pfad des Verzeichnisses, in der sich <em>A_LoopFileName</em> befindet. Wenn <em>Dateimuster</em> allerdings anstelle eines absoluten Pfads einen relativen Pfad enth&auml;lt, dann ist dieser Pfad hier auch relativ. Ein Hauptverzeichnis wird keinen nachfolgenden Backslash enthalten. Zum Beispiel: C:</td>
        </tr>
        <tr>
          <td>A_LoopFileTimeModified</td>
          <td id="LoopFileTimeModified">Wann die Datei zuletzt bearbeitet wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
        </tr>
        <tr>
          <td>A_LoopFileTimeCreated</td>
          <td id="LoopFileTimeCreated">Wann die Datei erstellt wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
        </tr>
        <tr>
          <td>A_LoopFileTimeAccessed</td>
          <td id="LoopFileTimeAccessed">Wann die Datei zuletzt aufgerufen wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
        </tr>
        <tr>
          <td>A_LoopFileAttrib</td>
          <td id="LoopFileAttrib">Die <a href="FileGetAttrib.htm">Attribute</a> der aktuell ermittelten Datei.</td>
        </tr>
        <tr>
          <td>A_LoopFileSize</td>
          <td id="LoopFileSize">Die Gr&ouml;&szlig;e in Bytes der aktuell ermittelten Datei. Dateien gr&ouml;&szlig;er als 4 Gigabyte werden ebenfalls unterst&uuml;tzt.</td>
        </tr>
        <tr>
          <td>A_LoopFileSizeKB</td>
          <td id="LoopFileSizeKB">Die Gr&ouml;&szlig;e in Kilobytes der aktuell ermittelten Datei, abgerundet auf den n&auml;chsten Integer.</td>
        </tr>
        <tr>
          <td>A_LoopFileSizeMB</td>
          <td id="LoopFileSizeMB">Die Gr&ouml;&szlig;e in Megabytes der aktuell ermittelten Datei, abgerundet auf den n&auml;chsten Integer.</td>
        </tr>
      </table>
      <h3>Bemerkungen</h3>
      <p>Eine Datei-Schleife ist n&uuml;tzlich, wenn mehrere Dateien und/oder Ordner nacheinander bearbeitet werden sollen.</p>
      <p>Alle &uuml;bereinstimmenden Dateien werden ermittelt, einschlie&szlig;lich versteckte Dateien. OS-Funktionen wie der DIR-Befehl lassen hingegen versteckte Dateien standardm&auml;&szlig;ig weg. Um die Bearbeitung von versteckten, schreibgesch&uuml;tzten und/oder System-Dateien zu vermeiden, kann folgendes Beispiel innerhalb der Schleife verwendet werden:</p>
      <pre>If A_LoopFileAttrib contains H,R,S  <em>; Jede Datei &uuml;berspringen, die H (versteckt), R (schreibgesch&uuml;tzt) oder S (vom System) ist. Hinweis: Keine Leerzeichen in "H,R,S".</em>
    continue  <em>; Diese Datei &uuml;berspringen und zur N&auml;chsten gehen</em></pre>
      <p>Um anstelle der absoluten Pfade die relativen Pfade von den Dateien beim rekursiven Suchen zu ermitteln, muss mit <a href="SetWorkingDir.htm">SetWorkingDir</a> der Basisordner ge&auml;ndert werden, bevor die Schleife erfolgt. Danach muss in der Schleife selbst der Pfad weggelassen werden (z. B. <code>Loop, *.*, 0, 1</code>). Das bewirkt, dass <a href="#LoopFileFullPath">A_LoopFileFullPath</a> den relativen Pfad f&uuml;r den Basisordner der Datei enth&auml;lt.</p>
      <p>Eine Datei-Schleife kann sich selbst unterbrechen, wenn sie Dateien oder Ordner innerhalb der eigenen Zust&auml;ndigkeit erstellt oder umbenennt. Wenn die Dateien in der Schleife zum Beispiel mit <a href="FileMove.htm">FileMove</a> umbenannt werden, kann es passieren, dass diese jeweils zweimal gefunden werden: einmal mit dem alten Namen und nochmal mit dem neuen Namen. Als &Uuml;bergangsl&ouml;sung sollten die Dateien nur umbenannt werden, nachdem eine Liste von denen erstellt wurde. Zum Beispiel:</p>
      <pre>Dateiliste =
Loop *.jpg
   Dateiliste = %Dateiliste%%A_LoopFileName%`n
Loop, parse, Dateiliste, `n
   FileMove, %A_LoopField%, unbenannt_%A_LoopField%</pre>
      <p>Dateien in einem NTFS-Dateisystem werden wahrscheinlich immer in alphabetischer Reihenfolge abgerufen. Dateien in anderen Dateisystemen werden in keiner bestimmten Reihenfolge abgerufen. Um eine bestimmte Reihenfolge sicherzustellen, sollte der <a href="Sort.htm">Sort</a>-Befehl verwendet werden, wie unten im Abschnitt "Beispiele" gezeigt.</p>
      <p>Dateien und Ordner mit einem kompletten Pfad l&auml;nger als 259 Zeichen werden ignoriert, als w&uuml;rde sie nicht existieren. Solche Dateien sind normalerweise selten, weil das Betriebssystem nicht erlaubt, dass diese erstellt werden k&ouml;nnen.</p>
      <p>Auf der <a href="Loop.htm">Loop</a>-Seite k&ouml;nnen Informationen zu <a href="Block.htm">Blocks</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index gefunden werden (weil diese in jeder Schleifenvariante vorkommen).</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blocks</a>, <a href="SplitPath.htm">SplitPath</a>, <a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>
      <h3>Beispiele</h3>
      <pre class="NoIndent"><em>; Beispiel #1:</em>
Loop, %A_ProgramFiles%\*.txt, , 1  <em>; Unterordner auch durchsuchen (rekursiv).</em>
{
    MsgBox, 4, , Dateiname = %A_LoopFileFullPath%`n`nFortfahren?
    IfMsgBox, No
        break
}</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #2: Berechnet die Gr&ouml;&szlig;e des Ordners, einschlie&szlig;lich die Dateien seiner Unterordner:</em>
SetBatchLines, -1  <em>; F&uuml;hrt die Operation mit maximaler Geschwindigkeit aus.</em>
OrdnerGr&ouml;&szlig;eKB = 0
FileSelectFolder, Ordner  <em>; Fordert den Benutzer auf, einen Ordner auszuw&auml;hlen.</em>
Loop, %Ordner%\*.*, , 1
    OrdnerGr&ouml;&szlig;eKB += %A_LoopFileSizeKB%
MsgBox Der Ordner %Ordner% hat eine Gr&ouml;&szlig;e von %OrdnerGr&ouml;&szlig;eKB% KB.</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #3: Ermittelt Dateinamen, die nach Name sortiert sind (siehe n&auml;chstes Beispiel, wie nach Datum sortiert werden kann):</em>
Dateiliste =  <em>; Leere Variable initialisieren.</em>
Loop, C:\*.*
    Dateiliste = %Dateiliste%%A_LoopFileName%`n
Sort, Dateiliste, R  <em>; Die R-Option sortiert in umgekehrter Richtung. Siehe <a href="Sort.htm">Sort</a> f&uuml;r weitere Optionen.</em>
Loop, parse, Dateiliste, `n
{
    If A_LoopField =  <em>; Ignoriert das leere Element am Ende der Liste.</em>
        continue
    MsgBox, 4,, Dateinummer %A_Index% ist %A_LoopField%.  Weiter?
    IfMsgBox, No
        break
}</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #4: Ermittelt Dateinamen, die nach &Auml;nderungsdatum sortiert sind:</em>
Dateiliste =
Loop, %A_MyDocuments%\Fotos\*.*, 1
    Dateiliste = %Dateiliste%%A_LoopFileTimeModified%`t%A_LoopFileName%`n
Sort, Dateiliste  <em>; Nach Datum sortieren.</em>
Loop, parse, Dateiliste, `n
{
    If A_LoopField =  <em>; L&auml;sst das letzte LF-Zeichen (leeres Element) am Ende der Liste weg.</em>
        continue
    StringSplit, Dateielement, A_LoopField, %A_Tab%  <em>; Beim Tab-Zeichen in zwei Teile aufteilen.</em>
    MsgBox, 4,, Die n&auml;chste Datei ist (modifiziert am %Dateielement1%):`n%Dateielement2%`n`nWeiter?
    IfMsgBox, No
        break
}</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #5: Kopiert nur Quelldateien ins Ziel, die neuer sind als ihr Gegenst&uuml;ck:</em>
KopierenWennNeuer:
<em>; Die Variablen KopieQuellmuster und KopieZiel wurden vorher gesetzt.</em>
Loop, %KopieQuellmuster%
{
    kopieren = n
    IfNotExist, %KopieZiel%\%A_LoopFileName%  <em>; Immer kopieren, falls die Zieldatei noch nicht existiert.</em>
        kopieren = y
    Else
    {
        FileGetTime, Zeitstempel, %KopieZiel%\%A_LoopFileName%
        EnvSub, Zeitstempel, %A_LoopFileTimeModified%, seconds  <em>; Subtrahiert die Zeit der Quelldatei mit der Zeit der Zieldatei.</em>
        If Zeitstempel &lt; 0  <em>; Quelldatei ist neuer als Zieldatei.</em>
            kopieren = y
    }
    If kopieren = y
    {
        FileCopy, %A_LoopFileFullPath%, %KopieZiel%\%A_LoopFileName%, 1   <em>; Kopieren und &uuml;berschreiben.</em>
        If ErrorLevel
            MsgBox, "%A_LoopFileFullPath%" konnte nicht nach "%KopieZiel%\%A_LoopFileName%" kopiert werden.
    }
}
Return</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #6: Konvertiert Dateinamen, die mittels Kommandozeilen-Parameter &uuml;bergeben wurden, in lange Namen,
; vervollst&auml;ndigt den Pfad und korrigiert die Gro&szlig;- und Kleinbuchstaben, wie sie im Dateisystem gespeichert sind.</em>
Loop %0%  <em>; F&uuml;r jede Datei, die auf das Script abgelegt wurde (oder als Parameter &uuml;bergeben wurde).</em>
{
    Pfadangabe := %A_Index%  <em>; Ermittelt den n&auml;chsten Befehlszeilenparameter.</em>
    Loop %Pfadangabe%, 1
        LangerPfad = %A_LoopFileLongPath%
    MsgBox Der zeichengenaue lange Pfadname der Datei `n%Pfadangabe%`n ist:`n%LangerPfad%
}</pre>
    </article>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>