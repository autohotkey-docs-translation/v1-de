<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Send - Syntax &amp; Verwendung | AutoHotkey</title>
<meta name="description" content="Die Befehle Send, SendRaw, SendInput, SendPlay und SendEvent senden simulierte Tastendrücke und Mausklicks an das aktive Fenster." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>Send, SendRaw, SendInput, SendPlay, SendEvent</h1>

<p>Sendet simulierte Tastendrücke und Mausklicks an das <a href="WinActivate.htm">aktive</a> Fenster.</p>

<pre class="Syntax">
<span class="func">Send</span> Tasten
<span class="func">SendRaw</span> Tasten
<span class="func">SendInput</span> Tasten
<span class="func">SendPlay</span> Tasten
<span class="func">SendEvent</span> Tasten
</pre>

<h2>Parameter</h2>
<dl>

  <dt>Tasten</dt>
  <dd>
    <p>Eine Reihe von Tasten, die gesendet werden sollen. Das Komma vor dem ersten Parameter ist, wie bei anderen Befehlen auch, optional.</p>
    <p>Standardmäßig (also wenn weder SendRaw noch der <a href="#Raw">Raw-Modus</a> oder <a href="#Text">Text-Modus</a> verwendet wird) haben die Zeichen <code>^+!#{}</code> eine besondere Bedeutung. Die Zeichen <code>^+!#</code> repräsentieren die Modifikatortasten <kbd>Strg</kbd>, <kbd>Umschalt</kbd>, <kbd>Alt</kbd> und <kbd>Win</kbd>. Sie beeinflussen nur die direkt darauffolgende Taste. Um die entsprechende Modifikatortaste separat zu senden, umschließen Sie den Tastennamen mit geschweiften Klammern. Um eine Taste einfach nur zu drücken (gedrückt halten) oder loszulassen, muss nach dem Tastennamen das Wort "down" oder "up" erfolgen, wie unten gezeigt.</p>
    <style>
      #modifierkeys td:not(:last-child) {
        white-space: nowrap;
        text-align: center
      }
    </style>
    <table id="modifierkeys" class="info">
      <tr>
        <th>Symbol</th>
        <th>Taste</th>
        <th>Drücken</th>
        <th>Loslassen</th>
        <th>Beispiele</th>
      </tr>
      <tr>
        <td>^</td>
        <td>{Ctrl}</td>
        <td>{Ctrl down}</td>
        <td>{Ctrl up}</td>
        <td><code>Send ^{Home}</code> drückt <kbd>Strg</kbd>+<kbd>Pos1</kbd></td>
      </tr>
      <tr>
        <td>+</td>
        <td>{Shift}</td>
        <td>{Shift down}</td>
        <td>{Shift up}</td>
        <td><code>Send +abC</code> sendet den Text "AbC"<br>
          <code>Send !+a</code> drückt <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>A</kbd></td>
      </tr>
      <tr>
        <td>!</td>
        <td>{Alt}</td>
        <td>{Alt down}</td>
        <td>{Alt up}</td>
        <td><code>Send !a</code> drückt <kbd>Alt</kbd>+<kbd>A</kbd></td>
      </tr>
      <tr>
        <td>#</td>
        <td>{LWin}<br>{RWin}</td>
        <td>{LWin down}<br>{RWin down}</td>
        <td>{LWin up}<br>{RWin up}</td>
        <td><code>Send #e</code> hält die <kbd>Win</kbd>-Taste gedrückt und drückt dann die <kbd>E</kbd>-Taste</td>
      </tr>
    </table>
    <p class="note"><strong>Hinweis</strong>: Großbuchstaben werden durch Senden der <kbd>Umschalt</kbd>-Taste erzeugt, daher würde z. B. <code>A</code> in einigen Programmen eine andere Wirkung als <code>a</code> erzielen. Zum Beispiel würde <code>!A</code> <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>A</kbd> und <code>!a</code> <kbd>Alt</kbd>+<kbd>A</kbd> drücken. Im Zweifelsfall sollte man immer Kleinbuchstaben verwenden.</p>
    <p>Die Zeichen <code>{}</code> werden genutzt, um <a href="#keynames">Tastennamen und andere Optionen</a> zu umschließen, und um spezielle Zeichen als direkt geschriebenen Text zu senden. Zum Beispiel ist <code>{Tab}</code> die <kbd>Tab</kbd>-Taste und <code>{!}</code> ein direkt geschriebenes Ausrufezeichen.</p>
    <p><span class="ver">[v1.1.27+]:</span> Umschließt man einen reinen ASCII-Buchstaben (a-z oder A-Z) mit geschweiften Klammern, wird stattdessen sein entsprechender virtueller Tastencode gesendet, auch wenn das Zeichen im aktuellen Tastaturlayout nicht vorhanden ist. Das heißt, dass <code>Send a</code> den Buchstaben "a" erzeugen würde, während <code>Send {a}</code> je nach Tastaturlayout ein "a" erzeugt oder nicht. Einzelheiten finden Sie unter <a href="#AZ">Bemerkungen</a>.</p>
  </dd>

</dl>

<h2 id="Send_variants">Send-Varianten</h2>
<p><strong>Send:</strong> Standardmäßig ist Send synonym mit SendEvent; allerdings kann es via <a href="SendMode.htm">SendMode</a> synonym mit SendInput oder SendPlay gemacht werden.</p>
<p><strong>SendRaw:</strong> Ähnlich wie Send, außer dass alle Zeichen in <em>Tasten</em> als direkt geschriebener Text interpretiert und gesendet werden. Weitere Informationen finden Sie unter <a href="#Raw">Raw-Modus</a>.</p>
<p><strong id="SendInput">SendInput</strong> und <strong id="SendPlay">SendPlay</strong> <span class="ver">[v1.0.43+]:</span> SendInput und SendPlay verwenden die gleiche Syntax wie Send, allerdings sind sie in der Regel schneller und zuverlässiger. Darüber hinaus puffern diese Modi alle physischen Aktivitäten via Tastatur oder Maus während des Sendens, um zu verhindern, dass die Tastendrücke des Benutzers mit solchen, die gesendet werden, vermischt werden. Verwende <a href="SendMode.htm">SendMode</a>, um Send zum Synonym für SendInput oder SendPlay zu machen. Um mehr Details über jeden Modus zu erfahren, siehe <a href="#SendInputDetail">SendInput</a> und <a href="#SendPlayDetail">SendPlay</a>.</p>
<p id="SendEvent"><strong>SendEvent</strong> <span class="ver">[v1.0.43+]:</span> SendEvent verwendet zum Senden von Tastendrücken die gleiche Methode wie der <em>Send</em>-Befehl vor Version 1.0.43. Die Sendegeschwindigkeit von Tastendrücken wird mit <a href="SetKeyDelay.htm">SetKeyDelay</a> bestimmt.</p>

<h2 id="Special_modes">Spezielle Modi</h2>
<p>Die folgenden Modi beeinflussen die Interpretation der Zeichen in <em>Tasten</em> oder das Verhalten von tastensendenden Befehlen wie Send, SendInput, SendPlay, SendEvent und <a href="ControlSend.htm">ControlSend</a>. Diese Modi müssen in Form von <code>{x}</code> in <em>Tasten</em> angegeben werden, wobei x entweder Raw, Text oder Blind ist. Zum Beispiel <code>{Raw}</code>.</p>

<h3 id="Raw">Raw-Modus</h3>
<p id="SendRaw">Der Raw-Modus kann entweder mit <code>{Raw}</code>, SendRaw oder <a href="ControlSend.htm">ControlSendRaw</a> aktiviert werden. Dieser bewirkt, dass alle nachfolgenden Zeichen, einschließlich <code>^+!#{}</code>, als direkt geschriebener Text interpretiert werden, anstatt z. B. <code>{Enter}</code> in <kbd>Enter</kbd>, <code>^c</code> in <kbd>Strg</kbd>+<kbd>C</kbd> usw. zu übersetzen. <code>Send {Raw}{Tab}</code> und <code>SendRaw {Tab}</code> beispielsweise senden <code>{Tab}</code> anstelle eines <kbd>Tab</kbd>-Tastendrucks.</p>
<p>Der Raw-Modus hat keinen Einfluss auf die Interpretation von <a href="_EscapeChar.htm">Escapesequenzen</a>, <a href="../Variables.htm#retrieving">Variablenreferenzen</a> und <a href="../Variables.htm#Expressions">Ausdrücke</a>. <code>SendRaw, ``100`%</code> beispielsweise sendet die Zeichenkette <code class="no-highlight">`100%</code>. Verwendet man <a href="ControlSend.htm">ControlSend</a>, müssen direkt geschriebene Kommas zudem mit einem Escapezeichen versehen werden (<code>`,</code>).</p>

<h3 id="Text">Text-Modus <span class="ver">[v1.1.27+]</span></h3>
<p id="SendText">Der Text-Modus kann mit <code>{Text}</code> aktiviert werden. Dieser ähnelt dem Raw-Modus, außer dass kein Versuch unternommen wird, Zeichen (außer <code>`r</code>, <code>`n</code>, <code>`t</code> und <code>`b</code>) in Tastencodes umzuwandeln; stattdessen wird für alle übrigen Zeichen die <a href="#fallback">Fallback</a>-Methode angewandt. Dieser Modus verbessert die Zuverlässigkeit von SendEvent, SendInput und <a href="ControlSend.htm">ControlSend</a>, da die Zeichen wesentlich weniger vom korrekten Modifikatorstatus abhängig sind. Dieser Modus kann mit dem Blind-Modus kombiniert werden, um das Loslassen von Modifikatortasten zu vermeiden: <code>Send {Blind}{Text}Ihr Text</code>. In einigen Anwendungen müssen die Modifikatortasten jedoch losgelassen werden.</p>
<p><code>`n</code>, <code>`r</code> und <code>`r`n</code> werden in einen einzelnen <kbd>Enter</kbd>-Tastendruck umgewandelt, ganz im Gegensatz zum Standardverhalten und Raw-Modus, die <code>`r`n</code> in zwei <kbd>Enter</kbd>-Tastendrücke übersetzen. <code>`t</code> wird in <kbd>Tab</kbd> und <code>`b</code> in <kbd>Backspace</kbd> umgewandelt, alle anderen Zeichen werden ohne Umwandlung gesendet.</p>
<p><span class="ver">[v1.1.29+]:</span> Genau wie der Blind-Modus wird der Text-Modus zum einen <a href="SetStoreCapslockMode.htm">SetStoreCapsLockMode</a> ignorieren (das heißt, dass der Status der <kbd>Feststell</kbd>-Taste nicht geändert wird) und zum anderen nicht darauf warten, <a href="../Hotkeys.htm#win-l">dass die <kbd>Win</kbd>-Taste losgelassen wird</a>. Grund dafür ist, dass der Text-Modus in der Regel nicht vom Status der <kbd>Feststell</kbd>-Taste abhängig ist und nicht den systeminternen <kbd>Win</kbd>+<kbd>L</kbd>-Hotkey auslösen kann. Dies gilt jedoch nur, wenn <em>Tasten</em> mit <code>{Text}</code> oder <code>{Blind}{Text}</code> beginnt.</p>

<h3 id="Blind">Blind-Modus</h3>
<p id="blind">Der Blind-Modus kann mit <code>{Blind}</code> aktiviert werden. Dieser bewirkt, dass das Skript mehr Kontrolle erhält, indem eine Reihe von Dingen deaktiviert werden, die normalerweise automatisch vorgenommen werden, damit die Dinge wie erwartet funktionieren. <code>{Blind}</code> muss das erste Element in der Zeichenkette sein, um den Blind-Modus zu aktivieren. Er hat folgende Auswirkungen:</p>
<ul>
  <li>Der Blind-Modus verhindert das Loslassen von <kbd>Alt</kbd>/<kbd>Strg</kbd>/<kbd>Umschalt</kbd>/<kbd>Win</kbd>, wenn sie zu Beginn im gedrückten Zustand waren. Zum Beispiel würde der Hotkey <code>+s::Send {Blind}abc</code> ABC statt abc senden, weil der Benutzer die <kbd>Umschalt</kbd>-Taste gedrückt hält.</li>
  <li>Modifikatortasten werden unterschiedlich wiederhergestellt, damit ein Send die Modifikatoren eines Hotkeys ausschalten kann, auch dann, wenn der Benutzer sie immer noch physisch gedrückt hält. <code>^space::Send {Ctrl up}</code> beispielsweise drückt die <kbd>Strg</kbd>-Taste wieder nach unten, wenn der Benutzer die <kbd>Strg</kbd>-Taste immer noch physisch gedrückt hält, während <code>^space::Send {Blind}{Ctrl up}</code> der <kbd>Strg</kbd>-Taste erlaubt, logisch oben zu sein, obwohl sie physisch nach unten gedrückt ist.</li>
  <li><a href="SetStoreCapslockMode.htm">SetStoreCapslockMode</a> wird ignoriert; das heißt, dass der Status der <kbd>Feststell</kbd>-Taste nicht geändert wird.</li>
  <li><a href="_MenuMaskKey.htm">Menü-Maskierung</a> ist deaktiviert. Das heißt, dass Send die zusätzlichen Tastendrücke weglässt, die sonst gesendet würden, um Folgendes zu verhindern: 1) Öffnen des Startmenüs bei <kbd>Win</kbd>-Tastendrücke (LWin/RWin); 2) Aktivierung der Menüleiste bei <kbd>Alt</kbd>-Tastendrücke. Der Blind-Modus verhindert jedoch nicht die Maskierung, die vom Tastatur-Hook nach Aktivierung einer Hook-Taste durchgeführt wird.</li>
  <li>Send wartet nicht auf das Loslassen der <kbd>Win</kbd>-Taste, auch wenn der Text einen <kbd>L</kbd>-Tastendruck enthält. Dies geschieht normalerweise, um zu verhindern, dass Send den System-Hotkey "Arbeitsplatz sperren" (<kbd>Win</kbd>+<kbd>L</kbd>) auslöst. Weitere Informationen finden Sie unter <a href="../Hotkeys.htm#win-l">Hotkeys</a>.</li>
</ul>
<p>Der Blind-Modus wird beim <a href="../misc/Remap.htm">Neubelegen einer Taste</a> automatisch verwendet. Zum Beispiel würde die Neubelegung <code>a::b</code> Folgendes erzeugen: 1) "b" wenn man "a" eingibt; 2) großes "B" wenn man ein großes "A" eingibt; und 3) <kbd>Strg</kbd>+<kbd>B</kbd> wenn man <kbd>Strg</kbd>+<kbd>A</kbd> eingibt.</p>
<p>SendRaw oder <a href="ControlSend.htm">ControlSendRaw</a> unterstützen kein <code>{Blind}</code>; verwenden Sie stattdessen <code>{Blind}{Raw}</code>.</p>
<p>Der Blind-Modus wird nicht vollständig von <a href="#SendPlayDetail">SendPlay</a> unterstützt, besonders in Bezug auf die Modifikatortasten (<kbd>Strg</kbd>, <kbd>Alt</kbd>, <kbd>Umschalt</kbd> und <kbd>Win</kbd>).</p>

<h2 id="keynames">Tastennamen</h2>
<p>Die folgende Tabelle listet alle speziellen Tasten auf, die gesendet werden können (jeder Tastenname muss mit geschweiften Klammern umschlossen werden):</p>
<table class="info">
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{F1} - {F24}</td>
    <td>Funktionstasten. Zum Beispiel: {F12} ist die <kbd>F12</kbd>-Taste.</td>
  </tr>
  <tr>
    <td>{!}</td>
    <td>!</td>
  </tr>
  <tr>
    <td>{#}</td>
    <td>#</td>
  </tr>
  <tr>
    <td>{+}</td>
    <td>+</td>
  </tr>
  <tr>
    <td>{^}</td>
    <td>^</td>
  </tr>
  <tr>
    <td>{{}</td>
    <td>{</td>
  </tr>
  <tr>
    <td>{}}</td>
    <td>}</td>
  </tr>
  <tr>
    <td>{Enter}</td>
    <td><kbd>Enter</kbd>-Taste im Hauptblock</td>
  </tr>
  <tr>
    <td>{Escape} oder {Esc}</td>
    <td><kbd>Esc</kbd></td>
  </tr>
  <tr>
    <td>{Space}</td>
    <td><kbd>Leer</kbd> (nur für Leerzeichen notwendig, die am Anfang oder Ende der Zeichenkette vorkommen - Leerzeichen in der Mitte können direkt geschrieben sein)</td>
  </tr>
  <tr>
    <td>{Tab}</td>
    <td><kbd>Tab</kbd></td>
  </tr>
  <tr>
    <td>{Backspace} oder {BS}</td>
    <td><kbd>Backspace</kbd></td>
  </tr>
  <tr>
    <td>{Delete} oder {Del}</td>
    <td><kbd>Entf</kbd></td>
  </tr>
  <tr>
    <td>{Insert} oder {Ins}</td>
    <td><kbd>Einfg</kbd></td>
  </tr>
  <tr>
    <td>{Up}</td>
    <td><kbd>↑</kbd> (Nach-Oben-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Down}</td>
    <td><kbd>↓</kbd> (Nach-Unten-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Left}</td>
    <td><kbd>←</kbd> (Nach-Links-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Right}</td>
    <td><kbd>→</kbd> (Nach-Rechts-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Home}</td>
    <td><kbd>Pos1</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <td>{End}</td>
    <td><kbd>Ende</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <td>{PgUp}</td>
    <td><kbd>Bild↑</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <td>{PgDn}</td>
    <td><kbd>Bild↓</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{CapsLock}</td>
    <td><kbd>Feststell</kbd> (in Win 2k/XP ist <a href="SetNumScrollCapsLockState.htm">SetCapsLockState</a> zuverlässiger). Das Senden von {CapsLock} benötigt möglicherweise vorher <code><a href="SetStoreCapslockMode.htm">SetStoreCapsLockMode</a> Off</code>.</td>
  </tr>
  <tr>
    <td>{ScrollLock}</td>
    <td><kbd>Rollen</kbd> (siehe auch: <a href="SetNumScrollCapsLockState.htm">SetScrollLockState</a>)</td>
  </tr>
  <tr>
    <td>{NumLock}</td>
    <td><kbd>Num</kbd> (siehe auch: <a href="SetNumScrollCapsLockState.htm">SetNumLockState</a>)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Control} oder {Ctrl}</td>
    <td><kbd>Strg</kbd> (technische Info: sendet die neutrale virtuelle Taste, aber den linken Scancode)</td>
  </tr>
  <tr>
    <td>{LControl} oder {LCtrl}</td>
    <td>Linke <kbd>Strg</kbd>-Taste (technische Info: sendet nicht die neutrale, sondern die linke virtuelle Taste)</td>
  </tr>
  <tr>
    <td>{RControl} oder {RCtrl}</td>
    <td>Rechte <kbd>Strg</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{Control down} oder {Ctrl down}</td>
    <td>Hält die <kbd>Strg</kbd>-Taste gedrückt, bis {Ctrl up} gesendet wird. Um stattdessen die linke oder rechte Taste gedrückt zu halten, verwenden Sie {RCtrl down} und {RCtrl up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Alt}</td>
    <td><kbd>Alt</kbd> (technische Info: sendet die neutrale virtuelle Taste, aber den linken Scancode)</td>
  </tr>
  <tr>
    <td>{LAlt}</td>
    <td>Linke <kbd>Alt</kbd>-Taste (technische Info: sendet nicht die neutrale, sondern die linke virtuelle Taste)</td>
  </tr>
  <tr>
    <td>{RAlt}</td>
    <td>Rechte <kbd>Alt</kbd>-Taste (oder <kbd>AltGr</kbd>, abhängig von der Tastaturbelegung)</td>
  </tr>
  <tr>
    <td>{Alt down}</td>
    <td>Hält die <kbd>Alt</kbd>-Taste gedrückt, bis {Alt up} gesendet wird. Um stattdessen die linke oder rechte Taste gedrückt zu halten, verwenden Sie {RAlt down} und {RAlt up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Shift}</td>
    <td><kbd>Umschalt</kbd> (technische Info: sendet die neutrale virtuelle Taste, aber den linken Scancode)</td>
  </tr>
  <tr>
    <td>{LShift}</td>
    <td>Linke <kbd>Umschalt</kbd>-Taste (technische Info: sendet nicht die neutrale, sondern die linke virtuelle Taste)</td>
  </tr>
  <tr>
    <td>{RShift}</td>
    <td>Rechte <kbd>Umschalt</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{Shift down}</td>
    <td>Hält die <kbd>Umschalt</kbd>-Taste gedrückt, bis {Shift up} gesendet wird. Um stattdessen die linke oder rechte Taste gedrückt zu halten, verwenden Sie {RShift down} und {RShift up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{LWin}</td>
    <td>Linke <kbd>Win</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{RWin}</td>
    <td>Rechte <kbd>Win</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{LWin down}</td>
    <td>Hält die linke <kbd>Win</kbd>-Taste gedrückt, bis {LWin up} gesendet wird</td>
  </tr>
  <tr>
    <td>{RWin down}</td>
    <td>Hält die rechte <kbd>Win</kbd>-Taste gedrückt, bis {RWin up} gesendet wird</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{AppsKey}</td>
    <td><kbd>Menü</kbd>-Taste (öffnet das Rechtsklick- oder Kontextmenü)</td>
  </tr>
  <tr>
    <td>{Sleep}</td>
    <td><kbd>Sleep</kbd>-Taste.</td>
  </tr>
  <tr id="asc">
    <td>{ASC nnnnn}</td>
    <td><p>Sendet eine <kbd>Alt</kbd>+nnnnn-Tastenkombination per Ziffernblock, um Sonderzeichen zu erzeugen, die auf der Tastatur normalerweise nicht vorhanden sind. Um ASCII-Zeichen zu generieren, geben Sie eine Nummer zwischen 1 und 255 an. Um ANSI-Zeichen zu generieren (Standard in den meisten Sprachen), geben Sie zuerst eine 0 und danach eine Nummer zwischen 128 und 255 an, zum Beispiel {Asc 0133}.</p>
    <p>Um Unicode-Zeichen zu generieren, geben Sie eine Nummer zwischen 256 und 65535 an (ohne 0 davor). Allerdings wird das nicht von jeder Anwendung unterstützt. Alternativen dazu finden Sie im nächsten Abschnitt.</p></td>
  </tr>
  <tr id="Unicode">
    <td>{U+nnnn}</td>
    <td><p id="sendu"><span class="ver">[AHK_L 24+]:</span> Sendet ein Unicode-Zeichen - <em>nnnn</em> ist der hexadezimale Wert des Zeichens ohne 0x-Präfix. Diese Methode ist in den Unicode-Versionen von AutoHotkey üblicherweise nicht notwendig, weil ihr Send und ControlSend von sich aus Unicode-Text unterstützen.</p>
    <p><a href="https://msdn.microsoft.com/de-de/library/ms646310">SendInput()</a> oder <a href="https://msdn.microsoft.com/de-de/library/ms646276">WM_CHAR</a> wird zum Senden des Zeichens verwendet, außerdem wird der aktuelle Send-Modus ignoriert. Zeichen, die auf diese Weise gesendet werden, lösen in der Regel keine Tastenkürzel oder Hotkeys aus.</p></td>
  </tr>
  <tr id="vk">
    <td><p>{vkXX}<br>
      
      {scYYY}<br>
    
    {vkXXscYYY}</p></td>
    <td><p>Sendet einen Tastendruck, der die virtuelle Taste XX und den Scancode YYY hat. Zum Beispiel: <code>Send {vkFFsc159}</code>. Lässt man den sc- oder vk-Bereich weg, wird der am besten geeignete Wert an seiner Stelle gesendet.</p>
      <p>Die Werte für XX und YYY sind hexadezimal und können üblicherweise über den Menüpunkt <a href="KeyHistory.htm">View-&gt; Key history</a> im Hauptfenster abgerufen werden. Siehe auch: <a href="../KeyList.htm#SpecialKeys">Sondertasten</a></p>
      <p class="warning"><strong>Warnung:</strong> Eine solche Kombination von vk und sc ist nur mit Send gültig. Vor <span class="ver">[v1.1.27]</span> waren Hotkeys erlaubt, aber alle nicht-hexadezimalen Zeichen nach XX wurden ignoriert.</p></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Numpad0} - {Numpad9}</td>
    <td>Ziffernblocktasten (wenn <kbd>Num</kbd> eingeschaltet ist). Zum Beispiel: {Numpad5} ist <kbd>5</kbd>.</td>
  </tr>
  <tr>
    <td>{NumpadDot}</td>
    <td><kbd>,</kbd> (Komma-Taste im Ziffernblock) (wenn <kbd>Num</kbd> eingeschaltet ist)</td>
  </tr>
  <tr>
    <td>{NumpadEnter}</td>
    <td><kbd>Enter</kbd>-Taste im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadMult}</td>
    <td><kbd>*</kbd> (Multiplikationstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <td>{NumpadDiv}</td>
    <td><kbd>/</kbd> (Divisionstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <td>{NumpadAdd}</td>
    <td><kbd>+</kbd> (Additionstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <td>{NumpadSub}</td>
    <td><kbd>-</kbd> (Subtraktionstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{NumpadDel}</td>
    <td><kbd>Entf</kbd>-Taste im Ziffernblock (diese und die nachfolgenden Ziffernblocktasten sind nur verwendbar, wenn <kbd>Num</kbd> ausgeschaltet ist)</td>
  </tr>
  <tr>
    <td>{NumpadIns}</td>
    <td><kbd>Einfg</kbd>-Taste im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadClear}</td>
    <td>Funktionslose Taste im Ziffernblock (üblicherweise die Taste '5', wenn <kbd>Num</kbd> ausgeschaltet ist).</td>
  </tr>
  <tr>
    <td>{NumpadUp}</td>
    <td><kbd>↑</kbd> (Nach-Oben-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadDown}</td>
    <td><kbd>↓</kbd> (Nach-Unten-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadLeft}</td>
    <td><kbd>←</kbd> (Nach-Links-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadRight}</td>
    <td><kbd>→</kbd> (Nach-Rechts-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadHome}</td>
    <td><kbd>Pos1</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadEnd}</td>
    <td><kbd>Ende</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadPgUp}</td>
    <td><kbd>Bild↑</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadPgDn}</td>
    <td><kbd>Bild↓</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Browser_Back}</td>
    <td>Browser "Zurück"</td>
  </tr>
  <tr>
    <td>{Browser_Forward}</td>
    <td>Browser "Vorwärts"</td>
  </tr>
  <tr>
    <td>{Browser_Refresh}</td>
    <td>Browser "Aktualisieren"</td>
  </tr>
  <tr>
    <td>{Browser_Stop}</td>
    <td>Browser "Stopp"</td>
  </tr>
  <tr>
    <td>{Browser_Search}</td>
    <td>Browser "Suchen"</td>
  </tr>
  <tr>
    <td>{Browser_Favorites}</td>
    <td>Browser "Favoriten"</td>
  </tr>
  <tr>
    <td>{Browser_Home}</td>
    <td>Startet den Browser und öffnet die Startseite</td>
  </tr>
  <tr>
    <td>{Volume_Mute}</td>
    <td>Master-Lautstärke stummschalten bzw. Stummschaltung aufheben. Normalerweise das gleiche wie <code><a href="SoundSet.htm">SoundSet</a>, +1, , mute</code>.</td>
  </tr>
  <tr>
    <td>{Volume_Down}</td>
    <td>Master-Lautstärke leiser machen. Normalerweise das gleiche wie <code><a href="SoundSet.htm">SoundSet</a>, -5</code>.</td>
  </tr>
  <tr>
    <td>{Volume_Up}</td>
    <td>Master-Lautstärke lauter machen. Normalerweise das gleiche wie <code><a href="SoundSet.htm">SoundSet</a>, +5</code>.</td>
  </tr>
  <tr>
    <td>{Media_Next}</td>
    <td>Media Player "Nächster Track"</td>
  </tr>
  <tr>
    <td>{Media_Prev}</td>
    <td>Media Player "Vorheriger Track"</td>
  </tr>
  <tr>
    <td>{Media_Stop}</td>
    <td>Media Player "Stopp"</td>
  </tr>
  <tr>
    <td>{Media_Play_Pause}</td>
    <td>Media Player "Wiedergabe/Anhalten"</td>
  </tr>
  <tr>
    <td>{Launch_Mail}</td>
    <td>E-Mail-Programm öffnen</td>
  </tr>
  <tr>
    <td>{Launch_Media}</td>
    <td>Media Player öffnen</td>
  </tr>
  <tr>
    <td>{Launch_App1}</td>
    <td>Benutzerdefiniertes Programm 1 öffnen</td>
  </tr>
  <tr>
    <td>{Launch_App2}</td>
    <td>Benutzerdefiniertes Programm 2 öffnen</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{PrintScreen}</td>
    <td><kbd>PrintScreen</kbd></td>
  </tr>
  <tr>
    <td>{CtrlBreak}</td>
    <td><kbd>Strg</kbd>+<kbd>Pause</kbd></td>
  </tr>
  <tr>
    <td>{Pause}</td>
    <td><kbd>Pause</kbd></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr id="Click">
    <td>{Click [Optionen]}<br>
    <span class="ver">[v1.0.43+]</span></td>
    <td>Sendet einen Mausklick, das die gleichen Optionen verwendet wie die vom <a href="Click.htm">Click-Befehl</a>. Zum Beispiel würde <code>Send {Click}</code> die linke Maustaste einmal bei der aktuellen Mausposition klicken, und <code>Send {Click 100, 200}</code> würde auf den Koordinaten 100, 200 klicken (basierend auf <a href="CoordMode.htm">CoordMode</a>). Um den Mauszeiger ohne Klicken zu verschieben, geben Sie nach den Koordinaten eine 0 an; zum Beispiel: <code>Send {Click 100, 200, 0}</code>. Die Verzögerung zwischen den Mausklicks wird durch <a href="SetMouseDelay.htm">SetMouseDelay</a> bestimmt (nicht <a href="SetKeyDelay.htm">SetKeyDelay</a>).</td>
  </tr>
  <tr>
    <td>{WheelDown}, {WheelUp}, {WheelLeft}, {WheelRight}, {LButton}, {RButton}, {MButton}, {XButton1}, {XButton2}</td>
    <td>
      <p>Sendet ein Maustastenereignis auf die aktuelle Mausposition (um die Position und weitere Optionen zu kontrollieren, siehe <a href="Click.htm">{Click}</a>). Die Verzögerung zwischen den Mausklicks wird durch <a href="SetMouseDelay.htm">SetMouseDelay</a> bestimmt. WheelLeft/Right benötigen <span class="ver">[v1.0.48+]</span>, allerdings funktionieren sie nicht in Betriebssystemen älter als Windows Vista.</p>
      <p>LButton und RButton beziehen sich auf die "physische" linke bzw. rechte Maustaste, wenn sie mit Send verwendet werden, aber auf die "logische" linke bzw. rechte Maustaste, wenn sie mit Hotkeys verwendet werden. Mit anderen Worten, wenn der Benutzer die Maustasten via Systemsteuerung vertauscht hat, wird <code>{LButton}</code> einen logischen Rechtsklick ausführen, während ein physischer Linksklick den Hotkey <code>RButton::</code> auslösen wird. Gleiches gilt für <code>{RButton}</code> und <code>LButton::</code>. Mit <a href="Click.htm">{Click}</a> kann immer ein logischer Klick ausgeführt werden.</p>
    </td>
  </tr>
  <tr>
    <td>{Blind}</td>
    <td>Aktiviert den <a href="#blind">Blind-Modus</a>. Dieser bewirkt, dass das Skript mehr Kontrolle erhält, indem eine Reihe von Dingen deaktiviert werden, die normalerweise automatisch vorgenommen werden, damit die Dinge wie erwartet funktionieren. Die Zeichenkette <code>{Blind}</code> muss am Anfang der Zeichenkette stehen.</td>
  </tr>
  <tr>
    <td>{Raw}<br>
    <span class="ver">[v1.0.43+]</span></td>
    <td>Aktiviert den <a href="#SendRaw">Raw-Modus</a>. Dieser bewirkt, dass die folgenden Zeichen als direkt geschriebener Text interpretiert werden: <code>^+!#{}</code>. <code>{Raw}</code> muss nicht am Anfang der Zeichenkette stehen. Einmal angegeben bleibt der Modus für den Rest der Zeichenkette aktiv.</td>
  </tr>
  <tr>
    <td>{Text}<br>
    <span class="ver">[v1.1.27+]</span></td>
    <td>Aktiviert den <a href="#SendText">Text-Modus</a>. Dieser sendet eine Kette von Zeichen anstelle von Tastendrücke. Genau wie der Raw-Modus bewirkt der Text-Modus, dass die folgenden Zeichen als direkt geschriebener Text interpretiert werden: <code>^+!#{}</code>. <code>{Text}</code> muss nicht am Anfang der Zeichenkette stehen. Einmal angegeben bleibt der Modus für den Rest der Zeichenkette aktiv.</td>
  </tr>
</table>

<h2>Mehrfaches oder haltendes Drücken einer Taste</h2>
<p id="repeat"><strong>Mehrfaches Drücken</strong>: Umschließen Sie den Namen der Taste und die Anzahl an Wiederholungen mit geschweiften Klammern. Zum Beispiel:</p>
<pre>Send {DEL 4}  <em>; Drückt viermal die ENTF-Taste.</em>
Send {S 30}   <em>; Sendet 30 große S-Zeichen.</em>
Send +{TAB 4}  <em>; Drückt viermal UMSCHALT+TAB.</em></pre>
<p id="Down"><strong>Halten oder Loslassen</strong>: Umschließen Sie den Namen der Taste und das Wort <strong>Down</strong> oder <strong>Up</strong> mit geschweiften Klammern. Zum Beispiel:</p>
<pre>Send {b down}{b up}
Send {TAB down}{TAB up}
Send {Up down}  <em>; Drückt die NACH-OBEN-Taste nach unten.</em>
Sleep 1000  <em>; Hält sie eine Sekunde lang gedrückt.</em>
Send {Up up}  <em>; Lässt die NACH-OBEN-Taste los.</em></pre>
<p>Wenn eine Taste mit der Methode oben gedrückt gehalten wird, erfolgt keine Auto-Wiederholung, wie es beim physischen Gedrückthalten geschehen würde (Auto-Wiederholung ist nämlich ein Treiber/Hardware-Feature). Allerdings kann mit einer <a href="Loop.htm">Schleife</a> das Auto-Wiederholen künstlich erzeugt werden. Das folgende Beispiel sendet 20 Tabulator-Tastendrücke:</p>
<pre>Loop 20
{
    Send {Tab down}  <em>; Auto-Wiederholen besteht aus fortlaufenden Down-Ereignissen (ohne Up-Ereignisse).</em>
    Sleep 30  <em>; Die Anzahl der Millisekunden zwischen den Tastendrücken (oder alternativ <a href="SetKeyDelay.htm">SetKeyDelay</a>).</em>
}
Send {Tab up}  <em>; Lässt die Taste los.</em></pre>
<p>Standardmäßig lässt Send eine Modifikatortaste (<kbd>Strg</kbd>/<kbd>Umschalt</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd>) nicht automatisch los, wenn diese Modifikatortaste via Send "nach unten gedrückt" wurde. <code>Send a</code> beispielsweise verhält sich eventuell ähnlich wie <code>Send <a href="#blind">{Blind}</a>{Ctrl up}a{Ctrl down}</code>, wenn der Benutzer <kbd>Strg</kbd> physisch gedrückt hält, während <code>Send {Ctrl Down}</code> gefolgt von <code>Send a</code> einen <kbd>Strg</kbd>+<kbd>A</kbd>-Tastendruck erzeugen würde. <em>DownTemp</em> und <em>DownR</em> können genutzt werden, um dieses Verhalten zu überschreiben. <em>DownTemp</em> und <em>DownR</em> haben die gleiche Wirkung wie <em>Down</em>, außer für die Modifikatortasten (<kbd>Strg</kbd>/<kbd>Umschalt</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd>).</p>
<p id="DownTemp"><strong>DownTemp</strong> benachrichtigt nachfolgende Send-Befehle, dass die Taste nicht permanent im gedrückten Zustand sein muss und jederzeit losgelassen werden könnte, wenn ein Tastendruck dies erfordert. <code>Send {Control DownTemp}</code>, später gefolgt von <code>Send a</code>, würde zum Beispiel einen normalen <kbd>A</kbd>-Tastendruck erzeugen, nicht einen <kbd>Strg</kbd>+<kbd>A</kbd>-Tastendruck. Jede Verwendung von Send kann dazu führen, dass der Modifikator permanent losgelassen wird, daher ist <em>DownTemp</em> nicht gerade die ideale Wahl, um Modifikatortasten <a href="../misc/Remap.htm">neuzubelegen</a>.</p>
<p id="DownR"><span class="ver">[v1.1.27+]:</span> <strong>DownR</strong> (das "R" bedeutet <a href="../misc/Remap.htm">Remapping</a> bzw. Neubelegen, was dessen Hauptzweck darstellt) teilt nachfolgenden Sendevorgängen mit, dass die Taste, wenn sie automatisch losgelassen wird, nach Beendigung des Sendevorgangs erneut gedrückt werden sollte. Zum Beispiel würde <code>Send {Control DownR}</code> und dann <code>Send a</code> einen normalen <kbd>A</kbd>-Tastendruck erzeugen, nicht einen <kbd>Strg</kbd>+<kbd>A</kbd>-Tastendruck, aber die <kbd>Strg</kbd>-Taste im gedrückten Zustand lassen, um sie für Tastaturkürzel zu verwenden. Mit anderen Worten hat <em>DownR</em> denselben Effekt wie, als würde man die Taste physisch drücken.</p>
<p>Wenn ein Zeichen nicht zu einer virtuellen Taste im aktuellen Tastaturlayout gehört, kann es nicht "gedrückt" oder "losgelassen" werden. <code>Send {µ up}</code> beispielsweise hat keinen Einfluss auf die meisten Layouts, während <code>Send {µ down}</code> das gleiche wie <code>Send µ</code> ist.</p>

<h2 id="Remarks">Allgemeine Bemerkungen</h2>
<p id="characters"><strong>Zeichen vs. Tasten</strong>: Standardmäßig werden Zeichen, die gesendet werden sollen, zuerst in Tastendrücke umgewandelt. Wenn diese Umwandlung nicht möglich ist (also wenn das aktuelle Tastaturlayout keine Taste oder Tastenkombination enthält, die dieses Zeichen erzeugen würde), wird das Zeichen mittels einer der folgenden Fallback-Methoden gesendet:</p>
<ul id="fallback">
  <li>SendEvent und SendInput nutzen <a href="http://msdn.microsoft.com/de-de/library/ms646310">SendInput()</a> mit dem <a href="https://msdn.microsoft.com/de-de/library/ms646271#keyeventf_unicode">KEYEVENTF_UNICODE-Flag</a>. <span class="ver">[v1.1.27+]:</span> ANSI-Versionen von AutoHotkey wandeln das Zeichen in Unicode um, bevor es gesendet wird. Vor v1.1.27 griffen die ANSI-Versionen auf die Alt+nnnnn-Methode zurück.</li>
  <li>SendPlay nutzt die <a href="#asc">Alt+nnnnn</a>-Methode, die nur Unicode erzeugt, wenn es von der Zielanwendung unterstützt wird.</li>
  <li>Controlsend sendet eine <a href="https://msdn.microsoft.com/de-de/library/ms646276">WM_CHAR</a>-Meldung.</li>
</ul>
<p class="warning"><strong>Hinweis:</strong> Zeichen, die mit einer der oben genannten Methoden gesendet werden, lösen in der Regel keine Tastenkürzel oder Hotkeys aus.</p>
<p id="AZ"><span class="ver">[v1.1.27+]:</span> Jedes Zeichen im Bereich von <strong>a-z</strong> oder <strong>A-Z</strong> (reine ASCII-Buchstaben), das im aktuellen Tastaturlayout nicht vorhanden ist, kann eventuell als Zeichen oder als entsprechender virtueller Tastencode (vk41-vk5A) gesendet werden:</p>
<ul>
  <li>Wenn ein reiner Buchstabe (also ohne Modifikatoren oder geschweifte Klammern) gesendet wird, oder wenn der <a href="#Raw">Raw-Modus</a> aktiv ist, wird er als Zeichen gesendet. <code>Send {Raw}Regards</code> beispielsweise sendet den erwarteten Text, obwohl das Drücken der <kbd>R</kbd>-Taste (vk52) ein anderes Zeichen erzeugen könnte (z. B. <kbd>К</kbd> im russischen Layout). <code>{Raw}</code> kann in diesem Fall weggelassen werden, es sei denn, eine Modifikatortaste wurde durch ein vorheriges Send aktiviert.</li>
  <li>Wenn eine oder mehrere Modifikatortasten durch den Send-Befehl aktiviert wurden, oder wenn der Buchstabe in geschweiften Klammern gesetzt ist, werden sie als Tastencode gesendet (mit <kbd>Umschalt</kbd> modifiziert, wenn der Buchstabe großgeschrieben ist). Dadurch kann das Skript auf einfache Weise die vordefinierten Tastenkürzel aktivieren. <code>^c</code> und <code>{Ctrl down}c{Ctrl up}</code> beispielsweise aktivieren das Standard-Tastenkürzel  <kbd>Strg</kbd>+<kbd>C</kbd>, während <code>{c}</code> das gleiche wie <code>{vk43}</code> ist.</li>
</ul>
<p>Wenn der Buchstabe im aktuellen Tastaturlayout vorhanden ist, wird er immer als Tastencode gesendet, den das Layout mit diesem Buchstaben assoziiert (es sei denn, der <a href="#SendText">Text-Modus</a> wird genutzt, dann wird das Zeichen auf andere Weise gesendet). Das heißt, dass der obige Abschnitt nur für nicht-lateinische Layouts wie z. B. Russisch relevant ist.</p>
<p id="mask"><strong>Modifikatorstatus</strong>: Wenn mit Send der Status von <kbd>Win</kbd>- oder <kbd>Alt</kbd>-Modifikatortasten geändert werden muss (z. B. wenn der Benutzer eine dieser Tasten gedrückt hält), werden eventuell zusätzliche Tastendrücke (standardmäßig <kbd>Strg</kbd>) hinzugefügt, um zu verhindern, dass das Startmenü oder das Fenstermenü angezeigt wird. Weitere Informationen finden Sie unter <a href="_MenuMaskKey.htm">#MenuMaskKey</a>.</p>
<p><strong>BlockInput im Vergleich zu SendInput/SendPlay</strong>: Obwohl der <a href="BlockInput.htm">BlockInput</a>-Befehl genutzt werden kann, um zu verhindern, dass physische Eingaben des Benutzers die Ausführung der simulierten Tastendrücke stören, ist es oft besser, <a href="#SendInputDetail">SendInput</a> oder <a href="#SendPlayDetail">SendPlay</a> zu nutzen, damit Tastendrücke und Mausklicks nicht mehr unterbrochen werden können. SendInput/Play verhindert im Gegensatz zu BlockInput, dass die Eingaben des Benutzers während des Sendens verworfen werden; stattdessen werden solche Tastendrücke gepuffert und später gesendet.</p>
<p>Beim Senden vieler Tastendrücke kann ein <a href="../Scripts.htm#continuation">Fortsetzungsbereich</a> hilfreich sein, um die Übersichtlichkeit und Wartbarkeit des Skripts zu erhöhen.</p>
<p>Da das Betriebssystem das Simulieren von <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>Entf</kbd> nicht erlaubt, kann so etwas wie <code>Send ^!{Delete}</code> nicht funktionieren.</p>
<p><b>Send könnte nicht funktionieren</b> in Windows Vista oder höher, wenn das aktive Fenster mit administrativen Rechten läuft, und das Skript nicht. Das hängt mit dem Sicherheitsmechanismus "User Interface Privilege Isolation" (UIPI) zusammen.</p>

<h2 id="SendInputDetail">SendInput <span class="ver">[v1.0.43+]</span></h2>
<p>SendInput ist in der Regel die bevorzugte Methode, um Tastendrücke und Mausklicks zu senden, weil sie im Gegensatz zu den anderen Methoden bedeutend schneller und zuverlässiger ist. In den meisten Fällen wird eine Zeichenkette via SendInput nahezu verzögerungsfrei gesendet, sogar wenn es sich um sehr lange Zeichenketten handelt. Aufgrund dieser Schnelligkeit ist SendInput auch zuverlässiger, weil die Chance geringer ist, dass ein anderes Fenster unerwartet erscheint und die Tastendrücke abfängt. Die Zuverlässigkeit erhöht sich nochmals durch die Tatsache, dass die Eingaben des Benutzers während eines SendInput-Vorgangs bis zum Schluss zwischengespeichert werden.</p>
<p>Im Gegensatz zu den anderen Sendmethoden ist SendInput auf ca. 5000 Zeichen begrenzt (dieser Grenzwert variiert je nach Version des Betriebssystems und Leistungseinstellungen). Zeichen und Ereignisse oberhalb des Limits werden nicht gesendet.</p>
<p class="note"><strong>Hinweis</strong>: SendInput ignoriert SetKeyDelay, weil das Betriebssystem keine Verzögerung in diesem Modus unterstützt. Wenn SendInput allerdings aufgrund der unten genannten Bedingungen auf <a href="#SendEvent">SendEvent</a> zurückgreift, wird <code><a href="SetKeyDelay.htm">SetKeyDelay</a> -1, 0</code> verwendet (es sei denn, die Tastenverzögerung von SendEvent ist <code>-1, -1</code>, dann wird <code>-1, -1</code> verwendet). Wenn SendInput auf <a href="#SendPlayDetail">SendPlay</a> zurückgreift, wird die Tastenverzögerung von SendPlay verwendet.</p>
<p id="SendInputUnavail">Wenn ein Skript - <em>außer</em> das Skript, das SendInput ausführt - einen <a href="_InstallKeybdHook.htm">systemnahen Tastatur-Hook</a> installiert hat, wird SendInput automatisch auf <a href="#SendEvent">SendEvent</a> zurückgreifen (oder auf <a href="#SendPlayDetail">SendPlay</a>, wenn <code><a href="SendMode.htm">SendMode</a> InputThenPlay</code> wirksam ist). Dieses Verhalten ist notwendig, weil das Vorhandensein eines externen Hooks alle Vorteile von SendInput zunichtemachen würde, so dass es sowohl SendPlay als auch SendEvent unterlegen wäre. Da SendInput jedoch einen systemnahen Hook in Programmen außer <span class="ver">[AutoHotkey v1.0.43+]</span> nicht erkennen kann, wird es in solchen Fällen nicht auf einen anderen Modus zurückgreifen, wodurch es unzuverlässiger als SendPlay/Event werden würde.</p>
<p>Wenn SendInput einen Mausklick mithilfe von z. B. <a href="#Click">{Click}</a> sendet, während <code><a href="CoordMode.htm">CoordMode</a> Mouse, Relative</code> aktiv ist (die Standardeinstellung), wird jeder Klick relativ zum Fenster sein, das vor dem Senden aktiv war. Demzufolge, wenn SendInput absichtlich ein anderes Fenster aktiviert (z. B. mit ALT+TAB), werden die Koordinaten der nachfolgenden Klicks innerhalb des gleichen Befehls falsch sein, weil sie weiterhin relativ zum alten statt zum neuen Fenster sind.</p>

<h2 id="SendPlayDetail">SendPlay <span class="ver">[v1.0.43+]</span></h2>
<p class="warning"><strong>Warnung:</strong> SendPlay funktioniert möglicherweise überhaupt nicht, wenn UAC aktiviert ist, selbst wenn das Skript mit Administratorrechten läuft. Weitere Informationen finden Sie in der <a href="../FAQ.htm#uac">FAQ</a>.</p>
<p>Der größte Vorteil von SendPlay gegenüber den anderen Methoden ist die Fähigkeit, Tastendrücke und Mausklicks bei einer breiteren Auswahl von Videospielen erzeugen zu können. Zum Beispiel könnten <a href="../Hotstrings.htm#SendMode">Hotstrings</a> in einem Videospiel nur funktionieren, wenn sie die <a href="../Hotstrings.htm#SendMode">SendPlay-Option</a> haben.</p>
<p>Von den drei Send-Methoden ist SendPlay die ungewöhnlichste Methode, weil sie selbst keine Tastendrücke und Mausklicks simuliert. Stattdessen erstellt sie eine Reihe von Ereignissen (Meldungen), die direkt in das aktive Fenster einfließen (ähnlich wie <a href="ControlSend.htm">ControlSend</a>, aber auf niedrigerem Niveau). Demzufolge kann SendPlay keine Hotkeys oder Hotstrings auslösen.</p>
<p>Wie bei <a href="#SendInputDetail">SendInput</a> werden die Tastendrücke von SendPlay nicht mit den Eingaben des Benutzers vermischt. Wenn der Benutzer also während SendPlay etwas eingibt, werden solche Tastendrücke bis zum Schluss zwischengespeichert.</p>
<p>Zwar ist SendPlay deutlich langsamer als SendInput, aber schneller als der traditionelle <a href="#SendEvent">SendEvent</a>-Modus (selbst wenn <a href="SetKeyDelay.htm">Tastenverzögerung</a> auf -1 ist).</p>
<p>Die <kbd>Win</kbd>-Tasten (LWin und RWin) werden während SendPlay automatisch blockiert, wenn der <a href="_InstallKeybdHook.htm">Tastatur-Hook</a> installiert ist. Dadurch wird verhindert, dass das Startmenü angezeigt wird, wenn der Benutzer versehentlich eine <kbd>Win</kbd>-Taste während des Sendens drückt. Alle anderen Tasten außer LWin und RWin müssen nicht blockiert werden, weil das Betriebssystem sie automatisch hinauszögert, bis SendPlay durchgeführt wurde (via Pufferung).</p>
<p>SendPlay verwendet nicht die Standardeinstellungen von <a href="SetKeyDelay.htm">SetKeyDelay</a> und <a href="SetMouseDelay.htm">SetMouseDelay</a>. Stattdessen erfolgt überhaupt keine Verzögerung, was aber wie folgt geändert werden kann:</p>
<pre><a href="SetKeyDelay.htm">SetKeyDelay</a>, 0, 10, <strong>Play</strong>  <em>; Beachten Sie, dass sowohl 0 als auch -1 das gleiche sind im SendPlay-Modus.</em>
<a href="SetMouseDelay.htm">SetMouseDelay</a>, 10, <strong>Play</strong></pre>
<p>SendPlay kann <kbd>Feststell</kbd>, <kbd>Num</kbd> oder <kbd>Rollen</kbd> weder ein- noch ausschalten. SendPlay kann zudem den Status einer Taste, wie von <a href="GetKeyState.htm">GetKeyState</a> gesehen, nicht ändern, es sei denn, die Tastendrücke werden an eines der eigenen Fenster des Skripts gesendet. Selbst dann können Änderungen an den linken/rechten Modifikatortasten (z. B. RControl) nur über ihrem neutralen Gegenstück (z. B. Control) erkannt werden. Außerdem gelten für SendPlay noch weitere Einschränkungen, die auf der <a href="SendMode.htm#Play">SendMode-Seite</a> zu finden sind.</p>
<p>Im Gegensatz zu <a href="#SendInputDetail">SendInput</a> und <a href="#SendEvent">SendEvent</a> kann SendPlay von einem Benutzer unterbrochen werden, indem er <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>Entf</kbd> oder <kbd>Strg</kbd>+<kbd>Esc</kbd> drückt. Wenn dies geschieht, werden die restlichen Tastendrücke nicht gesendet, und danach das Skript fortgesetzt, als ob das SendPlay normal abgeschlossen wurde.</p>
<p>Obwohl SendPlay LWin- und RWin-Ereignisse senden kann, werden sie nicht ihre native Funktion durchführen, sondern direkt an das aktive Fenster gesendet. Um das zu umgehen, verwenden Sie <a href="#SendEvent">SendEvent</a>. Zum Beispiel würde <code>SendEvent #r</code> das Ausführen-Dialogfenster des Startmenüs anzeigen.</p>

<h2>Siehe auch</h2>
<p><a href="SendMode.htm">SendMode</a>, <a href="SetKeyDelay.htm">SetKeyDelay</a>, <a href="SetStoreCapslockMode.htm">SetStoreCapsLockMode</a>, <a href="_EscapeChar.htm">Escapesequenzen (z. B. `%)</a>, <a href="ControlSend.htm">ControlSend</a>, <a href="BlockInput.htm">BlockInput</a>, <a href="../Hotstrings.htm">Hotstrings</a>, <a href="WinActivate.htm">WinActivate</a></p>

<h2>Beispiele</h2>
<div class="ex" id="ExBasic">
<p><a href="#ExBasic">#1</a>: Grundlegende Verwendung</p>
<pre>Send Mit freundlichen Grüßen,{enter}Max Mustermann  <em>; Schreibt eine zweizeilige Signatur.</em>
Send !ds <em>; Öffnet das Dateimenü und wählt Speichern aus (ALT+D, gefolgt von S).</em>
Send {End}+{Left 4} <em>; Springt zum Ende des Textes und sendet viermal UMSCHALT+NACH-LINKS.</em>
<a href="#SendInputDetail">SendInput</a> {Raw}Eine lange Reihe von Rohzeichen, die mit der schnellsten Methode gesendet wurden. <em>; Siehe <a href="#Raw">{Raw}</a>, um mehr zu erfahren.</em></pre>
</div>

</body>
</html>
