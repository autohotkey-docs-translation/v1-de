<!DOCTYPE HTML>
<html>
<head>
<title>DllCall</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>DllCall()</h1>

<p>Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</p>

<pre class="Syntax">Ergebnis := DllCall("[DllDatei\]Funktion" [, Typ1, Arg1, Typ2, Arg2, "Cdecl Rückgabetyp"])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Ergebnis</dt>
  <dd><p>DllCall gibt den aktuellen Rückgabewert der Funktion zurück. Unterstützt die Funktion keinen Rückgabewert, übergibt sie einen undefinierten Integer-Wert. Wenn die Funktion durch einen <a href="#error">Fehler</a> nicht aufgerufen werden kann, ist der Rückgabewert leer (ein leerer String).</p></dd>

  <dt>[DllDatei\]Funktion</dt>
  <dd><p>Der Name einer DLL- oder EXE-Datei, gefolgt von einem umgekehrten Schrägstrich und dem Funktionsnamen. Zum Beispiel: <code>"MeineDLL\MeineFunktion"</code> (die Dateierweiterung ".dll" kann standardmäßig weggelassen werden). Solange kein absoluter Pfad angegeben ist, befindet sich die <em>DllDatei</em> im System- oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Pfad.</p>
      <p><em><a name="std"></a>DllDatei</em> kann weggelassen werden, wenn eine Funktion in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll aufgerufen wird. Zum Beispiel würde <code>"User32\IsWindowVisible"</code> das gleiche Ergebnis liefern wie <code>"IsWindowVisible"</code>.</p>
      <p>Wenn eine Funktion nicht über den angegebenen Namen gefunden werden kann, wird automatisch ein A (ANSI) oder W (Unicode) angefügt, abhängig davon, welche Version von AutoHotkey das Script ausführt. <code>"MessageBox"</code>  wäre in einer ANSI-Version das gleiche wie <code>"MessageBoxA"</code> und in einer Unicode-Version das gleiche wie <code>"MessageBoxW"</code>.</p>
      <p>Bei <em>wiederholenden</em> Aufrufen einer DLL-Datei kann die Performance erheblich verbessert werden, indem man sie <a href="#load">im Voraus lädt</a>.</p>
    <p>Seit v1.0.46.08 kann dieser Parameter auch ein reiner Integer sein, um die Adresse einer Funktion anzugeben, die aufgerufen werden soll. Quellen für solche Adressen sind <a href="#COM">COM</a> und <a href="RegisterCallback.htm">RegisterCallBack()</a>.</p></dd>

  <dt>Typ1, Arg1</dt>
  <dd><p>Jedes dieser Paare repräsentiert einen einzelnen Parameter, der an die Funktion übergeben werden soll. Die Anzahl an möglichen Paaren ist unbegrenzt. Bei <em>Typ</em> kann ein Typ aus der unteren <a href="#types">Typentabelle</a> angegeben werden. Bei <em>Arg</em> kann der Wert angegeben werden, der an die Funktion übergeben werden soll.</p></dd>

  <dt>Cdecl Rückgabetyp</dt>
  <dd><p><a name="cdecl"></a>Das Wort <em>Cdecl</em> wird normalerweise weggelassen, weil die meisten Funktionen die Standard-Aufrufkonvention verwenden, statt die C-Aufrufkonvention (Funktionen wie wsprintf, die eine unterschiedliche Anzahl an Argumenten akzeptieren, bilden solch eine Ausnahme). Ergibt der Aufruf <a href="#An">ErrorLevel A<strong>n</strong></a> (<strong>n</strong> ist die Gesamtgröße an übergebenen Argumenten), während du Cdecl weglässt,  wird <em>Cdecl</em> möglicherweise benötigt. Beachte, dass die meisten objektorientierten C++-Funktionen die <i>thiscall</i>-Konvention verwenden, die in AutoHotkey nicht unterstützt wird.</p>
      <p>Das Wort <em>Cdecl</em> sollte vor dem Rückgabetyp (falls vorhanden) stehen. Dabei muss jedes Wort mit einem Leer- oder Tabulatorzeichen getrennt werden. Zum Beispiel: <code>"Cdecl Str"</code>.</p>
      <p><span class="ver">[AHK_L 53+]:</span> In den 64-Bit-Builds von AutoHotkey hat <i>Cdecl</i> keine Wirkung, weil es keine seperate C-Aufrufkonvention im 64-Bit-Code gibt.</p>
      <p><em>Rückgabetyp</em>: Wenn die Funktion einen vorzeichenbehafteten 32-Bit-Integer (Int), BOOL oder nichts zurückgibt, kann <em>Rückgabetyp</em> weggelassen werden. Ansonsten kann ein Argumenttyp aus der <a href="#types">Typentabelle</a> verwendet werden. Das <a href="#asterisk">Sternchen-Suffix</a> wird ebenfalls unterstützt.</p></dd>

</dl>

<h3 id="types">Argumenttypen und Rückgabewerte</h3>
<table class="info">
<tr>
<td>Str</td>
<td><p><a name="str"></a>Ein String wie "Blau" oder MeineVar. Wenn die aufgerufene Funktion den String ändert und das Argument eine reine Variable ist, wird deren Inhalt aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von <em>MeineVar</em> in Großbuchstaben umwandeln: <code>DllCall("CharUpper", "Str", <i>MeineVar</i>)</code>.</p>
  <p>Wenn die Funktion allerdings in der Lage ist, einen String größer als die aktuelle Variablenkapazität zu speichern, muss sichergestellt werden, dass die Variable vor dem Funktionsaufruf groß genug ist. Verwende dazu <code><a href="VarSetCapacity.htm">VarSetCapacity(MeineVar, 123)</a></code> - 123 wäre die Länge, die <em>MeineVar</em> haben soll.</p>
  <p>Ein <em>Str</em>-Argument darf kein <a href="../Variables.htm#Expressions">Ausdruck</a> sein, der eine Zahl errechnet (z. B. i+1). In diesem Fall wird die Funktion nicht aufgerufen und ErrorLevel auf -2 gesetzt.</p>
  <p>Die <a href="#asterisk">Sternchenvariable</a> "Str*" wird unterstützt, aber nur selten verwendet. Sie kann bei Funktionen nützlich sein, die so etwas wie "TCHAR **" oder "LPTSTR *" erwarten.</p>
  <p>Hinweis: Bei der Übergabe eines Strings an eine Funktion muss klar sein, welchen <a href="../Compat.htm#DllCall">String-<i>Typ</i></a> die Funktion erwartet.</p></td>
</tr>
<tr>
  <td><a name="astr"></a><a name="wstr"></a>AStr<br>WStr</td>
  <td><span class="ver">[AHK_L 42+]:</span> Ein <b>A</b>NSI- oder Unicode-String (<b>W</b>ide character). Unter <a href="../Compat.htm#DllCall">Script-Kompatibilität</a> findest du gleichwertige Win32-Typen und weitere Details.</td>
</tr>
<tr>
  <td>Int64</td>
  <td>Ein 64-Bit-Integer mit einem Bereich von -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</td>
</tr>
<tr>
  <td>Int</td>
  <td id="Int"><p>Ein 32-Bit-Integer (meistgenutzter Integer-Typ) mit einem Bereich von -2147483648 (-0x80000000) bis 2147483647 (0x7FFFFFFF). Int wird manchmal auch als "Long" bezeichnet.</p>
    <p>Int sollte auch verwendet werden, wenn die Funktion ein BOOL-Argument erwartet (ein BOOL-Wert sollte entweder 1 oder 0 sein).</p>
    <p>Ein <a href="#unsigned">vorzeichenloser</a> (unsigned) Integer (UInt) wird auch ziemlich oft genutzt, z. B. für DWORD.</p></td>
</tr>
<tr>
  <td>Short</td>
  <td>Ein 16-Bit-Integer im Bereich von -32768 (-0x8000) bis 32767 (0x7FFF). Ein <a href="#unsigned">vorzeichenloser</a> 16-Bit-Integer (UShort) kann bei Funktionen verwendet werden, die DWORD erwarten.</td>
</tr>
<tr>
  <td>Char</td>
  <td>Ein 8-Bit-Integer mit einem Bereich von -128 (-0x80) bis 127 (0x7F). Ein <a href="#unsigned">vorzeichenloser</a> 8-Bit-Integer (UChar) kann bei Funktionen verwendet werden, die BYTE erwarten.</td>
</tr>
<tr>
  <td>Float</td>
  <td>Eine 32-Bit-Fließkommazahl mit maximal 6 Stellen nach dem Komma.</td>
</tr>
<tr>
  <td>Double</td>
  <td>Eine 64-Bit-Fließkommazahl mit maximal 15 Stellen nach dem Komma.</td>
</tr>
<tr>
  <td>Ptr</td>
  <td id="ptr"><p><span class="ver">[AHK_L 42+]:</span> Ein <a href="../Variables.htm#PtrSize">pointer-großer</a> Integer, der Int oder Int64 entspricht, abhängig davon, ob die script-ausführende EXE-Datei 32- oder 64-Bit ist. <i>Ptr</i> sollte für Pointer verwendet werden, die auf Arrays oder Strukturen (wie RECT* oder LPPOINT) verweisen, und für fast alle Handles (wie HWND, HBRUSH oder HBITMAP). Wenn der Parameter ein Pointer ist, der auf einen einzelnen numerischen Wert wie LPDWORD oder int* verweist, ist der *- oder P-Suffix besser geeignet als "Ptr".</p>
  <p><i>Ptr</i> kann auch den *- oder P-Suffix haben; es sollte nur bei Funktionen verwendet werden, die einen Pointer per LPVOID* oder Ähnliches zurückgeben.</p>
  <p><i>UPtr</i> ist auch gültig, aber nur in einem 32-Bit-Build, da AutoHotkey keine vorzeichenlose 64-Bit-Integer unterstützt.</p>
  <p>Wenn die Kompatibilität mit älteren Versionen von AutoHotkey erforderlich ist, kann ein Variablentyp wie folgt verwendet werden:</p>
  <pre>Ptr := A_PtrSize ? "Ptr" : "UInt" <em>; Wenn A_PtrSize nicht definiert ist, gilt stattdessen UInt.</em>
DllCall("DeleteFile", Ptr, &amp;Dateiname) <em>; Lass die Anführungszeichen bei Ptr weg.</em></pre>
  <p>Hinweis: Zum Übergeben eines <strong>NULL</strong>-Handles oder -Pointers muss der Integer 0 verwendet werden.</p></td>
</tr>
<tr>
  <td>* oder P<br>
    (Suffix)</td>
  <td id="asterisk"><p>Füge ein Sternchen (optional mit einem Leerzeichen davor) an einen der oben genannten Typen davor an, wenn nicht der Wert selbst, sondern die Adresse des Arguments übergeben werden soll (die aufgerufene Funktion muss so konstruiert sein, dass sie so etwas akzeptieren kann). Der Wert von so einem Argument könnte durch die Funktion geändert werden - wann immer man eine reine Variable als Argument übergibt, wird der Inhalt dieser Variable aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von MeineVar per Adresse an MeineFunktion übergeben, und auch MeineVar aktualisieren, um Änderung an ihr durch MeineFunktion widerzuspiegeln: <code>DllCall("MeineDLL\MeineFunktion", "Int*", MeineVar)</code>.</p>
    <p>In der Regel wird ein Sternchen verwendet, wann immer eine Funktion ein Argumenttyp oder Rückgabetyp hat, der mit "LP" beginnt. Das bekannteste Beispiel dafür ist LPDWORD - ein Pointer, der auf ein DWORD verweist. Da DWORD ein vorzeichenloser 32-Bit-Integer ist, sollte für LPDWORD stattdessen "UInt*" oder "UintP" verwendet werden. Das Sternchen sollte nicht bei Stringtypen wie LPTSTR, auf Strukturen verweisende Pointer wie LPRECT, oder Arrays verwendet werden; für sie ist <a href="#str">"Str"</a> oder "Ptr" besser geeignet, abhängig davon, ob du eine Variable oder deren Adresse übergeben willst.</p>
    <p>Hinweis: "Char*" ist nicht das gleiche wie <a href="#str">"Str"</a>, weil "Char*" die Adresse einer 8-Bit-Zahl übergibt, während <a href="#str">"Str"</a> die Adresse einer Reihe von Zeichen übergibt, die je nach AutoHotkey-Version 8-Bit (ANSI) oder 16-Bit (Unicode) groß sind. Ebenso übergibt "UInt*" die Adresse einer 32-Bit-Zahl. Es sollte nicht verwendet werden, wenn die Funktion ein Array mit Werten oder eine Struktur größer als 32 Bit erwartet.</p>
    <p>Da die Variablen in AutoHotkey keinen festen Typ haben, verweist die Adresse, die an die Funktion übergeben wurde, auf einen temporären Speicher, anstatt auf die Variable selbst. Es ist nicht notwendig, <a href="VarSetCapacity.htm">VarSetCapacity</a> auf die Variable anzuwenden, weil DllCall sie nach dem Durchführen der Funktion korrekt aktualisieren wird.</p>
    </td>
</tr>
<tr>
  <td>U (Präfix)</td>
  <td><p><a name="unsigned"></a>Füge den Buchstaben U an einen der oben genannten Integer-Typen dahinter an, wenn der Typ als vorzeichenloser Integer (UInt64, Uint, UShort und UChar) interpretiert werden soll. Streng genommen ist das nur für Rückgabewerte und <a href="#asterisk">Sternchenvariablen</a> notwendig, da es keine Rolle spielt, ob ein Argument, der als Wert übergeben wurde, vorzeichenbehaftet oder vorzeichenlos ist (außer für Int64).</p>
    <p>Wenn ein negativer Integer bei einem vorzeichenlosen Argument angegeben wurde, wechselt der Integer in den vorzeichenlosen Bereich. Wenn -1 beispielsweise als UInt gesendet wurde, wäre es 0xFFFFFFFF.</p>
    <p>Von Funktionen erzeugte <em>vorzeichenlose</em> 64-Bit-Integer werden nicht unterstützt. Zahlen größer gleich 0x8000000000000000 können daher nur verwendet werden, wenn man das U-Präfix weglässt und jeden negativen Wert, der von der Funktion empfangen wurde, als großen Integer interpretiert. Zum Beispiel würde eine Funktion, die -1 als Int64 zurückgibt, eigentlich 0xFFFFFFFFFFFFFFFF zurückgeben, wenn sie ein UInt64 überhaupt zurückgeben kann.</p></td>
</tr>
</TABLE>
<p><strong>Hinweis</strong>: Wenn man ein Argument- oder Rückgabetyp ohne Leerzeichen oder Sternchen angibt, können die Anführungszeichen weggelassen werden. Zum Beispiel könnte <code>Str</code> anstelle von <code>"Str"</code> und <code>CDecl</code> anstelle von <code>"CDecl"</code> verwendet werden. Darüber hinaus könnte der Buchstabe P anstelle des Sternchens verwendet werden, so dass auch dort die Anführungszeichen weggelassen werden können. Zum Beispiel: <code>UIntP</code>.</p>

<h3 id="error">ErrorLevel</h3>
<p><span class="ver">[v1.1.04+]</span> Diese Funktion ist in der Lage, bei Misserfolg eine Ausnahme auszulösen. Für mehr Informationen, siehe <a href="Catch.htm#RuntimeErrors">Laufzeitfehler</a>.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> wird auf einen der folgenden Werte gesetzt, um den Erfolg oder Misserfolg des Aufrufs zu kennzeichnen.</p>
<p><strong>0</strong>: Erfolgreich.</p>
<p><strong>-1</strong>: Der <em>[DllDatei\]Funktion</em>-Parameter ist eine Fließkommazahl. Es wird ein String oder ein positiver Integer benötigt.</p>
<p><strong>-2</strong>: Der <a href="#types">Rückgabetyp</a> oder einer der angegebenen <a href="#types">Argumenttypen</a> ist ungültig. Dieser Fehler kann auch auftreten, wenn ein <a href="../Variables.htm#Expressions">Ausdruck</a>, der eine Zahl errechnet, an ein String-Argument (<a href="#str">Str</a>) übergeben wird.</p>
<p><strong>-3</strong>: Die angegebene <em>DllDatei</em> war weder zugreifbar noch konnte sie geladen werden. Wenn ein expliziter Pfad bei <em>DllDatei</em> fehlt, muss sich die Datei auf einen der Pfade aus der PATH-Umgebungsvariable oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a> befinden. Dieser Fehler kann auch auftreten, wenn dem Benutzer die nötigen Zugriffsrechte für die Datei fehlen, oder wenn AutoHotkey im 32-Bit-Format und die DLL im 64-Bit-Format ist (oder umgekehrt).</p>
<p><strong>-4</strong>: Die angegebene Funktion konnte innerhalb der DLL nicht gefunden werden.</p>
<p><strong>N</strong> (beliebige positive Nummer): Die Funktion wurde aufgerufen, aber mit der schweren Ausnahme Nummer <strong>N</strong> abgebrochen (z. B. wäre 0xC0000005 "Zugriffsverletzung"). In solchen Fällen wird die Funktion einen leeren String zurückgeben und jede <a href="#asterisk">Sternchenvariable</a> weiter aktualisiert. Ein Beispiel einer schweren Ausnahme ist die Dereferenzierung eines ungültigen Pointers, wie z. B. NULL. Da eine <a href="#cdecl">Cdecl</a>-Funktion nie den im nächsten Abschnitt erwähnten <em>"An"</em>-Fehler erzeugen kann, könnte sie eine Ausnahme generieren, wenn zu wenig Argumente an diese Funktion übergeben werden.</p>
<p><strong><a name="An"></a>An</strong> (Buchstabe A, gefolgt von einem Integer <strong>n</strong>): Der Aufruf der Funktion war erfolgreich, allerdings wurden zu viele oder zu wenig Argumente übergeben. "<strong>n</strong>" ist dabei die Anzahl an Bytes, mit denen die Argumentenliste falsch war. Ist <strong>n</strong> positiv, wurden zu viele Argumente (oder zu lange Argumente) übergeben, oder der Aufruf erfordert <a href="#cdecl">CDecl</a>. Ist <strong>n</strong> negativ, wurden zu wenig Argumente übergeben. Dieses Problem sollte behoben werden, um eine zuverlässige Operation der Funktion zu gewährleisten. So ein Fehler könnte auch darauf hindeuten, dass eine Ausnahme aufgetreten ist - in diesem Fall gibt die Funktion einen leeren Wert zurück. Beachte, dass aufgrund der x64-Aufrufkonvention ein 64-Bit-Build den ErrorLevel nie auf <b>An</b> setzt.</p>

<h3 id="except">Ausnahmen und A_LastError</h3>
<p>Trotz integrierter Ausnahmebehandlung ist es möglich, dass ein Script mit DllCall abstürzt. Dies kann passieren, wenn eine Funktion nicht direkt eine Ausnahme erzeugt, sondern etwas Unangebrachtes zurückgibt, wie z. B. ein schlechter Pointer oder ein nicht-terminierter String. Die Funktion ist nicht unbedingt daran Schuld, wenn das Script ihr einen ungeeigneten Wert übergibt, wie z. B. einen schlechten Pointer oder ein <a href="#str">"Str"</a> mit unzureichender Kapazität. Ein Script kann auch abstürzen, wenn es einen ungeeigneten Argument- oder Rückgabetyp spezifiziert, z.B. mit der Behauptung, dass ein gewöhnlicher Integer, der von einer Funktion zurückgegeben wurde, eine <a href="#asterisk">Sternchenvariable</a> oder <a href="#str">Str</a> ist.</p>
<p><a name="LastError"></a>Die integrierte Variable <strong>A_LastError</strong> enthält den Rückgabewert der Systemfunktion GetLastError(), die sofort nach einem Funktionsaufruf aufgerufen wird (hat keine messbaren Auswirkungen auf die Performance). A_LastError enthält eine Nummer zwischen 0 und 4294967295 (immer in dezimaler Form, nicht hexadezimal). Wie <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auch, ist A_LastError eine Pro-Thread-Einstellung; das heißt, dass Unterbrechungen durch andere <a href="../misc/Threads.htm">Threads</a> den Wert nicht ändern können. Allerdings wird A_LastError auch von <a href="Run.htm#LastError">Run/RunWait</a> gesetzt.</p>

<h3 id="load">Performance</h3>
<p>Bei wiederholenden Aufrufen einer DLL-Datei kann die Performance erheblich verbessert werden, indem man sie explizit lädt (<em>unnötig bei einer <a href="#std">Standard-DLL</a> wie User32, weil sie dauerhaft im Arbeitsspeicher vorhanden ist</em>). Diese Methode verhindert, dass für DllCall jedesmal LoadLibrary und FreeLibrary intern aufgerufen werden muss. Zum Beispiel:</p>
<pre>hModule := DllCall("<strong>LoadLibrary</strong>", "Str", "MeineFunktionen.dll", "Ptr")  <em>; Verhindert, dass DllCall() die Library in der Schleife laden muss.</em>
Loop, C:\Meine Dokumente\*.*, , 1
    Ergebnis := DllCall("MeineFunktionen\BackupFile", "Str", A_LoopFileFullPath)
DllCall("<strong>FreeLibrary</strong>", "Ptr", hModule)  <em>; Zum Freigeben des Speichers kann die DLL nach ihrer Verwendung entladen werden.</em></pre>
<p>Seit v1.0.46.08 kann eine noch schnellere Performance erreicht werden, wenn man im Voraus die Adresse der Funktion nachschlägt. Zum Beispiel:</p>
<pre><em>; Das folgende Beispiel zeigt, wie man LoadLibrary anstelle von GetModuleHandle verwenden kann, wenn die DLL noch nicht geladen ist.</em>
<strong>MulDivProc</strong> := DllCall("GetProcAddress", Ptr, DllCall("GetModuleHandle", Str, "<strong>kernel32</strong>", "Ptr"), AStr, "<strong>MulDiv</strong>", "Ptr")
Loop 500
    DllCall(<strong>MulDivProc</strong>, Int, 3, Int, 4, Int, 3)</pre>
<p><span class="ver">[AHK_L 31+]:</span> Wenn der erste Parameter von DllCall ein literaler String wie <code>"MulDiv"</code> ist und die DLL mit der Funktion normal vor dem Scriptstart geladen wurde, wird der String automatisch in eine Funktionsadresse aufgelöst. Diese integrierte Optimierung ist effektiver als das oben gezeigte Beispiel.</p>
<p>Auch das Hinzufügen von <a href="_NoEnv.htm">#NoEnv</a> irgendwo im Script verbessert die Performance von DllCall, wenn Parametertypen ohne Anführungszeichen verwendet werden (z. B. Int vs. "Int").</p>
<p>Beim Übergeben einer Stringvariable an eine Funktion, die die Länge des Strings unverändert lässt, kann die Performance verbessert werden, wenn man die Variable <a href="../Variables.htm#amp">per Adresse</a> (z. B. &amp;MeineVar) übergibt und nicht als "<a href="#str">str</a>" (besonders bei einem sehr langen String). Das folgende Beispiel wandelt einen String in Großbuchstaben um: <code>DllCall("CharUpper", <strong>Ptr</strong>, <strong>&amp;</strong>MeineVar, Ptr)</code>.</p>

<h3 id="struct">Strukturen und Arrays</h3>
<p>Eine Struktur ist eine Sammlung von <em>Elementen</em> (Feldern), die nebeneinander im Speicher abgelegt sind. Die meisten Elemente sind für gewöhnlich Integer.</p>
<p>Funktionen, die die Adresse einer Struktur (oder eines Speicher-Block-Arrays) akzeptieren, können aufgerufen werden, wenn man die binären Rohdaten der Struktur in eine normale Variable speichert. Die folgenden Schritte werden in der Regel durchgeführt:</p>
<p>1) Rufe <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineStruktur, 123, 0)</code> auf, um sicherzustellen, dass der Speicherumfang der Zielvariable groß genug für die Struktur ist. Ersetze 123 mit einer Zahl, die mindestens so groß ist wie die Strukturgröße. Die Null im letzten Parameter ist optional; sie initialisiert jedes Element mit einer binären Null, um einen häufigen Aufruf von NumPut() im nächsten Schritt zu verhindern.</p>
<p>2) Wenn die Zielfunktion die Werte anfangs in der Struktur verwendet, muss <code><a href="NumPut.htm">NumPut</a>(123, MeineStruktur, 4, "UInt")</code> aufgerufen werden, um jedes Element zu initialisieren, das ungleich 0 sein soll. Ersetze 123 mit dem Integer, der in das Zielelement eingefügt werden soll (oder verwende <code>&amp;Var</code>, um die <a href="../Variables.htm#amp">Adresse</a> einer Variable zu speichern). Ersetze 4 mit dem Offset des Zielelements (siehe Schritt #4, was ein "Offset" ist). Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</p>
<p>3) Rufe die Zielfunktion auf, indem man die <a href="../Variables.htm#amp">Adresse</a> von MeineStruktur als UInt-Argument (oder seit AHK_L 42 als Ptr-Argument) übergibt. Zum Beispiel: <code>DllCall("MeineDLL\MeineFunktion", Ptr, <strong>&amp;</strong>MeineStruktur)</code>. Die Funktion wird einige Elemente untersuchen und/oder ändern.</p>
<p>4) Verwende <code>MeinInteger := <a href="NumGet.htm">NumGet</a>(MeineStruktur, 4, "UInt")</code>, um beliebige Integer von der Struktur abzurufen. Ersetze 4 mit dem Offset des Zielelements in der Struktur. Das erste Element ist immer bei Offset 0. Das zweite Element ist bei Offset 0 plus die Größe des ersten Elements (in der Regel 4). Elemente nach dem zweiten sind bei dem Offset des vorherigen Feldes plus die Größe des vorherigen Feldes. Die meisten Elemente wie DWORD, INT und <a href="#Int">andere Typen von 32-Bit-Integer</a> haben eine Größe von 4 Bytes. Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</p>
<p>Siehe <a href="#ExStruct">Strukturbeispiele</a> für weitere Verwendungsmöglichkeiten.</p>
<h3 id="limits">Bekannte Einschränkungen</h3>
<p>Wenn die <a href="../Variables.htm#amp">Adresse einer Variable</a> (z. B. <code>&amp;MeineVar</code>) an eine Funktion übergeben wird und die Funktion die Länge des Variableninhalts ändert, verhält sich die Variable bei nachfolgender Verwendung nicht mehr korrekt. Dieses Problem kann nur behoben werden, wenn einer der folgenden Punkte durchgeführt wird: 1) Übergebe MeineVar nicht als Ptr/Adresse, sondern als <a href="#str">"Str"</a>-Argument; 2) Seit v1.0.44.03 kann <code><a href="VarSetCapacity.htm#neg1">VarSetCapacity (MeineVar, -1)</a></code> aufgerufen werden, um die intern gespeicherte Länge der Variable zu aktualisieren, nachdem DllCall aufgerufen wurde.</p>
<p>Jede binäre Null, die per Funktion in eine Variable gespeichert wurde, versteckt alle Daten, die rechts neben der Null vorkommen; das heißt, dass solche Daten weder zugreifbar sind noch von den meisten Befehlen und Funktionen geändert werden können. Allerdings können solche Daten per <a href="../Variables.htm#amp">Adressoperatoren</a>, <a href="NumPut.htm">NumPut</a>/<a href="NumGet.htm">NumGet</a> und DllCall selbst manipuliert werden.</p>
<p>Eine Funktion, die die Adresse von einen der übergebenen Strings zurückgibt, könnte einen gleichen String zurückgeben, aber auf einer anderen Speicheradresse als erwartet. Zum Beispiel würde der Aufruf von <code>CharLower(CharUpper(MeineVar))</code> in einer Programmiersprache dazu führen, dass der Inhalt von <em>MeineVar</em> in Kleinbuchstaben umgewandelt wird. Macht man aber das gleiche mit DllCall(), würde <em>MeineVar</em> nach folgendem Aufruf großgeschrieben sein, weil CharLower einen anderen/temporären String bearbeitet hat, dessen Inhalt identisch zu <em>MeineVar</em> war:</p>
<pre>MeineVar = ABC
Ergebnis := DllCall("CharLower", <strong><u>str</u></strong>, DllCall("CharUpper", Str, MeineVar, <strong><u>Str</u></strong>), Str)</pre>
<p>Um dieses Problem zu umgehen, müssen die zwei unterstrichenen "Str"-Werte oben mit Ptr ersetzt werden. Dadurch wird der Rückgabewert von CharUpper als reine Adresse interpretiert, der dann als Integer an CharLower übergeben wird.</p>
<p>Bestimmte Einschränkungen können auftreten, wenn man mit Strings umgeht. Für weitere Informationen, siehe <a href="../Compat.htm#DllCall">Script-Kompatibilität</a>.</p>
<h3 id="COM">Component Object Model (COM)</h3>
<p>COM-Objekte, die per VBScript und ähnliche Sprachen zugreifbar sind, kann man üblicherweise auch über AutoHotkey via <a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjGet.htm">ComObjGet</a>, <a href="ComObjActive.htm">ComObjActive</a> und integrierter <a href="../Objects.htm#Usage_Objects">Objekt-Syntax</a> zugreifen.</p>
<p>COM-Objekte, die <a href="http://msdn.microsoft.com/en-us/library/ms221608.aspx">IDispatch</a> nicht unterstützen, können mit DllCall verwendet werden, wenn man die Adresse einer Funktion von der virtuellen Funktionstabelle des Objekt-Interfaces ermittelt. Für weitere Details, siehe <a href="#ExTaskbar">das Beispiel</a> weiter unten.</p>
<p>Der größte Teil von .NET-Framework ist auch über COM und DllCall zugreifbar. Siehe <a href="http://www.autohotkey.com/forum/topic26191.html">http://www.autohotkey.com/forum/topic26191.html</a>.
</p>

<h3>Siehe auch</h3>
<p><a href="../Compat.htm#DllCall">Script-Kompatibilität</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity</a>, <a href="../Functions.htm">Funktionen</a>, <a href="SysGet.htm">SysGet</a>, <a href="http://msdn.microsoft.com/library/">MSDN Library</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel: Ruft die Windows-API-Funktion "MessageBox" auf und meldet, welchen Button der Benutzer gedrückt hat.</em>

WelcherButton := DllCall("MessageBox", "Int", "0", "Str", "Ja oder Nein drücken", "Str", "Titel der Box", "Int", 4)
MsgBox Du hast den Button #%WelcherButton% gedrückt.</pre>

<pre class="NoIndent"><em>; Beispiel: Ersetzt das Desktop-Hintergrundbild mit der angegebenen Bitmap-Datei (.bmp).</em>

DllCall("SystemParametersInfo", UInt, 0x14, UInt, 0, Str, <i>A_WinDir <strong>.</strong> "\winnt.bmp"</i>, UInt, 2)</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion "IsWindowVisible" auf, um herauszufinden, ob ein Editor-Fenster sichtbar ist.</em>

DetectHiddenWindows On
if not DllCall("IsWindowVisible", "Ptr", WinExist("Unbenannt - Editor"))  <em>; WinExist() gibt HWND zurück.</em>
    MsgBox Das Fenster ist nicht sichtbar.</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion wsprintf() auf, um die Zahl 432 bis zu 10 Zeichen mit führenden Nullen zu erweitern (0000000432).</em>

VarSetCapacity(ErweiterteZahl, 20)  <em>; Stellt sicher, dass die Variable groß genug für den neuen String ist.</em>
DllCall("wsprintf", "Str", ErweiterteZahl, "Str", "%010d", "Int", 432, "Cdecl")  <em>; Benötigt die Cdecl-Aufrufkonvention.</em>
MsgBox %ErweiterteZahl%</pre>

<pre class="NoIndent"><a name="QPC"></a><em>; Beispiel: Zeigt, wie man mit QueryPerformanceCounter() eine höhere Präzision erreichen kann, als die 10 ms von <a href="../Variables.htm#TickCount">A_TickCount</a>.</em>

DllCall("QueryPerformanceCounter", "Int64*", CounterDavor)
Sleep 1000
DllCall("QueryPerformanceCounter", "Int64*", CounterDanach)
MsgBox % "Die Differenz zwischen den Zeiten beträgt " . CounterDanach - CounterDavor</pre>

<pre class="NoIndent"><em>; Beispiel: Ein Hotkey, der vorübergehend die Geschwindigkeit des Mauszeigers verringert, um eine genauere Positionierung zu ermöglichen.
; Halte die F1-Taste, um den Mauszeiger zu verlangsamen. Lass sie los, um die originale Geschwindigkeit wiederherzustellen.</em>

F1::
SPI_GETMOUSESPEED = 0x70
SPI_SETMOUSESPEED = 0x71
<em>; Ermittelt die aktuelle Geschwindigkeit, um sie später wiederherzustellen:</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_GETMOUSESPEED, UInt, 0, UIntP, OrigMausTempo, UInt, 0)
<em>; Nun wird die Geschwindigkeit der Maus im vorletzten Parameter verringert (von 1 bis 20, 10 ist Standard):</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_SETMOUSESPEED, UInt, 0, Ptr, <strong>3</strong>, UInt, 0)
KeyWait F1  <em>; Dies hindert die Auto-Wiederholung der Tastatur daran, DllCall wiederholend aufzurufen.</em>
return

F1 up::<strong>DllCall</strong>("SystemParametersInfo", UInt, 0x71, UInt, 0, Ptr, OrigMausTempo, UInt, 0)  <em>; Stellt die ursprüngliche Geschwindigkeit wieder her.</em></pre>

<pre class="NoIndent"><a name="GetChildHWND"></a><em>; Beispiel: Beim Übergeben einer eindeutigen ID und des Textes oder der ClassNN von einem der Steuerelemente des Fensters
; gibt die folgende Funktion das HWND (eindeutige ID) des Steuerelements zurück.
; v1.0.43.06+: Diese Funktion wurde von folgendem Befehl ersetzt, der genauer ist.</em>

<a href="ControlGet.htm#Hwnd">ControlGet, AusgabeVar, Hwnd,, ClassNN, Fenstertitel</a></pre>

<pre class="NoIndent"><em>; Beispiel: Überwacht das aktive Fenster und zeigt die Position der vertikalen Scrollleiste
; im fokussierten Steuerelement an (in Echzeit). Erfordert v1.0.43.06+, weil es <a href="ControlGet.htm#Hwnd">ControlGet Hwnd</a> verwendet.</em>

#Persistent
SetTimer, BeobachteScrollleiste, 100
return

BeobachteScrollleiste:
AktivesFenster := WinExist("A")
if not AktivesFenster  <em>; Kein aktives Fenster.</em>
    return
ControlGetFocus, FokussiertesSteuerelement, ahk_id %AktivesFenster%
if not FokussiertesSteuerelement  <em>; Kein fokussiertes Steuerelement.</em>
    return
<em>; Zeigt die vertikale oder horizontale Position der Scrollleiste in einem ToolTip an:</em>
ControlGet, UnterelementHWND, Hwnd,, %FokussiertesSteuerelement%, ahk_id %AktivesFenster%
ToolTip % <strong>DllCall</strong>("GetScrollPos", "Ptr", UnterelementHWND, "Int", 1)  <em>;  Letzter Parameter kann 1 für SB_VERT und 0 für SB_HORZ sein.</em>
return</pre>

<pre class="NoIndent"><a name="file"></a><em>; Beispiel: Dieses Script schreibt etwas Text in eine Datei und liest ihn wieder in den Speicher (benötigt v1.0.34+).
; Diese Methode schont die Performance beim Lesen oder Schreiben von mehrere Dateien gleichzeitig.
; Seit AHK_L 42 kann das gleiche mit <a href="FileOpen.htm#writeread">FileOpen</a> erreicht werden. Siehe dazu das <a href="FileOpen.htm">Beispiel</a>.</em>

FileSelectFile, Dateiname, S16,, Neue Datei erstellen:
if Dateiname =
    return
GENERIC_WRITE = 0x40000000  <em>; Öffnet eine Datei zum Schreiben.</em>
CREATE_ALWAYS = 2  <em>; Erstellt eine neue Datei (überschreibt eine vorhandene Datei).</em>
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_WRITE, UInt, 0, Ptr, 0, UInt, CREATE_ALWAYS, UInt, 0, Ptr, 0, Ptr)
if not hFile
{
    MsgBox Kann "%Dateiname%" nicht zum Schreiben öffnen.
    return
}
TestString = Das ist ein Teststring.`r`n  <em>; Wenn eine Datei auf diese Weise geschrieben wird, sollte `r`n anstelle von `n verwendet werden, um eine neue Zeile zu beginnen.</em>
<strong>DllCall</strong>("WriteFile", Ptr, hFile, Str, TestString, UInt, StrLen(TestString), UIntP, AktuellGeschriebeneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Schließt die Datei.</em>

<em>; Nachdem die Datei geschrieben wurde, soll deren Inhalt zurück in den Speicher gelesen werden.</em>
GENERIC_READ = 0x80000000  <em>; Öffnet die Datei zum Lesen.</em>
OPEN_EXISTING = 3  <em>; Datei muss existieren, bevor sie geöffnet werden kann.</em>
FILE_SHARE_READ = 0x1 <em>; Diese und die nächste Variable bestimmen, ob andere Prozesse die Datei öffnen können.</em>
FILE_SHARE_WRITE = 0x2
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_READ, UInt, FILE_SHARE_READ|FILE_SHARE_WRITE, Ptr, 0, UInt, OPEN_EXISTING, UInt, 0, Ptr, 0)
if not hFile
{
    MsgBox Kann "%Dateiname%" nicht zum Lesen öffnen.
    return
}
<em>; Macht die Variable für weitere Testzwecke leer, aber stellt sicher, das genügend Kapazität zur Verfügung steht:</em>
ZuLesendeBytes := VarSetCapacity(TestString, StrLen(TestString))
<strong>DllCall</strong>("ReadFile", Ptr, hFile, Str, TestString, UInt, ZuLesendeBytes, UIntP, AktuellGeleseneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Schließt die Datei.</em>
MsgBox Der folgende String wurde aus der Datei gelesen: %TestString%</pre>

<pre class="NoIndent"><a name="HideCursor"></a><em>; Beispiel: Versteckt den Mauszeiger, wenn man WIN+C drückt. Um den Mauszeiger wieder sichtbar zu machen, drücke nochmals WIN+C.
; Dieses Script stammt von <a href="http://www.autohotkey.com/forum/topic6107.html">www.autohotkey.com/forum/topic6107.html</a></em>

OnExit, ZeigeCursor  <em>; Stellt sicher, dass der Mauszeiger beim Beenden des Scripts wieder sichtbar gemacht wird.</em>
return

ZeigeCursor:
SystemCursor("On")
ExitApp

#c::SystemCursor("Toggle")  <em>; WIN+C, um Mauszeiger ein- und auszuschalten.</em>

SystemCursor(OnOff=1)   <em>; INIT = "I","Init"; OFF = 0,"Off"; TOGGLE = -1,"T","Toggle"; ON = Andere</em>
{
    static AndMask, XorMask, $, h_cursor
        ,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13 <em>; Mauszeiger vom System</em>
        , b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13   <em>; Leere Mauszeiger</em>
        , h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13   <em>; Handles von Standardzeiger</em>
    if (OnOff = "Init" or OnOff = "I" or $ = "")       <em>; initialisieren, wenn benötigt oder erster Aufruf</em>
    {
        $ = h                                          <em>; aktive Standardzeiger</em>
        VarSetCapacity( h_cursor,4444, 1 )
        VarSetCapacity( AndMask, 32*4, 0xFF )
        VarSetCapacity( XorMask, 32*4, 0 )
        system_cursors = 32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650
        StringSplit c, system_cursors, `,
        Loop %c0%
        {
            h_cursor   := DllCall( "LoadCursor", "Ptr",0, "Ptr",c%A_Index% )
            h%A_Index% := DllCall( "CopyImage", "Ptr",h_cursor, "UInt",2, "Int",0, "Int",0, "UInt",0 )
            b%A_Index% := DllCall( "CreateCursor", "Ptr",0, "Int",0, "Int",0
                , "Int",32, "Int",32, "Ptr",&amp;AndMask, "Ptr",&amp;XorMask )
        }
    }
    if (OnOff = 0 or OnOff = "Off" or $ = "h" and (OnOff &lt; 0 or OnOff = "Toggle" or OnOff = "T"))
        $ = b  <em>; leere Mauszeiger benutzen</em>
    else
        $ = h  <em>; gespeicherte Mauszeiger benutzen</em>

    Loop %c0%
    {
        h_cursor := DllCall( "CopyImage", "Ptr",%$%%A_Index%, "UInt",2, "Int",0, "Int",0, "UInt",0 )
        DllCall( "SetSystemCursor", "Ptr",h_cursor, "UInt",c%A_Index% )
    }
}</pre>

<pre class="NoIndent" id="ExStruct"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an GetWindowRect(), das die
; Strukturelemente auf die Positionen der linken, oberen,
; rechten und unteren Seite des Fensters setzt (bezogen auf dem Bildschirm).</em>

Run Notepad
WinWait Unbenannt - Editor  <em>; Setzt auch das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" für das untere WinExist().</em>
VarSetCapacity(Rect, 16)  <em>; RECT ist eine Struktur, bestehend aus vier 32-Bit-Integern (also 4 * 4 = 16).</em>
<strong>DllCall</strong>("GetWindowRect", Ptr, WinExist(), Ptr, &amp;Rect)  <em>; WinExist() gibt HWND zurück.</em>
MsgBox % "Links " . <a href="NumGet.htm">NumGet</a>(Rect, 0, "Int") . " Oben " . NumGet(Rect, 4, "Int")
    . " Rechts " . NumGet(Rect, 8, "Int") . " Unten " . NumGet(Rect, 12, "Int")</pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an FillRect(), um den
; Bildschirm kurzzeitig rot zu färben.</em>

VarSetCapacity(Rect, 16, 0)  <em>; Setzt die Kapazität zum Speichern von vier 4-Byte-Integern und initialisiert sie alle mit Null.</em>
<a href="NumPut.htm">NumPut</a>(A_ScreenWidth//2, Rect, 8, "Int")  <em>; Der dritte Integer in der Struktur ist "rect.right".</em>
NumPut(A_ScreenHeight//2, Rect, 12, "Int") <em>; Der vierte Integer in der Struktur ist "rect.bottom".</em>
hDC := <strong>DllCall</strong>("GetDC", "Ptr", 0, "Ptr")  <em>; Übergibt 0, um den Gerätekontext vom Desktop zu ermitteln.</em>
hBrush := <strong>DllCall</strong>("CreateSolidBrush", "UInt", 0x0000FF, "Ptr")  <em>; Erstellt einen roten Pinsel (0x0000FF ist im BGR-Format).</em>
<strong>DllCall</strong>("FillRect", "Ptr", hDC, "Ptr", &amp;Rect, "Ptr", hBrush)  <em>; Füllt das angegebene Rechteck mithilfe des oberen Pinsels.</em>
<strong>DllCall</strong>("ReleaseDC", "Ptr", 0, "Ptr", hDC)  <em>; Gibt Speicher frei.</em>
<strong>DllCall</strong>("DeleteObject", "Ptr", hBrush)  <em>; Gibt Speicher frei.</em></pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Ändert Datum und Zeit der Systemuhr. Aber sei gewarnt: 
; Sobald die Uhr auf ein zukünftiges Datum gesetzt wird, kann es passieren, dass geplante Tasks vorzeitig ausgeführt werden!</em>

SetzeSystemzeit("20051008142211")  <em>; <a href="FileSetTime.htm#YYYYMMDD">Zeitstempel</a> übergeben (lokal, nicht UTC).</em>

SetzeSystemzeit(YYYYMMDDHHMISS)
<em>; Setzt die Systemzeit auf das angegebene Datum und Zeit.
; Der Aufrufer muss sicherstellen, dass der eingehende Parameter ein gültiger Zeitstempel ist
; (lokale Zeit, nicht UTC). Bei Erfolg wird eine Zahl ungleich 0 zurückgegeben.</em>
{
    <em>; Konvertiert für SetzeSystemzeit() den Parameter von lokale Zeit in UTC.</em>
    UTC_Delta -= A_NowUTC, Seconds  <em>; Sekunden sind aufgrund des Rundungsproblems genauer.</em>
    UTC_Delta := Round(-UTC_Delta/60)  <em>; Rundet auf die nächste Minute.</em>
    YYYYMMDDHHMISS += UTC_Delta, Minutes  <em>; Wendet Offset zum Konvertieren auf UTC an.</em>

    VarSetCapacity(Systemzeit, 16, 0)  <em>; Diese Struktur besteht aus 8 UShort-Werte (d. h. 8 * 2 = 16).</em>

    StringLeft, Int, YYYYMMDDHHMISS, 4    <em>; YYYY (Jahr)</em>
    <a href="NumPut.htm">NumPut</a>(Int, Systemzeit, 0, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 5, 2  <em>; MM (Monat des Jahres, 1-12)</em>
    NumPut(Int, Systemzeit, 2, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 7, 2  <em>; DD (Tag des Monats)</em>
    NumPut(Int, Systemzeit, 6, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 9, 2  <em>; HH (Stunden im 24-Stunden-Format)</em>
    NumPut(Int, Systemzeit, 8, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 11, 2 <em>; MI (Minuten)</em>
    NumPut(Int, Systemzeit, 10, "UShort")
    StringMid, Int, YYYYMMDDHHMISS, 13, 2 <em>; SS (Sekunden)</em>
    NumPut(Int, Systemzeit, 12, "UShort")

    return <strong>DllCall</strong>("SetSystemTime", Ptr, &amp;Systemzeit)
}</pre>

<pre class="NoIndent"><em>/* <strong>Weitere Struktur-Befehle:</strong>

1) Im <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Script</a> wird gezeigt, wie man mit DllCall() eine Netzwerkverbindung zu einem TCP/IP-Server aufbauen und Daten von ihm empfangen kann.

2) Das Betriebssystem besitzt Standard-Fensterdialoge zum Auswählen von Farben, Schriftarten oder Icons.
Solche Fensterdialoge verwenden Strukturen und werden auf <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a> gezeigt.

*/</em></pre>

<pre id="ExTaskbar" class="NoIndent"><em>/*
  Beispiel: Entfernt mithilfe von COM vorübergehend das aktive Fenster aus der Taskleiste.

  Methoden in der VTable der <a href="http://msdn.microsoft.com/en-us/library/bb774652.aspx">ITaskbarList</a>:
    IUnknown:
      0 QueryInterface  -- verwende stattdessen <a href="ComObjQuery.htm">ComObjQuery</a>
      1 AddRef          -- verwende stattdessen <a href="ObjAddRef.htm">ObjAddRef</a>
      2 Release         -- verwende stattdessen <a href="ObjAddRef.htm">ObjRelease</a>
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Erstellt ein TaskbarList-Objekt und speichert dessen Adresse in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

activeHwnd := WinExist("A")

DllCall(vtable(tbl,3), "ptr", tbl)                     <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774650.aspx">HrInit</a>()</em>
DllCall(vtable(tbl,5), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
DllCall(vtable(tbl,4), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

<em>; Nicht-Dispatch-Objekte müssen immer manuell freigegeben werden.</em>
ObjRelease(tbl)

vtable(ptr, n) {
    <em>; NumGet(ptr+0) gibt die Adresse der virtuellen Funktionstabelle
    ; des Objekts zurück (kurz: vtable). Der Rest des Ausdrucks ermittelt
    ; die Adresse der n-ten Funktionsadresse von der vtable.</em>
    return NumGet(NumGet(ptr+0), n*A_PtrSize)
}
</pre>

</body>
</html>
