<!DOCTYPE HTML>
<html>
<head>
<title>Process</title>
<meta name="keywords" content="Befehl, Prozess">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<link href="../static/font.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="../static/html5.js"></script>
<![endif]-->
<script src="../navbar/NavScript.js" type="text/javascript"></script>
</head>
<body>
<script type="text/javascript">WriteHeader(1);</script>
<div id="content">
  <section>
    <div id="article">
      <h1>Process</h1>
      <p>Führt verschiedene Operationen an einem Prozess aus: Überprüfung seiner Existenz, Änderung seiner Priorität, Schließen, Warten auf Schließen des Prozesses.</p>
      <pre class="Syntax">Process, Befehl, PID-oder-Name [, Param3]</pre>
      <h3>Parameter</h3>
      <table class="info">
        <tr>
          <td style="width: 15%;">Befehl</td>
          <td style="width: 85%;"><p>Eins der folgenden Wörter:</p>
            <p><strong>Exist</strong>: Setzt <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf die Prozess-ID (PID), falls ein passender Prozess gefunden wird, ansonsten auf 0. Ist der <em>PID-oder-Name</em>-Parameter leer, wird die PID des Scripts abgerufen. Alternativ kann die einzeilige Methode <code>PID := DllCall("GetCurrentProcessId")</code> verwendet werden, um die PID des Scripts abzurufen.</p>
            <p><strong>Close</strong>: Wenn ein passender Prozess erfolgreich beendet wird, enthält <a href="../misc/ErrorLevel.htm">ErrorLevel</a> die zuletzt verwendete Prozess-ID (PID). Andernfalls wird ErrorLevel auf 0 gesetzt (das heißt, dass der Prozess nicht gefunden wurde oder nicht richtig beendet werden konnte). Das Schließen eines Prozesses kann dazu führen, dass der Prozessablauf an einem kritischen Punkt unterbrochen wird oder nicht gespeicherte Daten in seinem Fenster verloren gehen können, falls vorhanden. Da der Prozess abrupt beendet wird, sollte diese Methode nur verwendet werden, wenn sein Fenster mit <a href="WinClose.htm">WinClose</a> nicht geschlossen werden kann.</p>
            <p><strong>List</strong>: Obwohl <em>List</em> noch nicht unterstützt wird, wird im <a href="#ListEx">Beispiele-Abschnitt</a> demonstriert, wie mit DllCall eine Prozessliste ermittelt werden kann.</p>
            <p id="Priority"><strong>Priority</strong>: Ändert die Priorität (wie im Windows Task-Manager angezeigt) des ersten passenden Prozesses auf <em>Param3</em> und setzt <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf dessen Prozess-ID (PID). Ist der <em>PID-oder-Name</em>-Parameter leer, wird die Priorität vom Script geändert. Falls kein passender Prozess gefunden wird oder Probleme beim Ändern der Priorität auftreten, wird ErrorLevel auf 0 gesetzt.</p>
            <p><em>Param3</em> sollte einer der folgenden Buchstaben oder Wörter sein: L (oder Low), B (oder BelowNormal), N (oder Normal), A (oder AboveNormal), H (oder High), R (oder Realtime). Da BelowNormal und AboveNormal in Windows 95/98/Me/NT4 nicht unterstützt werden, werden diese automatisch mit <em>Normal</em> ersetzt. Hinweis: Jeder Prozess, der nicht darauf ausgelegt ist, in Echtzeit (Realtime) zu laufen, reduziert möglicherweise die Systemstabilität, wenn er auf diese Priorität gesetzt wird.</p>
            <p><strong>Wait</strong>: Wartet bis zu <em>Param3</em> Sekunden (kann einen Dezimalpunkt enthalten), bis ein passender Prozess vorhanden ist. Wenn <em>Param3</em> nicht vorhanden ist, wird der Befehl unendlich lang warten. Wenn ein passender Prozess entdeckt wird, wird <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auf die Prozess-ID (PID) gesetzt. Wenn der Befehl das Zeitlimit überschreitet, wird ErrorLevel auf 0 gesetzt.</p>
            <p><strong>WaitClose</strong>: Wartet bis zu <em>Param3</em> Sekunden darauf (kann einen Dezimalpunkt enthalten), dass ALLE passenden Prozesse geschlossen werden. Wenn <em>Param3</em> nicht vorhanden ist, wird der Befehl unendlich lang warten. Wenn alle passenden Prozesse geschlossen sind, wird <a href="../misc/ErrorLevel.htm">Errorlevel</a> auf 0 gesetzt. Wenn der Befehl das Zeitlimit überschreitet, wird ErrorLevel auf die Prozess-ID (PID) des ersten passenden Prozesses gesetzt, der noch vorhanden ist.</p></td>
        </tr>
        <tr>
          <td>PID-oder-Name </td>
          <td><p>Dieser Parameter ist entweder eine Nummer (die PID) oder ein Prozessname, wie unten beschrieben. Zudem kann dieser Parameter leer gelassen werden, um die Priorität des Scripts selbst zu ändern.</p>
            <p>PID: Die Prozess-ID - eine Nummer, die einen bestimmten Prozess eindeutig identifiziert (diese Nummer ist nur während der Laufzeit dieses Prozesses gültig). Die PID eines neu gestarteten Prozesses kann mit dem <a href="Run.htm">Run</a>-Befehl ermittelt werden. Ebenso kann die PID eines Fensters mit <a href="WinGet.htm">WinGet</a> abgerufen werden. Der Process-Befehl selbst kann auch dazu verwendet werden, eine PID zu ermitteln.</p>
            <p>Name: Der Prozessname ist im Prinzip der Name der ausführbaren Datei (ohne Pfad), z. B. notepad.exe oder winword.exe. Da ein Name mit mehreren laufenden Prozessen übereinstimmen kann, wird nur der erste Prozess bearbeitet. Der Name ist nicht von der Groß-/Kleinschreibung abhängig.</p></td>
        </tr>
        <tr>
          <td>Param3</td>
          <td>Siehe <em>Befehl</em>-Parameter für Details.</td>
        </tr>
      </table>
      <h3>ErrorLevel</h3>
      <p>Siehe <em>Befehl</em>-Parameter für Details.</p>
      <h3>Bemerkungen</h3>
      <p>Bei <em>Wait</em> und <em>WaitClose</em> werden Prozesse alle 100 Millisekunden überprüft; sobald die Bedingung erfüllt ist, hört der Befehl auf, zu warten. Das heißt, dass der Befehl diese Zeitüberschreitung nicht erst abwartet, sondern <a href="../misc/ErrorLevel.htm">ErrorLevel</a> sofort auf einen oben genannten Wert setzt und die Ausführung des Scripts fortsetzt. Während der Befehl im Wartezustand ist, können neue <a href="../misc/Threads.htm">Threads</a> per <a href="../Hotkeys.htm">Hotkey</a>, <a href="Menu.htm">benutzerdefinierte Menüeinträge</a> oder <a href="SetTimer.htm">Timer</a> gestartet werden.</p>
      <p>Damit der Process-Befehl in Windows NT4 funktioniert, wird die Datei PSAPI.DLL benötigt, welche normalerweise bereits im AutoHotkey-Installationsverzeichnis enthalten ist (d. h., dass keine zusätzlichen Installationsschritte notwendig sind). Um diesen Befehl innerhalb eines <a href="../Scripts.htm#ahk2exe">kompilierten Scripts</a> in Windows NT4 zu verwenden, muss eine Kopie von PSAPI.DLL im Ordner des Scripts oder in eins der angegebenen Verzeichnisse aus der PATH-Umgebungsvariable eingefügt werden (einige NT4-Systeme verfügen bereits über die DLL).</p>
      <h3>Verwandte Befehle</h3>
      <p><a href="Run.htm">Run</a>, <a href="WinGet.htm">WinGet</a>, <a href="WinClose.htm">WinClose</a>, <a href="WinKill.htm">WinKill</a>, <a href="WinWait.htm">WinWait</a>, <a href="WinWaitClose.htm">WinWaitClose</a>, <a href="IfWinExist.htm">IfWinExist</a></p>
      <h3>Beispiele</h3>
      <pre class="NoIndent"><em>; Beispiel #1:</em>

Run Notepad.exe, , , NeuPID
Process, priority, %NeuPID%, High
MsgBox Die PID des neu gestarteten Editors ist %NeuPID%.</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #2:</em>

Process, wait, Notepad.exe, 5.5
NeuPID = %ErrorLevel%  <em>; Den Wert sofort speichern, da sich ErrorLevel ständig ändert.</em>
If NeuPID = 0
{
    MsgBox Innerhalb von 5.5 Sekunden ist kein passender Prozess erschienen.
    Return
}
<em>; Ansonsten:</em>
MsgBox Ein passender Prozess ist erschienen (Prozess-ID ist %NeuPID%).
Process, priority, %NeuPID%, Low
Process, priority, , High  <em>; Das Script selbst setzt sich auf hohe Priorität.</em>
WinClose Unbenannt - Editor
Process, WaitClose, %NeuPID%, 5
If ErrorLevel <em>; Die PID ist noch vorhanden.</em>
    MsgBox Der Prozess wurde nicht innerhalb von 5 Sekunden geschlossen.</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent"><em>; Beispiel #3: Ein Hotkey, der die Priorität des Prozesses vom aktiven Fenster ändert:</em>

#z:: <em>; Hotkey: WIN+Z</em>
WinGet, aktiv_pid, PID, A
WinGetTitle, aktiv_titel, A
Gui, 5:Add, Text,, Drücke ESCAPE, um das Fenster zu schließen, oder wähle mit einem Doppelklick eine neue Prioritätsstufe für das folgende Fenster:`n%aktiv_titel%
Gui, 5:Add, ListBox, vEigeneListBox gEigeneListBox r5, Normal|High|Low|BelowNormal|AboveNormal
Gui, 5:Add, Button, default, OK
Gui, 5:Show,, Priorität bestimmen
Return

5GuiEscape:
5GuiClose:
Gui, Destroy
Return

EigeneListBox:
If A_GuiEvent &lt;&gt; DoubleClick
    Return
<em>; sonst bis zum nächsten Label springen:</em>
5ButtonOK:
GuiControlGet, EigeneListBox
Gui, Destroy
Process, Priority, %aktiv_pid%, %EigeneListBox%
If ErrorLevel
    MsgBox Erfolg: Die Priorität wurde auf "%EigeneListBox%" gesetzt.
Else
    MsgBox Fehler: Die Priorität wurde nicht auf "%EigeneListBox%" gesetzt.
Return</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent" id="ListEx"><em>; Beispiel #4: Ermittelt mit DllCall eine Liste aller laufenden Prozesse und zeigt sie in einer MsgBox an.</em>

d := "  |  "  <em>; String-Trennzeichen</em>
s := 4096  <em>; Größe der Puffer und Arrays (4 KB)</em>

Process, Exist  <em>; Setzt ErrorLevel auf die PID des laufenden Scripts</em>
<em>; Ermittelt den Handle des Scripts mit PROCESS_QUERY_INFORMATION (0x0400)</em>
h := DllCall("OpenProcess", "UInt", 0x0400, "Int", false, "UInt", ErrorLevel, "Ptr")
<em>; Öffnet einen anpassbaren Zugriffstoken mit diesem Prozess (TOKEN_ADJUST_PRIVILEGES = 32)</em>
DllCall("Advapi32.dll\OpenProcessToken", "Ptr", h, "UInt", 32, "PtrP", t)
VarSetCapacity(ti, 16, 0)  <em>; Struktur der Berechtigungen</em>
NumPut(1, ti, 0, "UInt")  <em>; Einen Eintrag in das Array mit Berechtigungen ...</em>
<em>; Ermittelt die lokale eindeutige Kennung der Debug-Berechtigung:</em>
DllCall("Advapi32.dll\LookupPrivilegeValue", "Ptr", 0, "Str", "SeDebugPrivilege", "Int64P", luid)
NumPut(luid, ti, 4, "Int64")
NumPut(2, ti, 12, "UInt")  <em>; Aktiviert die Berechtigung: SE_PRIVILEGE_ENABLED = 2</em>
<em>; Aktualisiert die Berechtigungen von diesem Prozess mit dem neuen Zugriffstoken:</em>
DllCall("Advapi32.dll\AdjustTokenPrivileges", "Ptr", t, "Int", false, "Ptr", &amp;ti, "UInt", 0, "Ptr", 0, "Ptr", 0)
DllCall("CloseHandle", "Ptr", t)  <em>; Handle vom Zugriffstoken schließen, um Speicherplatz zu sparen.</em>
DllCall("CloseHandle", "Ptr", h)  <em>; Handle vom Prozess schließen, um Speicherplatz zu sparen.</em>

hModule := DllCall("LoadLibrary", "Str", "Psapi.dll")  <em>; Bibliothek vorher laden, um die Performance zu erhöhen.</em>
s := VarSetCapacity(a, s)  <em>; Ein Array, das die Liste mit Prozesskennungen erhält:</em>
c := 0  <em>; Zähler für Prozesskennungen</em>
DllCall("Psapi.dll\EnumProcesses", "Ptr", &amp;a, "UInt", s, "UIntP", r)
Loop, % r // 4  <em>; Parst das Array nach Kennungen in DWORD-Formaten (32 Bit):</em>
{
   id := NumGet(a, A_Index * 4, "UInt")
   <em>; Öffnet Prozess mit: PROCESS_VM_READ (0x0010) | PROCESS_QUERY_INFORMATION (0x0400)</em>
   h := DllCall("OpenProcess", "UInt", 0x0010 | 0x0400, "Int", false, "UInt", id, "Ptr")
   If !h
      continue
   VarSetCapacity(n, s, 0)  <em>; Ein Puffer, der den Basisnamen des Moduls erhält:</em>
   e := DllCall("Psapi.dll\GetModuleBaseName", "Ptr", h, "Ptr", 0, "Str", n, "UInt", A_IsUnicode ? s//2 : s)
   If !e    <em>; Rückfallmethode für 64-Bit-Prozesse, falls im 32-Bit-Modus:</em>
      If e := DllCall("Psapi.dll\GetProcessImageFileName", "Ptr", h, "Str", n, "UInt", A_IsUnicode ? s//2 : s)
         SplitPath n, n
   DllCall("CloseHandle", "Ptr", h)  <em>; Handle vom Prozess schließen, um Speicherplatz zu sparen.</em>
   If (n && e)  <em>; Wenn Abbild ungleich 0 ist, zur Liste hinzufügen:</em>
      l .= n . d, c++
}
DllCall("FreeLibrary", "Ptr", hModule)  <em>; Bibliothek entladen, um Speicher freizugeben.</em>
<em>;Sort, l, C  ; Hebt die Kommentierung dieser Zeile auf, um die Liste alphabetisch zu sortieren.</em>
MsgBox, 0, %c% Prozesse, %l%</pre>
      <p>&nbsp;</p>
      <pre class="NoIndent" id="ListCom"><em>; Beispiel #5: Ermittelt über COM eine Liste von laufenden Prozessen.</em>

Gui, Add, ListView, x2 y0 w400 h500, Prozessname|Befehlszeile
for Prozess in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Process")
    LV_Add("", Prozess.Name, Prozess.CommandLine)
Gui, Show,, Prozessliste

<em>; Win32_Prozess: <a href="http://msdn.microsoft.com/en-us/library/aa394372.aspx">http://msdn.microsoft.com/en-us/library/aa394372.aspx</a></em>
</pre>
    </div>
  </section>
</div>
<script type="text/javascript">WriteFooter(1);</script>
</body>
</html>