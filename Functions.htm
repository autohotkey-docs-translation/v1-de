<!DOCTYPE HTML>
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Rückgabewerte an den Aufrufer</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion</a></li>
  <li><a href="#ShortCircuit">Logische Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Verwenden von Subroutinen innerhalb einer Funktion</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</a></li>
  <li><a href="#lib">Libraries mit Funktionen: Standard- und Benutzer-Library</a></li>
  <li><a href="#BuiltIn">Built-in-Funktionen</a></li>
</ul>
<h2 id="intro">Einführung und einfache Beispiele</h2>
<p id="define">Eine Funktion ist prinzipiell das gleiche wie eine Subroutine (<a href="commands/Gosub.htm">GoSub</a>), außer dass sie Parameter (Eingabewerte) von ihrem Aufrufer entgegennehmen kann. Darüber hinaus kann eine Funktion optional einen Wert an den Aufrufer zurückgeben. Das folgende Beispiel zeigt, wie eine einfache Funktion zwei Zahlen entgegennimmt und deren Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
<p>So etwas nennt man auch eine <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (Groß- und Kleinschreibung ist egal) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, speichert man ihr Ergebnis mithilfe des <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operators</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) in eine Variable. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Man kann eine Funktion auch aufrufen, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)</pre>
<p>In diesem Fall aber wird der zurückgegebene Wert der Funktion verworfen; wenn die Funktion nur einen Rückgabewert erzeugen würde, wäre ihr Aufruf daher sinnlos.</p>
<p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten Variablennamen in ihrer Parameterliste nicht von Prozentzeichen umschlossen sein. Dagegen sollten literale Zeichenketten in Anführungszeichen gesetzt werden. Zum Beispiel:</p>
<pre>if <a href="#InStr">InStr</a>(MeineVar, "Fuchs")
    MsgBox Die Variable MeineVar enthält das Wort Fuchs.</pre>
<p>Desweiteren kann man Funktionen innerhalb der Parameter eines Befehls aufrufen (außer in EingabeVar und AusgabeVar-Parametern, wie die von <a href="commands/StringLen.htm">StringLen</a>). Allerdings müssen Parameter, die keine <a href="Variables.htm#Expressions">Ausdrücke</a> unterstützen, den "%"-Präfix wie folgt verwenden:</p>
<pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
<p>Das "%"-Präfix kann auch in Parametern verwendet werden, die bereits Ausdrücke unterstützen, aber es wird einfach ignoriert.</p>
<h2 id="param">Parameter</h2>
<p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in Klammern aufgelistet (Leerzeichen zwischen dem Namen und der öffnenden Klammer sind nicht erlaubt). Braucht die Funktion keine Parameter, können die Klammern leer gelassen werden; zum Beispiel: <code>ErmittleAktuellenZeitstempel()</code>.</p>
<p id="ByRef"><strong>ByRef-Parameter</strong>: Innerhalb der Funktion werden Parameter grundsätzlich wie <a href="#Locals">lokale Variablen</a> behandelt, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Das Benutzen von <em>ByRef</em> bewirkt, dass die angegebene Variable mit dem Parameter verbunden wird. Das heißt, dass der Parameter und die Variable des Aufrufers auf den gleichen Inhalt im Arbeitsspeicher verweisen. Auf diese Weise kann die Tauschen-Funktion die Variablen des Aufrufers ändern, indem sie den Inhalt der <em>Links</em>-Variable in die <em>Rechts</em>-Variable verschiebt, und umgekehrt.</p>
<p>Würde man <em>ByRef</em> hingegen nicht verwenden, wären <em>Links</em> und <em>Rechts</em> nur Kopien der Variablen des Aufrufers - die Tauschen-Funktion hätte keine externe Auswirkung.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zurückgeben kann, ist <em>ByRef</em> gut dafür geeignet, zusätzliche Ergebnisse zurückzugeben. Bringe den Aufrufer einfach dazu, eine Variable zu übergeben (üblicherweise leer), in der die Funktion einen Wert speichern kann.</p>
<p>Beim Übergeben langer Zeichenketten an eine Funktion ist <em>ByRef</em> leistungsfähiger und außerdem platzsparend, weil keine Kopie der Zeichenkette gemacht werden muss. Ebenso ist <em>ByRef</em>, wenn man eine lange Zeichenkette an den Aufrufer zurücksenden will, leistungsfähiger als <code>Return LangeZeichenkette</code>.</p>
<p><span class="ver">[AHK_L 60+]:</span> Übergibt man etwas anderes als eine veränderbare Variable an einen ByRef-Parameter, verhält sich die Funktion so, als wäre das Schlüsselwort "ByRef" nicht vorhanden. Zum Beispiel würde <code>Tauschen(A_Index, i)</code> den Wert von <i>A_Index</i> in <i>i</i> speichern, aber den gespeicherten Wert in <i>Links</i> verwerfen, sobald die <i>Tauschen</i>-Funktion fertig ist.</p>
<p><span class="ver">[v1.1.01+]:</span> Mit der <a href="#IsByRef">IsByRef()</a>-Funktion kann festgestellt werden, ob der Aufrufer eine Variable für einen bestimmten ByRef-Parameter bereitgestellt hat.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Objektfelder werden nicht als Variablen behandelt, wenn sie mit <em>ByRef</em> verwendet werden. Übergibt man beispielsweise <code>foo.bar</code> an einen ByRef-Parameter, wird <em>ByRef</em> einfach ignoriert.</li>
  <li>Es ist nicht möglich, die <a href="misc/Clipboard.htm">Zwischenablage</a>, <a href="Variables.htm#BuiltIn">Built-in-Variablen</a> oder <a href="Variables.htm#env">Umgebungsvariablen</a> an einen <em>ByRef</em>-Parameter einer Funktion zu übergeben, egal ob <a href="commands/_NoEnv.htm">#NoEnv</a> im Skript vorhanden ist oder nicht.</li>
  <li id="recurse">Theoretisch kann eine Funktion sich selbst rekursiv aufrufen. Wenn sie sich jedoch selbst ihre eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter per <em>ByRef</em> übergibt, wird der <em>ByRef</em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit selben Namen verweisen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter übergibt.</li>
  <li>Wenn ein Parameter bei einem Funktionsaufruf in eine Variable aufgelöst wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), können andere Parameter auf der linken oder rechten Seite diese Variable ändern, bevor sie an die Funktion übergeben wird. Zum Beispiel würde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 übergeben, wenn <em>Var</em> zu Beginn 0 ist, selbst wenn der erste Parameter der Funktion nicht als <em>ByRef</em> markiert ist. Da dieses Verhalten unlogisch ist, könnte es in einer zukünftigen Version geändert werden.</li>
  <li>ByRef werden nicht direkt in Funktionen unterstützt, die von COM-Clienten aufgerufen werden, oder beim Aufrufen von COM-Methoden. Stattdessen wird das Skript ein <a href="commands/ComObjActive.htm#ByRef">Wrapper-Objekt</a> übergeben müssen oder empfangen, das den <a href="commands/ComObjType.htm">VarTyp</a> und die Adresse des Wertes enthält.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Bei einer Funktionsdefinition können die Parameter als optional gekennzeichnet werden. Dazu muss ein Gleichheitszeichen (oder seit v1.1.09 <code>:=</code>) und ein Standardwert angefügt werden. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Addieren(X, Y, Z:=0) {
    return X + Y + Z
}</pre>
<p>Seit v1.1.09 wird sowohl <code>=</code> als auch <code>:=</code> unterstützt. Es wird empfohlen, die zweite Methode zu verwenden, um Widersprüche bei Ausdruckszuweisungen zu vermeiden und die Kompatibilität mit zukünftigen AutoHotkey-Versionen einzuhalten.</p>
<p>Übergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Wenn der Aufrufer aber nur <strong>zwei</strong> Parameter übergibt, wird in Z automatisch der Wert 0 gespeichert.</p>
<p id="missing">Es ist nicht möglich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das heißt, dass alle Parameter, die auf der rechten Seite des ersten optionalen Parameters vorkommen, auch als optional gekennzeichnet werden müssen. <span class="ver">[AHK_L 31+]:</span> Beim Aufrufen der Funktion können die optionale Parameter in der Mitte der Parameterliste weggelassen werden, wie unten gezeigt. Für dynamische Funktionsaufrufe und Methodenaufrufe wird v1.1.12+ benötigt.</p>
<pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p id="OptionalByRef">Seit v1.0.46.13 unterstützen <a href="#ByRef">ByRef-Parameter</a> auch Standardwerte; zum Beispiel: <code>Funktion(ByRef p1 = "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter weglässt, erstellt die Funktion eine lokale Variable, die den Standardwert enthält; das heißt, dass die Funktion sich so verhält, als würde das Schlüsselwort "ByRef" fehlen.</p>
<p>Als Standardwert eines Parameters sind folgende Werte zulässig: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Gleitkommazahl oder eine literale Zeichenkette wie "fox" oder "" (Zeichenketten unterstützen vor v1.0.46.13 nur "").</p>
<h2 id="return">Rückgabewerte an den Aufrufer</h2>
<p>Wie man bereits in der <a href="#intro">Einführung</a> lesen konnte, kann eine Funktion dazu gebracht werden, einen Wert per <a href="commands/Return.htm">Return</a> an ihren Aufrufer zurückzugeben.</p>
<pre>
Test := returnTest()
MsgBox % Test

returnTest() {
  return 123
}
</pre>
<p>Wenn noch mehr Ergebnisse von einer Funktion zurückgegeben werden sollen, kann man auch <a href="#ByRef">ByRef</a> verwenden:</p>
<pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
  val1 := "A"
  val2 := 100
  val3 := 1.1
  return
}
</pre>
<p><span class="ver">[v1.0.97+]:</span> Mithilfe von <a href="Objects.htm#Usage_Objects">Objekten</a> und <a href="Objects.htm#Usage_Simple_Arrays">Arrays</a> können mehrere Werte oder sogar benannte Werte zurückgegeben werden:</p>
<pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen <span class="ver">[AHK_L 60+]</span></h2>
<p>Bei einer Funktionsdefinition kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, so dass sie eine beliebige Anzahl an Parametern akzeptieren kann:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Ruft man eine variadische Funktion auf, sind überschüssige Parameter über ein Objekt zugreifbar, das im letzten Parameter der Funktion gespeichert ist. Der erste überschüssige Parameter ist <code><i>params</i>[1]</code>, der Zweite ist <code><i>params</i>[2]</code> und so weiter. Wie bei anderen Standardobjekten auch, kann <code><i>params</i>.MaxIndex()</code> verwendet werden, um den höchsten numerischen Index zu ermitteln (in diesem Fall die Parameteranzahl). Sind keine Parameter vorhanden, gibt MaxIndex jedoch eine leere Zeichenkette zurück.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann nur am Ende der formalen Parameterliste verwendet werden.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> können nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> übergeben überschüssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Während variadische Funktionen eine beliebige Parameteranzahl <i>akzeptieren</i> können, kann ein Array mit Parametern an <i>jede</i> Funktion durch Anwenden der gleichen Syntax beim Funktionsaufruf übergeben werden:</p>
<pre>Teilzeichenketten := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">Teilzeichenketten*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Die Nummerierung der Parameter beginnt innerhalb des Quell-Arrays bei 1.</li>
  <li>Optionale Parameter können im Array ganz weggelassen werden.</li>
  <li>Das Array mit Parametern kann benannte Elemente beim Aufrufen einer benutzerdefinierten Funktion enthalten; in allen anderen Fällen werden benannte Elemente nicht unterstützt.</li>
  <li>Die Zielfunktion kann auch variadisch sein - in diesem Fall werden benannte Elemente kopiert, selbst wenn sie keine entsprechenden formalen Parameter haben.</li>
  <li>Diese Syntax kann auch zum Aufrufen einer Methode oder zum Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>. Seit v1.1.12 kann sie auch zum Setzen von Eigenschaften verwendet werden.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterstützt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Es dürfen keine Leerraumzeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste vorkommen.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen</h2>
<h3>Lokale Variablen</h3>
<p>Alle Variablen, die innerhalb einer Funktion abgerufen oder erstellt werden, sind standardmäßig <em>lokal</em> (außer <a href="#SuperGlobal">superglobale</a> Variablen und Built-in-Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Die Inhalte der lokalen Variablen sind nur für Zeilen innerhalb der Funktion sichtbar. Daher kann eine lokale Variable den gleichen Namen haben wie eine globale Variable, aber mit unterschiedlichem Inhalt. Alle lokalen Variablen sind zu Beginn leer, und das jedes Mal, wenn die Funktion aufgerufen wird.</p>
<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor man sie verwendet. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    global LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert außerhalb dieser Funktion zugewiesen.</em>
    FileAppend, %TextZuLog%`n, %LogDateiname%
}</pre>
<p id="AssumeGlobal"><strong>Global-behandelnder Modus</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) global behandelt. Dazu muss in der ersten Zeile entweder das Wort "global" stehen oder die Deklaration einer lokalen Variable durchgeführt werden. Zum Beispiel:</p>
<pre>SetzeStandardwerte()
{
    global  <em>; Kann weggelassen werden, wenn die erste Zeile so etwas wie "local MeineVar" ist.</em>
    MeineGlobal := 33  <em>; Speichert 33 in eine globale Variable und erstellt sie, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen müssen in diesem Modus deklariert werden, weil sie sonst global behandelt werden.</em>
}</pre>
<p>Dieser global-behandelnde Modus kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Array</a> zu erstellen - wie bei einer Schleife, die Werte per <code>Array%A_Index%</code> zuweist.</p>
<p id="SuperGlobal"><strong>Superglobale Variablen</strong> <span class="ver">[v1.1.05+]:</span> Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen. Dadurch wird verhindert, dass die Variablen jedes Mal in einer Funktion neu deklariert werden müssen. Funktionsparameter oder lokale Variablen mit gleichem Namen haben Vorrang vor der globalen Variable. Variablen, die mit dem Schlüsselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind im Prinzip immer lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl = 0
    Zeilenanzahl += 1  <em>; Behandelt einen Zähler lokal (der Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend, %Zeilenanzahl%: %TextZuLog%`n, %LogDateiname%
}</pre>
<p id="InitStatic"><strong>Statische Initialisierungen</strong>: In den Versionen vor v1.0.46 enthielten alle statischen Variablen zu Beginn einen leeren Wert; das erstmalige Verwenden solcher Variablen konnte nur erkannt werden, wenn sie überprüft wurden, ob sie leer sind. Seit v1.0.46 können statische Variablen mit einem beliebigen Wert initialisiert werden (vorher war nur <code>""</code> möglich), wenn <code>:=</code> oder <code>=</code> gefolgt von einem folgenden Wert angefügt wird: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Gleitkommazahl oder eine literale Zeichenkette wie <code>"fox"</code>. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Jede statische Variable wird nur einmal initialisiert (bevor das Skript seine Ausführung beginnt).</p>
<p><span class="ver">[AHK_L 58+]:</span> <code>Static Var := Ausdruck</code> wird unterstützt. Solche Ausdrücke werden unmittelbar vor dem automatischen Ausführungsbereich ausgewertet - in der Reihenfolge, wie sie im Skript vorkommen.</p>
<p id="AssumeStatic"><strong>Statisch-behandelnder Modus</strong> <span class="ver">[v1.0.48+]:</span> Eine Funktion kann so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) statisch behandelt. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
<pre>ErmittleVomStatischenArray(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird nur einmal ausgeführt (beim Start).</em>
    if ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    return StatischesArray%Elementnummer%
}</pre>
<p>Im statisch-behandelnden Modus muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Es ist möglich, mehrere Variablen auf der gleichen Zeile zu deklarieren, wenn sie wie folgt durch Kommas getrennt werden:</p>
<pre>global LogDateiname, MaxVersuche := 5
static GesamtVersuche = 0, VorherErgebnis</pre>
<p id="DeclareInit">Seit v1.0.46 kann eine lokale oder globale Variable auf der gleichen Zeile als Deklaration initialisiert werden, wenn ein <code>:=</code> oder <code>=</code> gefolgt von einem <a href="Variables.htm#Expressions">Ausdruck</a> angefügt wird (in Deklarationen verhält sich der Operator <code>=</code> wie <code>:=</code>). Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgeführt, sofern sie von der Ablaufsteuerung erreicht werden. Das heißt, dass eine Zeile wie <code>local x = 0</code> den gleichen Effekt hat wie die zwei folgenden Zeilen: <code>local x</code>, gefolgt von <code>x = 0</code>.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Starten des Skripts verarbeitet werden, kann eine Variable nicht bedingt per <a href="commands/IfExpression.htm">IF-Anweisung</a> deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> bedingungslos für alle Zeilen zwischen der Deklaration und der schließenden Funktionsklammer wirksam wird. Beachte zudem, dass es zurzeit nicht möglich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>
<p id="PseudoArrays">Bei Befehlen, die <a href="misc/Arrays.htm">Pseudo-Arrays</a> erstellen (z. B. <a href="commands/StringSplit.htm">StringSplit</a>), ist jede Variable im resultierenden Pseudo-Array lokal, solange der <a href="#AssumeGlobal">global-behandelnder Modus</a> nicht aktiv ist oder das erste Pseudo-Array-Element als lokale Variable deklariert wurde (das gilt auch bei der Übergabe eines Funktionsparameters, selbst wenn dieser Parameter ein <a href="#ByRef">ByRef</a> ist, da Parameter prinzipiell das gleiche sind wie lokale Variablen). Wurde das erste Element hingegen <a href="#Global">global deklariert</a>, wird ein globales Array erstellt. Allerdings gilt die unten genannte <i>Oft auftretende Verwechslungsgefahr</i> auch in solchen Fällen. Das erste Element bei <a href="commands/StringSplit.htm">StringSplit</a> ist ArrayName0. Bei anderen array-erstellenden Befehlen wie <a href="commands/WinGet.htm">WinGet List</a> ist das erste Element ArrayName (also ohne die Nummer).</p>
<p id="DynVar"><span id="Dynamic"></span>Innerhalb einer Funktion wird jeder dynamische Variablenverweis wie <code>Array%i%</code> immer in eine lokale Variable aufgelöst. Wenn aber eine Variable mit diesem Namen nicht vorhanden ist, wird eine globale Variable verwendet, falls vorhanden. Wenn sie weder existiert noch bei ihrer Verwendung die Variable erstellt werden muss, wird sie als lokale Variable erstellt, solange der <a href="#AssumeGlobal">global-behandelnder Modus</a> nicht aktiv ist. Daher kann eine Funktion ein globales <a href="misc/Arrays.htm">Array</a> nur manuell erstellen (z. B. mithilfe von <code>Array%i% := A_Index</code>), wenn in der Funktion der <a href="#AssumeGlobal">global-behandelnder Modus</a> definiert wurde.</p>
<p id="ArrayConfusion"><strong>Oft auftretende Verwechslungsgefahr</strong>: Jeder <em>nicht</em>-dynamische Verweis auf eine Variable erstellt diese Variable in dem Moment, wo das Skript gestartet wird. Zum Beispiel: Außerhalb einer Funktion würde <code>MsgBox %Array1%</code> die Array1-Variable als globale Variable erstellen, in dem Moment, wo das Skript gestartet wird. Innerhalb einer Funktion würde <code>MsgBox %Array1%</code> die Array1-Variable als lokale Variable erstellen, in dem Moment, wo das Skript gestartet wird (solange der <a href="#AssumeGlobal">global-behandelnder Modus</a> nicht aktiv ist), selbst wenn Array und Array0 als global deklariert sind.</p>
<h2 id="DynCall">Dynamisches Aufrufen einer Funktion</h2>
<p>Seit v1.0.47.06 kann eine Funktion (auch eine <a href="#BuiltIn">Built-in-Funktion</a>) mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel würde <code>%Var%(x, "Fuchs")</code> die Funktion aufrufen, deren Name in <em>Var</em> enthalten ist. Ebenso würde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abhängig vom aktuellen Wert in A_Index.</p>
<p>Seit v1.1.07.00 kann <em>Var</em> in <code>%Var%()</code> einen Funktionsnamen oder ein <a href="objects/Functor.htm">Funktionsobjekt</a> enthalten. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen.</p>
<p>Kann die Funktion aufgrund einer der unten genannten Gründe nicht aufgerufen werden, stoppt die Auswertung des Ausdrucks, der den Aufruf enthält, vorzeitig ohne Meldung, was zu widersprüchlichen Ergebnissen führen könnte:</p>
<ul>
  <li>Aufrufen einer nicht-existierenden Funktion, das mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">Built-in-Funktionen</a>) muss explizit im Skript vorkommen (zum Beispiel über <a href="commands/_Include.htm">#Include</a> oder einem nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>).</li>
  <li>Übergeben von zu wenigen Parametern, das verhindert werden kann, wenn der Rückgabewert von <a href="#IsFunc">IsFunc()</a> überprüft wird (das ist die Anzahl der Pflichtparameter plus 1). Hinweis: Seit v1.0.48 wird das Übergeben von zu vielen Parametern toleriert; jeder zusätzliche Parameter wird vollständig ausgewertet (einschließlich aller Funktionsaufrufe) und dann verworfen.</li>
</ul>
<p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="ShortCircuit">Logische Kurzschlussauswertung</h2>
<p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, schließen sie sich kurz, um die Performance zu erhöhen (egal ob Funktionsaufrufe vorhanden sind oder nicht). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Im folgenden Beispiel wird gezeigt, wie genau das funktioniert:</p>
<pre>if (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
<p>Wenn die <em>FarbName</em>-Variable leer sein sollte, wird die FindeFarbe()-Funktion niemals aufgerufen, weil die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass Nebeneffekte von einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachte außerdem, dass die Kurzschlussauswertung verschachtelte <em>AND</em>s und <em>OR</em>s stufenweise durchgeht. Im Ausdruck des folgenden Beispiels würde nur der Vergleich ganz links erfolgen, wann immer <em>FarbName</em> leer ist, weil die linke Seite dann ausreichen würde, um das Endergebnis mit Sicherheit zu bestimmen:</p>
<pre>if (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie die Beispiele oben zeigen, sollten lange (zeitaufwendige) Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erhöhen. Diese Technik kann auch dazu genutzt werden, das Aufrufen einer Funktion zu verhindern, wenn ein ungeeigneter Wert (z. B. eine leere Zeichenkette) an einen ihrer Parameter übergeben wird.</p>
<p>Seit v1.0.46 erfolgt beim <a href="Variables.htm#ternary">ternären Bedingungsoperator (?:)</a> auch eine Kurzschließung durch Ignorieren der verlierenden Abzweigung.</p>
<h2 id="gosub">Verwenden von Subroutinen innerhalb einer Funktion</h2>
<p>Eine Funktion kann keine <a href="#define">Definitionen</a> von anderen Funktionen enthalten. Subroutinen sind aber möglich. Sie können, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> gestartet und per <a href="commands/Return.htm">Return</a> beendet werden (in diesem Fall gilt das Return nicht für die Funktion, sondern für das GoSub).</p>
<p>Bekannte Einschränkung: Momentan darf der Name jeder Subroutine (Label) nur einmal im ganzen Skript vorkommen. Beim Starten des Programms wird eine Fehlermeldung angezeigt, wenn Labels doppelt vorkommen.</p>
<p id="GosubPublic">Verwendet eine Funktion das <a href="commands/Gosub.htm">GoSub</a>, um zu einer öffentlichen Subroutine zu springen (die sich außerhalb der Funktionsklammern befindet), sind alle Variablen außerhalb global und die funktions-eigenen <a href="#Locals">lokalen Variablen</a> nicht abrufbar, bis die Subroutine ihr Return erreicht hat. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
<p>Das <a href="commands/Goto.htm">Goto</a> kann nicht verwendet werden, um vom Inneren der Funktion nach außen zu springen. Allerdings kann eine Funktion per <a href="commands/Gosub.htm">GoSub</a> zu einer externen/öffentlichen Subroutine springen und von dort aus per Goto weiterspringen.</p>
<p>In der Regel sollte man auf <a href="commands/Goto.htm">Goto</a> verzichten. Dieser Befehl kann aber innerhalb einer Funktion nützlich sein, wo man auf eine andere Position springen muss. Diese Methode kann helfen, komplexe Funktionen zu vereinfachen, die mehrere Rückgabepunkte haben, bei denen zuvor einige Säuberungsaktionen durchgeführt werden müssen.</p>
<p>Eine Funktion kann extern-aufrufende Subroutinen wie <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Menüpunkte</a> enthalten. Dies ist eine übliche Vorgehensweise, um sie in eine separate Datei zu packen und später via <a href="commands/_Include.htm">#Include</a> bereitzustellen, so dass sie den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> des Skripts nicht stören können. Allerdings gelten folgende Einschränkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), wenn ihre Funktionen normal aufgerufen werden, weil ein Subroutinen-<a href="misc/Threads.htm">Thread</a>, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage wäre, die Werte von lokalen Variablen zu ändern, wie sie vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zurückkehrt, werden all ihre lokale Variablen leer gemacht, um deren Speicher freizugeben.</li>
  <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) als <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
  <li>Wenn eine Funktion von einem Subroutinen-<a href="misc/Threads.htm">Thread</a> betreten wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschließlich array-erstellende Befehle).</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Erreicht der Ausführungsablauf innerhalb einer Funktion die schließende Funktionsklammer, ohne auf ein <a href="commands/Return.htm">Return</a> gestoßen zu sein, endet die Funktion und gibt ihren Aufrufer eine leere Zeichenkette zurück. Ein leerer Wert wird auch zurückgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> explizit fehlt.</p>
<p>Wenn eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> mit dem <a href="commands/Exit.htm">Exit</a>-Befehl terminiert, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Zum Beispiel: Die Anweisung <code>Var := Addieren(2, 3)</code> würde <code>Var</code> unverändert belassen, wenn <code>Add()</code> per Exit beendet wird. Das gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausführen</a> einer nicht-existierenden Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> ändern, um einen zusätzlichen Wert zurückzugeben, der sich leicht merken lässt.</p>
<p>Um eine Funktion mit einer oder mehreren leeren Zeichenketten aufzurufen, verwende zwei Anführungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
<p>Da das Aufrufen einer Funktion keinen neuen <a href="misc/Threads.htm">Thread</a> startet, werden von der Funktion geänderten Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer wirksam.</p>
<p>Der Aufrufer einer Funktion kann nicht-existierende Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente an ihr übergeben, was nützlich für Funktionen ist, die den entsprechenden Parameter als <a href="#ByRef">ByRef</a> erwarten. Ruft man beispielsweise <code>ErmittleNächsteZeile(LeeresArray%i%)</code> auf, wird die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellt (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">global-behandelnder Modus</a> wirksam ist).</p>
<p>Wenn <a href="commands/ListVars.htm">ListVars</a> in einer Funktion verwendet wird, werden ihre <a href="#Locals">lokalen Variablen</a> und deren Inhalte angezeigt. Diese Sache kann dabei helfen, ein Skript zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Man könnte komplexe Funktionen als besser lesbar und verwaltbar empfinden, wenn deren Variablen eindeutige Präfixe angefügt werden. Durch Hinzufügen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    return x + y
<strong>}</strong></pre>
<h2 id="include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Skripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
<p>Erklärung: Erreicht der Ausführungsablauf des Skripts eine Funktionsdefinition, wird er sie sofort überspringen und seine Ausführung bei der Zeile nach der schließenden Klammer fortsetzen. Daraus folgt, dass die Ausführung nie in eine Funktion geraten kann, oder dass das Vorhandensein von einer oder mehreren Funktionen am Anfang des Skripts den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> beeinflussen könnten.</p>
<h2 id="lib">Libraries mit Funktionen: Standard- und Benutzer-Library <span class="ver">[v1.0.47+]</span></h2>
<p>Ein Skript kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> verwenden zu müssen. Damit dies funktioniert, muss eine Datei, die den gleichen Namen hat wie die Funktion, in einem der folgenden Library-Verzeichnissen vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Lokale Library - benötigt <span class="ver">AHK_L 42+</span>.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; Benutzer-Library.</em>
Pfad-zur-gerade-laufenden-AutoHotkey.exe\Lib\  <em>; Standard-Library.</em></pre>
<p>Ruft ein Skript beispielsweise die nicht-existierende Funktion <code>MeineFunktion()</code> auf, sucht das Programm nach einer Datei namens "MeineFunktion.ahk" in der Benutzer-Library. Wenn sie dort nicht gefunden werden kann, wird die Standard-Library durchsucht. Ergibt die Suche weiterhin keine Treffer und enthält der Funktionsname einen Unterstrich (z. B. <code>MeinPräfix_MeineFunktion</code>), sucht das Programm in beiden Libraries nach einer Datei namens <code>MeinPräfix.ahk</code> und lädt sie, falls sie existiert. Auf diese Weise kann <code>MeinPräfix.ahk</code> sowohl die Funktion <code>MeinPräfix_MeineFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>MeinPräfix_</code> beginnen.</p>
<p><span class="ver">[AHK_L 42+]:</span> Es kann nun die lokale Library verwendet werden, die durchsucht wird, bevor die Benutzer- und Standard-Library durchsucht werden.</p>
<p>Nur ein direkter Funktionsaufruf wie <code>MeineFunk()</code> kann eine Library automatisch einfügen lassen. Wenn die Funktion nur dynamisch oder indirekt aufgerufen wird, z. B. via Timer oder GUI-Ereignis, dann muss die Library explizit in das Skript eingefügt werden. Zum Beispiel: <code><a href="commands/_Include.htm">#Include</a> &lt;MeineFunk&gt;</code></p>
<p>In der Regel enthält eine Library-Datei nur eine einzelne Funktion, die den gleichen Namen hat wie die Datei. Sie kann aber auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum zur Verfügung stehen; das heißt, dass sie von überall im Skript aufgerufen werden können.</p>
<p>Verwendet eine Library-Datei <a href="commands/_Include.htm">#Include</a>, gilt als Arbeitsverzeichnis für #Include das Verzeichnis der Library-Datei. Der Vorteil davon ist, dass eine Weiterleitung zu einer größeren Library-Datei erstellt werden kann, die diese Funktion und andere dazugehörige Funktionen enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Skript-Compiler (ahk2exe)</a> unterstützt auch Library-Funktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Wenn AutoHotkey.exe dort nicht vorhanden, wird der Compiler zwar weiterhin funktionieren, aber die Library-Funktionen werden nicht mehr automatisch eingefügt.</p>
<p>Funktionen, die auf diese Weise eingefügt werden, haben die gleiche Performance wie andere Funktionen, weil sie geladen werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="BuiltIn">Built-in-Funktionen</h2>
<p>Jeder optionale Parameter, der am Ende der Parameterliste einer Built-in-Funktion vorkommt, kann komplett weggelassen werden. Zum Beispiel könnte man <code>WinExist("Unbenannt - Editor")</code> angeben, weil die Funktion ihre anderen drei Parameter als leere Werte ansieht.</p>
<p>Eine Built-in-Funktion wird überschrieben, wenn das Skript seine eigene Funktion mit dem gleichen Namen definieren würde. Zum Beispiel könnte man anstelle der normalen WinExist()-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können per <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
<p>Klicke unten auf den Namen einer bestimmten Built-In-Funktion, um mehr über sie zu erfahren.</p>
<h3>Häufig verwendete Funktionen</h3>
<table class="info">
  <tr>
    <th style="width:150px">Funktion</th>
    <th>Beschreibung</th>
  </tr>
  <tr id="FileExist">
    <td><a href="commands/FileExist.htm">FileExist</a></td>
    <td>Überprüft, ob eine Datei oder ein Ordner vorhanden ist, und gibt ihre/seine Attribute zurück.</td>
  </tr>
  <tr id="GetKeyState">
    <td><a href="commands/GetKeyState.htm">GetKeyState</a></td>
    <td>Gibt True (1) zurück, wenn die angegebene Taste unten ist, und False (0), wenn sie oben ist.</td>
  </tr>
  <tr id="InStr">
    <td><a href="commands/InStr.htm">InStr</a></td>
    <td>Sucht eine bestimmte Zeichenkette, beginnend von links oder rechts.</td>
  </tr>
  <tr id="RegExMatch">
    <td><a href="commands/RegExMatch.htm">RegExMatch</a></td>
    <td>Überprüft, ob ein Muster (regulärer Ausdruck) in einer Zeichenkette vorkommt.</td>
  </tr>
  <tr id="RegExReplace">
    <td><a href="commands/RegExReplace.htm">RegExReplace</a></td>
    <td>Ersetzt Vorkommen eines Musters (regulärer Ausdruck) innerhalb einer Zeichenkette.</td>
  </tr>
  <tr id="SubStr">
    <td><a href="commands/SubStr.htm">SubStr</a></td>
    <td>Ermittelt ein oder mehrere Zeichen von der angegebenen Position innerhalb einer Zeichenkette.</td>
  </tr>
  <tr id="StrLen">
    <td><a href="commands/StringLen.htm">StrLen</a></td>
    <td>Ermittelt die Anzahl an Zeichen, die sich in einer Zeichenkette befinden.</td>
  </tr>
  <tr id="StrSplit">
    <td><a href="commands/StringSplit.htm">StrSplit</a></td>
    <td>Teilt eine Zeichenkette in mehreren Teilzeichenketten auf, basierend auf die angegebenen Trennzeichen.</td>
  </tr>
  <tr id="WinActive">
    <td><a href="commands/WinActive.htm">WinActive</a></td>
    <td>Überprüft, ob das angegebene Fenster existiert und zurzeit aktiv (im Vordergrund) ist, und gibt dessen Eindeutige ID (HWND) zurück.</td>
  </tr>
  <tr id="WinExist">
    <td><a href="commands/WinExist.htm">WinExist</a></td>
    <td>Überprüft, ob ein passendes Fenster existiert, und gibt die Eindeutige ID (HWND) des ersten passenden Fensters zurück.</td>
  </tr>
</table>
<h3>Verschiedene Funktionen</h3>
<table class="info">
  <tr>
    <th style="width:150px">Funktion</th>
    <th>Beschreibung</th>
  </tr>
  <tr id="Asc">
    <td><a href="commands/Asc.htm">Asc</a></td>
    <td>Gibt den numerischen Wert des ersten Bytes oder der ersten UTF-16-Codeeinheit in der angegebenen Zeichenkette zurück.</td>
  </tr>
  <tr id="Chr">
    <td><a href="commands/Chr.htm">Chr</a></td>
    <td>Gibt eine Zeichenkette zurück (üblicherweise ein einzelnes Zeichen), deren Zeichencode mit der angegebenen Nummer übereinstimmt.</td>
  </tr>
  <tr id="DllCall">
    <td><a href="commands/DllCall.htm">DllCall</a></td>
    <td>Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</td>
  </tr>
  <tr id="FileOpen">
    <td><a href="commands/FileOpen.htm">FileOpen</a></td>
    <td>Ermöglicht eine objektorientierte Dateibearbeitung.</td>
  </tr>
  <tr id="Func">
    <td><a href="commands/Func.htm">Func</a></td>
    <td>Ermittelt einen Verweis auf die angegebene Funktion.</td>
  </tr>
  <tr id="GetKeyName">
    <td><a href="commands/GetKey.htm">GetKeyName/VK/SC</a></td>
    <td>Ermittelt den Namen/Text, virtuellen Tastencode oder Scancode einer Taste.</td>
  </tr>
  <tr id="IsByRef">
    <td><a href="commands/IsByRef.htm">IsByRef</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn ein ByRef-Parameter einer Funktion mit einer Variable übergeben wurde.</td>
  </tr>
  <tr id="IsFunc">
    <td><a href="commands/IsFunc.htm">IsFunc</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn die angegebene Funktion im Skript vorkommt.</td>
  </tr>
  <tr id="IsLabel">
    <td><a href="commands/IsLabel.htm">IsLabel</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn das angegebene Label im Skript vorkommt.</td>
  </tr>
  <tr id="IsObject">
    <td><a href="commands/IsObject.htm">IsObject</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn der angegebene Wert ein Objekt ist.</td>
  </tr>
  <tr id="ListView">
    <td><a href="commands/ListView.htm#BuiltIn">ListView</a></td>
    <td>Funktion zum Hinzufügen, Einfügen, Modifizieren oder Löschen von ListView-Reihen/Spalten, oder zum Abrufen ihrer Daten.</td>
  </tr>
  <tr id="NumGet">
    <td><a href="commands/NumGet.htm">NumGet</a></td>
    <td>Gibt eine binäre Nummer zurück, die auf der angegebenen Adresse + Offset zu finden ist.</td>
  </tr>
  <tr id="NumPut">
    <td><a href="commands/NumPut.htm">NumPut</a></td>
    <td>Speichert eine binäre Nummer auf die angegebene Adresse + Offset.</td>
  </tr>
  <tr id="OnMessage">
    <td><a href="commands/OnMessage.htm">OnMessage</a></td>
    <td>Überwacht eine Nachricht/ein Ereignis.</td>
  </tr>
  <tr id="Ord">
    <td><a href="commands/Ord.htm">Ord</a></td>
    <td>Gibt den Ordinalwert (numerischen Zeichencode) des ersten Zeichens in der angegebenen Zeichenkette zurück.</td>
  </tr>
  <tr id="StrPutGet">
    <td><a href="commands/StrPutGet.htm">StrGet</a></td>
    <td>Kopiert eine Zeichenkette aus einer Speicheradresse unter Beachtung des angegebenen Zeichensatzes.</td>
  </tr>
  <tr id="StrPutGet">
    <td><a href="commands/StrPutGet.htm">StrPut</a></td>
    <td>Kopiert eine Zeichenkette auf eine Speicheradresse unter Beachtung des angegebenen Zeichensatzes.</td>
  </tr>
  <tr id="RegisterCallback">
    <td><a href="commands/RegisterCallback.htm">RegisterCallback</a></td>
    <td>Erstellt eine Maschinencode-Adresse, die, wenn sie aufgerufen wird, den Aufruf an eine Funktion im Skript weiterleitet.</td>
  </tr>
  <tr id="TreeView">
    <td><a href="commands/TreeView.htm#BuiltIn">TreeView</a></td>
    <td>Funktionen zum Hinzufügen, Modifizieren oder Löschen von TreeView-Elementen, oder zum Abrufen ihrer Daten.</td>
  </tr>
  <tr id="Trim">
    <td><a href="commands/Trim.htm">Trim</a></td>
    <td>Entfernt Zeichen vom Anfang und/oder Ende einer Zeichenkette.</td>
  </tr>
  <tr id="VarSetCapacity">
    <td><a href="commands/VarSetCapacity.htm">VarSetCapacity</a></td>
    <td>Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei.</td>
  </tr>
</table>
<h3 id="Math">Mathematik</h3>
<table class="info">
  <tr>
    <th style="width:150px">Funktion</th>
    <th>Beschreibung</th>
  </tr>
  <tr id="Abs">
    <td><a href="commands/Math.htm#Abs">Abs</a></td>
    <td>Gibt den absoluten Wert von <em>Zahl</em> zurück.</td>
  </tr>
  <tr id="Ceil">
    <td><a href="commands/Math.htm#Ceil">Ceil</a></td>
    <td>Gibt <em>Zahl</em> zurück, welche auf den nächsten Integer aufgerundet ist (ohne .00-Suffix).</td>
  </tr>
  <tr id="Exp">
    <td><a href="commands/Math.htm#Exp">Exp</a></td>
    <td>Gibt <em>e</em> zurück (ungefähr 2.71828182845905), potenziert mit <em>N</em>.</td>
  </tr>
  <tr id="Floor">
    <td><a href="commands/Math.htm#Floor">Floor</a></td>
    <td>Gibt <em>Zahl</em> zurück, welche auf den nächsten Integer abgerundet ist (ohne .00-Suffix).</td>
  </tr>
  <tr id="Log">
    <td><a href="commands/Math.htm#Log">Log</a></td>
    <td>Gibt den Logarithmus (Basis 10) von <em>Zahl</em> zurück.</td>
  </tr>
  <tr id="Ln">
    <td><a href="commands/Math.htm#Ln">Ln</a></td>
    <td>Ermittelt den Logarithmus (Basis e) von <em>Zahl</em>.</td>
  </tr>
  <tr id="Mod">
    <td><a href="commands/Math.htm#Mod">Mod</a></td>
    <td>Gibt den Rest zurück, wenn <em>Dividend</em> durch <em>Divisor</em> geteilt wird.</td>
  </tr>
  <tr id="Round">
    <td><a href="commands/Math.htm#Round">Round</a></td>
    <td>Gibt <em>Zahl</em> zurück, welche auf <em>N</em> Dezimalstellen gerundet ist.</td>
  </tr>
  <tr id="Sqrt">
    <td><a href="commands/Math.htm#Sqrt">Sqrt</a></td>
    <td>Gibt die Quadratwurzel von <em>Zahl</em> zurück.</td>
  </tr>
  <tr>
    <td><span id="Sin"></span><span id="Cos"></span><span id="Tan"></span><a href="commands/Math.htm#Sin">Sin</a> / <a href="commands/Math.htm#Cos">Cos</a> / <a href="commands/Math.htm#Tan">Tan</a></td>
    <td>Gibt den trigonometrischen Sinus/Kosinus/Tangens von <em>Zahl</em> zurück.</td>
  </tr>
  <tr>
    <td><span id="ASin"></span><span id="ACos"></span><span id="ATan"></span><a href="commands/Math.htm#ASin">ASin</a> / <a href="commands/Math.htm#ACos">ACos</a> / <a href="commands/Math.htm#ATan">ATan</a></td>
    <td>Gibt den Arkussinus/Arkuskosinus/Arkustangens als Bogenmaß zurück.</td>
  </tr>
</table>
<h3>Sonstige Funktionen</h3>
<p><a href="https://github.com/polyethene/AutoHotkey-Scripts/blob/master/Functions.ahk">Befehlsfunktionen von Polyethene</a>: Bietet für jeden AutoHotkey-Befehl, der eine Ausgabevariable hat, eine aufrufbare Funktion. Diese Library kann per <a href="commands/_Include.htm">#Include</a> in jedem Skript eingefügt werden.</p>
</body>
</html>
