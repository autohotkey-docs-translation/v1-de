<!DOCTYPE HTML>
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Rückgabewerte an den Aufrufer</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion</a></li>
  <li><a href="#ShortCircuit">Logische Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Verwenden von Subroutinen innerhalb einer Funktion</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</a></li>
  <li><a href="#lib">Libraries mit Funktionen: Standard- und Benutzer-Library</a></li>
  <li><a href="#BuiltIn">Built-in-Funktionen</a></li>
</ul>
<h2 id="intro">Einführung und einfache Beispiele</h2>
<p id="define">Eine Funktion ist prinzipiell das gleiche wie eine Subroutine (<a href="commands/Gosub.htm">GoSub</a>), außer dass sie Parameter (Eingabewerte) von ihrem Aufrufer entgegennehmen kann. Darüber hinaus kann eine Funktion optional einen Wert an den Aufrufer zurückgeben. Das folgende Beispiel zeigt, wie eine einfache Funktion zwei Zahlen entgegennimmt und deren Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
<p>So etwas nennt man auch eine <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (Groß- und Kleinschreibung ist egal) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, speichert man ihr Ergebnis mithilfe des <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operators</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) in eine Variable. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Man kann eine Funktion auch aufrufen, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)</pre>
<p>In diesem Fall aber wird der zurückgegebene Wert der Funktion verworfen; wenn die Funktion nur einen Rückgabewert erzeugen würde, wäre ihr Aufruf daher sinnlos.</p>
<p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten Variablennamen in ihrer Parameterliste nicht von Prozentzeichen umschlossen sein. Dagegen sollten literale Zeichenketten in Anführungszeichen gesetzt werden. Zum Beispiel:</p>
<pre>if <a href="#InStr">InStr</a>(MeineVar, "Fuchs")
    MsgBox Die Variable MeineVar enthält das Wort Fuchs.</pre>
<p>Desweiteren kann man Funktionen innerhalb der Parameter eines Befehls aufrufen (außer in EingabeVar und AusgabeVar-Parametern, wie die von <a href="commands/StringLen.htm">StringLen</a>). Allerdings müssen Parameter, die keine <a href="Variables.htm#Expressions">Ausdrücke</a> unterstützen, den "%"-Präfix wie folgt verwenden:</p>
<pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
<p>Das "%"-Präfix kann auch in Parametern verwendet werden, die bereits Ausdrücke unterstützen, aber es wird einfach ignoriert.</p>
<h2 id="param">Parameter</h2>
<p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in Klammern aufgelistet (Leerzeichen zwischen dem Namen und der öffnenden Klammer sind nicht erlaubt). Braucht die Funktion keine Parameter, können die Klammern leer gelassen werden; zum Beispiel: <code>ErmittleAktuellenZeitstempel()</code>.</p>
<p id="ByRef"><strong>ByRef-Parameter</strong>: Innerhalb der Funktion werden Parameter grundsätzlich wie <a href="#Locals">lokale Variablen</a> behandelt, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Das Benutzen von <em>ByRef</em> bewirkt, dass die angegebene Variable mit dem Parameter verbunden wird. Das heißt, dass der Parameter und die Variable des Aufrufers auf den gleichen Inhalt im Arbeitsspeicher verweisen. Auf diese Weise kann die Tauschen-Funktion die Variablen des Aufrufers ändern, indem sie den Inhalt der <em>Links</em>-Variable in die <em>Rechts</em>-Variable verschiebt, und umgekehrt.</p>
<p>Würde man <em>ByRef</em> hingegen nicht verwenden, wären <em>Links</em> und <em>Rechts</em> nur Kopien der Variablen des Aufrufers - die Tauschen-Funktion hätte keine externe Auswirkung.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zurückgeben kann, ist <em>ByRef</em> gut dafür geeignet, zusätzliche Ergebnisse zurückzugeben. Bringe den Aufrufer einfach dazu, eine Variable zu übergeben (üblicherweise leer), in der die Funktion einen Wert speichern kann.</p>
<p>Beim Übergeben langer Zeichenketten an eine Funktion ist <em>ByRef</em> leistungsfähiger und außerdem platzsparend, weil keine Kopie der Zeichenkette gemacht werden muss. Ebenso ist <em>ByRef</em>, wenn man eine lange Zeichenkette an den Aufrufer zurücksenden will, leistungsfähiger als <code>Return LangeZeichenkette</code>.</p>
<p><span class="ver">[AHK_L 60+]:</span> Übergibt man etwas anderes als eine veränderbare Variable an einen ByRef-Parameter, verhält sich die Funktion so, als wäre das Schlüsselwort "ByRef" nicht vorhanden. Zum Beispiel würde <code>Tauschen(A_Index, i)</code> den Wert von <i>A_Index</i> in <i>i</i> speichern, aber den gespeicherten Wert in <i>Links</i> verwerfen, sobald die <i>Tauschen</i>-Funktion fertig ist.</p>
<p><span class="ver">[v1.1.01+]:</span> Mit der <a href="#IsByRef">IsByRef()</a>-Funktion kann festgestellt werden, ob der Aufrufer eine Variable für einen bestimmten ByRef-Parameter bereitgestellt hat.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Objektfelder werden nicht als Variablen behandelt, wenn sie mit <em>ByRef</em> verwendet werden. Übergibt man beispielsweise <code>foo.bar</code> an einen ByRef-Parameter, wird <em>ByRef</em> einfach ignoriert.</li>
  <li>Es ist nicht möglich, die <a href="misc/Clipboard.htm">Zwischenablage</a>, <a href="Variables.htm#BuiltIn">Built-in-Variablen</a> oder <a href="Variables.htm#env">Umgebungsvariablen</a> an einen <em>ByRef</em>-Parameter einer Funktion zu übergeben, egal ob <a href="commands/_NoEnv.htm">#NoEnv</a> im Skript vorhanden ist oder nicht.</li>
  <li id="recurse">Theoretisch kann eine Funktion sich selbst rekursiv aufrufen. Wenn sie sich jedoch selbst ihre eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter per <em>ByRef</em> übergibt, wird der <em>ByRef</em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit selben Namen verweisen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter übergibt.</li>
  <li>Wenn ein Parameter bei einem Funktionsaufruf in eine Variable aufgelöst wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), können andere Parameter auf der linken oder rechten Seite diese Variable ändern, bevor sie an die Funktion übergeben wird. Zum Beispiel würde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 übergeben, wenn <em>Var</em> zu Beginn 0 ist, selbst wenn der erste Parameter der Funktion nicht als <em>ByRef</em> markiert ist. Da dieses Verhalten unlogisch ist, könnte es in einer zukünftigen Version geändert werden.</li>
  <li>ByRef werden nicht direkt in Funktionen unterstützt, die von COM-Clienten aufgerufen werden, oder beim Aufrufen von COM-Methoden. Stattdessen wird das Skript ein <a href="commands/ComObjActive.htm#ByRef">Wrapper-Objekt</a> übergeben müssen oder empfangen, das den <a href="commands/ComObjType.htm">VarTyp</a> und die Adresse des Wertes enthält.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Bei einer Funktionsdefinition können die Parameter als optional gekennzeichnet werden. Dazu muss ein Gleichheitszeichen (oder seit v1.1.09 <code>:=</code>) und ein Standardwert angefügt werden. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Addieren(X, Y, Z:=0) {
    return X + Y + Z
}</pre>
<p>Seit v1.1.09 wird sowohl <code>=</code> als auch <code>:=</code> unterstützt. Es wird empfohlen, die zweite Methode zu verwenden, um Widersprüche bei Ausdruckszuweisungen zu vermeiden und die Kompatibilität mit zukünftigen AutoHotkey-Versionen einzuhalten.</p>
<p>Übergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Wenn der Aufrufer aber nur <strong>zwei</strong> Parameter übergibt, wird in Z automatisch der Wert 0 gespeichert.</p>
<p id="missing">Es ist nicht möglich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das heißt, dass alle Parameter, die auf der rechten Seite des ersten optionalen Parameters vorkommen, auch als optional gekennzeichnet werden müssen. <span class="ver">[AHK_L 31+]:</span> Beim Aufrufen der Funktion können die optionale Parameter in der Mitte der Parameterliste weggelassen werden, wie unten gezeigt. Für dynamische Funktionsaufrufe und Methodenaufrufe wird v1.1.12+ benötigt.</p>
<pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p id="OptionalByRef">Seit v1.0.46.13 unterstützen <a href="#ByRef">ByRef-Parameter</a> auch Standardwerte; zum Beispiel: <code>Funktion(ByRef p1 = "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter weglässt, erstellt die Funktion eine lokale Variable, die den Standardwert enthält; das heißt, dass die Funktion sich so verhält, als würde das Schlüsselwort "ByRef" fehlen.</p>
<p>Als Standardwert eines Parameters sind folgende Werte zulässig: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Gleitkommazahl oder eine literale Zeichenkette wie "fox" oder "" (Zeichenketten unterstützen vor v1.0.46.13 nur "").</p>
<h2 id="return">Rückgabewerte an den Aufrufer</h2>
<p>Wie man bereits in der <a href="#intro">Einführung</a> lesen konnte, kann eine Funktion dazu gebracht werden, einen Wert per <a href="commands/Return.htm">Return</a> an ihren Aufrufer zurückzugeben.</p>
<pre>
Test := returnTest()
MsgBox % Test

returnTest() {
  return 123
}
</pre>
<p>Wenn noch mehr Ergebnisse von einer Funktion zurückgegeben werden sollen, kann man auch <a href="#ByRef">ByRef</a> verwenden:</p>
<pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
  val1 := "A"
  val2 := 100
  val3 := 1.1
  return
}
</pre>
<p><span class="ver">[v1.0.97+]:</span> Mithilfe von <a href="Objects.htm#Usage_Objects">Objekten</a> und <a href="Objects.htm#Usage_Simple_Arrays">Arrays</a> können mehrere Werte oder sogar benannte Werte zurückgegeben werden:</p>
<pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen <span class="ver">[AHK_L 60+]</span></h2>
<p>Bei einer Funktionsdefinition kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, so dass sie eine beliebige Anzahl an Parametern akzeptieren kann:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Ruft man eine variadische Funktion auf, sind überschüssige Parameter über ein Objekt zugreifbar, das im letzten Parameter der Funktion gespeichert ist. Der erste überschüssige Parameter ist <code><i>params</i>[1]</code>, der Zweite ist <code><i>params</i>[2]</code> und so weiter. Wie bei anderen Standardobjekten auch, kann <code><i>params</i>.MaxIndex()</code> verwendet werden, um den höchsten numerischen Index zu ermitteln (in diesem Fall die Parameteranzahl). Sind keine Parameter vorhanden, gibt MaxIndex jedoch eine leere Zeichenkette zurück.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann nur am Ende der formalen Parameterliste verwendet werden.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> können nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> übergeben überschüssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Während variadische Funktionen eine beliebige Parameteranzahl <i>akzeptieren</i> können, kann ein Array mit Parametern an <i>jede</i> Funktion durch Anwenden der gleichen Syntax beim Funktionsaufruf übergeben werden:</p>
<pre>Teilzeichenketten := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">Teilzeichenketten*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Die Nummerierung der Parameter beginnt innerhalb des Quell-Arrays bei 1.</li>
  <li>Optionale Parameter können im Array ganz weggelassen werden.</li>
  <li>Das Array mit Parametern kann benannte Elemente beim Aufrufen einer benutzerdefinierten Funktion enthalten; in allen anderen Fällen werden benannte Elemente nicht unterstützt.</li>
  <li>Die Zielfunktion kann auch variadisch sein - in diesem Fall werden benannte Elemente kopiert, selbst wenn sie keine entsprechenden formalen Parameter haben.</li>
  <li>Diese Syntax kann auch zum Aufrufen einer Methode oder zum Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>. Seit v1.1.12 kann sie auch zum Setzen von Eigenschaften verwendet werden.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterstützt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Es dürfen keine Leerraumzeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste vorkommen.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen</h2>
<h3>Lokale Variablen</h3>
<p>Alle Variablen, die innerhalb einer Funktion abgerufen oder erstellt werden, sind standardmäßig <em>lokal</em> (außer <a href="#SuperGlobal">superglobale</a> Variablen und Built-in-Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Die Inhalte der lokalen Variablen sind nur für Zeilen innerhalb der Funktion sichtbar. Daher kann eine lokale Variable den gleichen Namen haben wie eine globale Variable, aber mit unterschiedlichem Inhalt. Alle lokalen Variablen sind zu Beginn leer, und das jedes Mal, wenn die Funktion aufgerufen wird.</p>
<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor man sie verwendet. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    global LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert außerhalb dieser Funktion zugewiesen.</em>
    FileAppend, %TextZuLog%`n, %LogDateiname%
}</pre>
<p id="AssumeGlobal"><strong>Global-behandelnder Modus</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) global behandelt. Dazu muss in der ersten Zeile entweder das Wort "global" stehen oder die Deklaration einer lokalen Variable durchgeführt werden. Zum Beispiel:</p>
<pre>SetzeStandardwerte()
{
    global  <em>; Kann weggelassen werden, wenn die erste Zeile so etwas wie "local MeineVar" ist.</em>
    MeineGlobal := 33  <em>; Speichert 33 in eine globale Variable und erstellt sie, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen müssen in diesem Modus deklariert werden, weil sie sonst global behandelt werden.</em>
}</pre>
<p>Dieser global-behandelnde Modus kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Array</a> zu erstellen - wie bei einer Schleife, die Werte per <code>Array%A_Index%</code> zuweist.</p>
<p id="SuperGlobal"><strong>Superglobale Variablen</strong> <span class="ver">[v1.1.05+]:</span> Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen. Dadurch wird verhindert, dass die Variablen jedes Mal in einer Funktion neu deklariert werden müssen. Funktionsparameter oder lokale Variablen mit gleichem Namen haben Vorrang vor der globalen Variable. Variablen, die mit dem Schlüsselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind im Prinzip immer lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl = 0
    Zeilenanzahl += 1  <em>; Behandelt einen Zähler lokal (der Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend, %Zeilenanzahl%: %TextZuLog%`n, %LogDateiname%
}</pre>
<p id="InitStatic"><strong>Statische Initialisierungen</strong>: In den Versionen vor v1.0.46 enthielten alle statischen Variablen zu Beginn einen leeren Wert; das erstmalige Verwenden solcher Variablen konnte nur erkannt werden, wenn sie überprüft wurden, ob sie leer sind. Seit v1.0.46 können statische Variablen mit einem beliebigen Wert initialisiert werden (vorher war nur <code>""</code> möglich), wenn <code>:=</code> oder <code>=</code> gefolgt von einem folgenden Wert angefügt wird: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Gleitkommazahl oder eine literale Zeichenkette wie <code>"fox"</code>. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Jede statische Variable wird nur einmal initialisiert (bevor das Skript seine Ausführung beginnt).</p>
<p><span class="ver">[AHK_L 58+]:</span> <code>Static Var := Ausdruck</code> wird unterstützt. Solche Ausdrücke werden unmittelbar vor dem automatischen Ausführungsbereich ausgewertet - in der Reihenfolge, wie sie im Skript vorkommen.</p>
<p id="AssumeStatic"><strong>Statisch-behandelnder Modus</strong> <span class="ver">[v1.0.48+]:</span> Eine Funktion kann so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) statisch behandelt. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
<pre>ErmittleVomStatischenArray(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird nur einmal ausgeführt (beim Start).</em>
    if ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    return StatischesArray%Elementnummer%
}</pre>
<p>Im statisch-behandelnden Modus muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Es ist möglich, mehrere Variablen auf der gleichen Zeile zu deklarieren, wenn sie wie folgt durch Kommas getrennt werden:</p>
<pre>global LogDateiname, MaxVersuche := 5
static GesamtVersuche = 0, VorherErgebnis</pre>
<p id="DeclareInit">Seit v1.0.46 kann eine lokale oder globale Variable auf der gleichen Zeile als Deklaration initialisiert werden, wenn ein <code>:=</code> oder <code>=</code> gefolgt von einem <a href="Variables.htm#Expressions">Ausdruck</a> angefügt wird (in Deklarationen verhält sich der Operator <code>=</code> wie <code>:=</code>). Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgeführt, sofern sie von der Ablaufsteuerung erreicht werden. Das heißt, dass eine Zeile wie <code>local x = 0</code> den gleichen Effekt hat wie die zwei folgenden Zeilen: <code>local x</code>, gefolgt von <code>x = 0</code>.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Starten des Skripts verarbeitet werden, kann eine Variable nicht bedingt per <a href="commands/IfExpression.htm">IF-Anweisung</a> deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> bedingungslos für alle Zeilen zwischen der Deklaration und der schließenden Funktionsklammer wirksam wird. Beachte zudem, dass es zurzeit nicht möglich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>
<p id="PseudoArrays">Bei Befehlen, die <a href="misc/Arrays.htm">Pseudo-Arrays</a> erstellen (z. B. <a href="commands/StringSplit.htm">StringSplit</a>), ist jede Variable im resultierenden Pseudo-Array lokal, solange der <a href="#AssumeGlobal">global-behandelnder Modus</a> nicht aktiv ist oder das erste Pseudo-Array-Element als lokale Variable deklariert wurde (das gilt auch bei der Übergabe eines Funktionsparameters, selbst wenn dieser Parameter ein <a href="#ByRef">ByRef</a> ist, da Parameter prinzipiell das gleiche sind wie lokale Variablen). Wurde das erste Element hingegen <a href="#Global">global deklariert</a>, wird ein globales Array erstellt. Allerdings gilt die unten genannte <i>Oft auftretende Verwechslungsgefahr</i> auch in solchen Fällen. Das erste Element bei <a href="commands/StringSplit.htm">StringSplit</a> ist ArrayName0. Bei anderen array-erstellenden Befehlen wie <a href="commands/WinGet.htm">WinGet List</a> ist das erste Element ArrayName (also ohne die Nummer).</p>
<p id="DynVar"><span id="Dynamic"></span>Innerhalb einer Funktion wird jeder dynamische Variablenverweis wie <code>Array%i%</code> immer in eine lokale Variable aufgelöst. Wenn aber eine Variable mit diesem Namen nicht vorhanden ist, wird eine globale Variable verwendet, falls vorhanden. Wenn sie weder existiert noch bei ihrer Verwendung die Variable erstellt werden muss, wird sie als lokale Variable erstellt, solange der <a href="#AssumeGlobal">global-behandelnder Modus</a> nicht aktiv ist. Daher kann eine Funktion ein globales <a href="misc/Arrays.htm">Array</a> nur manuell erstellen (z. B. mithilfe von <code>Array%i% := A_Index</code>), wenn in der Funktion der <a href="#AssumeGlobal">global-behandelnder Modus</a> definiert wurde.</p>
<p id="ArrayConfusion"><strong>Oft auftretende Verwechslungsgefahr</strong>: Jeder <em>nicht</em>-dynamische Verweis auf eine Variable erstellt diese Variable in dem Moment, wo das Skript gestartet wird. Zum Beispiel: Außerhalb einer Funktion würde <code>MsgBox %Array1%</code> die Array1-Variable als globale Variable erstellen, in dem Moment, wo das Skript gestartet wird. Innerhalb einer Funktion würde <code>MsgBox %Array1%</code> die Array1-Variable als lokale Variable erstellen, in dem Moment, wo das Skript gestartet wird (solange der <a href="#AssumeGlobal">global-behandelnder Modus</a> nicht aktiv ist), selbst wenn Array und Array0 als global deklariert sind.</p>
<h2 id="DynCall">Dynamisches Aufrufen einer Funktion</h2>
<p>Seit v1.0.47.06 kann eine Funktion (auch eine <a href="#BuiltIn">Built-in-Funktion</a>) mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel würde <code>%Var%(x, "Fuchs")</code> die Funktion aufrufen, deren Name in <em>Var</em> enthalten ist. Ebenso würde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abhängig vom aktuellen Wert in A_Index.</p>
<p>Seit v1.1.07.00 kann <em>Var</em> in <code>%Var%()</code> einen Funktionsnamen, <a href="objects/Func.htm">Funktionsverweis</a> oder ein <a href="Objects.htm#Objects_as_Functions">Funktion-nachahmendes Objekt</a> enthalten. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen.</p>
<p>Kann die Funktion aufgrund einer der unten genannten Gründe nicht aufgerufen werden, stoppt die Auswertung des Ausdrucks, der den Aufruf enthält, vorzeitig ohne Meldung, was zu widersprüchlichen Ergebnissen führen könnte:</p>
<ul>
  <li>Aufrufen einer nicht-existierenden Funktion, das mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">Built-in-Funktionen</a>) muss explizit im Skript vorkommen (zum Beispiel über <a href="commands/_Include.htm">#Include</a> oder einem nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>).</li>
  <li>Übergeben von zu wenigen Parametern, das verhindert werden kann, wenn der Rückgabewert von <a href="#IsFunc">IsFunc()</a> überprüft wird (das ist die Anzahl der Pflichtparameter plus 1). Hinweis: Seit v1.0.48 wird das Übergeben von zu vielen Parametern toleriert; jeder zusätzliche Parameter wird vollständig ausgewertet (einschließlich aller Funktionsaufrufe) und dann verworfen.</li>
</ul>
<p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="ShortCircuit">Logische Kurzschlussauswertung</h2>
<p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, schließen sie sich kurz, um die Performance zu erhöhen (egal ob Funktionsaufrufe vorhanden sind oder nicht). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Im folgenden Beispiel wird gezeigt, wie genau das funktioniert:</p>
<pre>if (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
<p>Wenn die <em>FarbName</em>-Variable leer sein sollte, wird die FindeFarbe()-Funktion niemals aufgerufen, weil die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass Nebeneffekte von einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachte außerdem, dass die Kurzschlussauswertung verschachtelte <em>AND</em>s und <em>OR</em>s stufenweise durchgeht. Im Ausdruck des folgenden Beispiels würde nur der Vergleich ganz links erfolgen, wann immer <em>FarbName</em> leer ist, weil die linke Seite dann ausreichen würde, um das Endergebnis mit Sicherheit zu bestimmen:</p>
<pre>if (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie die Beispiele oben zeigen, sollten lange (zeitaufwendige) Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erhöhen. Diese Technik kann auch dazu genutzt werden, das Aufrufen einer Funktion zu verhindern, wenn ein ungeeigneter Wert (z. B. eine leere Zeichenkette) an einen ihrer Parameter übergeben wird.</p>
<p>Seit v1.0.46 erfolgt beim <a href="Variables.htm#ternary">ternären Bedingungsoperator (?:)</a> auch eine Kurzschließung durch Ignorieren der verlierenden Abzweigung.</p>
<h2 id="gosub">Verwenden von Subroutinen innerhalb einer Funktion</h2>
<p>Eine Funktion kann keine <a href="#define">Definitionen</a> von anderen Funktionen enthalten. Subroutinen sind aber möglich. Sie können, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> gestartet und per <a href="commands/Return.htm">Return</a> beendet werden (in diesem Fall gilt das Return nicht für die Funktion, sondern für das GoSub).</p>
<p>Bekannte Einschränkung: Momentan darf der Name jeder Subroutine (Label) nur einmal im ganzen Skript vorkommen. Beim Starten des Programms wird eine Fehlermeldung angezeigt, wenn Labels doppelt vorkommen.</p>
<p id="GosubPublic">Verwendet eine Funktion das <a href="commands/Gosub.htm">GoSub</a>, um zu einer öffentlichen Subroutine zu springen (die sich außerhalb der Funktionsklammern befindet), sind alle Variablen außerhalb global und die funktions-eigenen <a href="#Locals">lokalen Variablen</a> nicht abrufbar, bis die Subroutine ihr Return erreicht hat. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
<p>Das <a href="commands/Goto.htm">Goto</a> kann nicht verwendet werden, um vom Inneren der Funktion nach außen zu springen. Allerdings kann eine Funktion per <a href="commands/Gosub.htm">GoSub</a> zu einer externen/öffentlichen Subroutine springen und von dort aus per Goto weiterspringen.</p>
<p>In der Regel sollte man auf <a href="commands/Goto.htm">Goto</a> verzichten. Dieser Befehl kann aber innerhalb einer Funktion nützlich sein, wo man auf eine andere Position springen muss. Diese Methode kann helfen, komplexe Funktionen zu vereinfachen, die mehrere Rückgabepunkte haben, bei denen zuvor einige Säuberungsaktionen durchgeführt werden müssen.</p>
<p>Eine Funktion kann extern-aufrufende Subroutinen wie <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Menüpunkte</a> enthalten. Dies ist eine übliche Vorgehensweise, um sie in eine separate Datei zu packen und später via <a href="commands/_Include.htm">#Include</a> bereitzustellen, so dass sie den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> des Skripts nicht stören können. Allerdings gelten folgende Einschränkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), wenn ihre Funktionen normal aufgerufen werden, weil ein Subroutinen-<a href="misc/Threads.htm">Thread</a>, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage wäre, die Werte von lokalen Variablen zu ändern, wie sie vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zurückkehrt, werden all ihre lokale Variablen leer gemacht, um deren Speicher freizugeben.</li>
  <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) als <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
  <li>Wenn eine Funktion von einem Subroutinen-<a href="misc/Threads.htm">Thread</a> betreten wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschließlich array-erstellende Befehle).</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Erreicht der Ausführungsablauf innerhalb einer Funktion die schließende Funktionsklammer, ohne auf ein <a href="commands/Return.htm">Return</a> gestoßen zu sein, endet die Funktion und gibt ihren Aufrufer eine leere Zeichenkette zurück. Ein leerer Wert wird auch zurückgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> explizit fehlt.</p>
<p>Wenn eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> mit dem <a href="commands/Exit.htm">Exit</a>-Befehl terminiert, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Zum Beispiel: Die Anweisung <code>Var := Addieren(2, 3)</code> würde <code>Var</code> unverändert belassen, wenn <code>Add()</code> per Exit beendet wird. Das gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausführen</a> einer nicht-existierenden Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> ändern, um einen zusätzlichen Wert zurückzugeben, der sich leicht merken lässt.</p>
<p>Um eine Funktion mit einer oder mehreren leeren Zeichenketten aufzurufen, verwende zwei Anführungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
<p>Da das Aufrufen einer Funktion keinen neuen <a href="misc/Threads.htm">Thread</a> startet, werden von der Funktion geänderten Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer wirksam.</p>
<p>Der Aufrufer einer Funktion kann nicht-existierende Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente an ihr übergeben, was nützlich für Funktionen ist, die den entsprechenden Parameter als <a href="#ByRef">ByRef</a> erwarten. Ruft man beispielsweise <code>ErmittleNächsteZeile(LeeresArray%i%)</code> auf, wird die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellt (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">global-behandelnder Modus</a> wirksam ist).</p>
<p>Wenn <a href="commands/ListVars.htm">ListVars</a> in einer Funktion verwendet wird, werden ihre <a href="#Locals">lokalen Variablen</a> und deren Inhalte angezeigt. Diese Sache kann dabei helfen, ein Skript zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Man könnte komplexe Funktionen als besser lesbar und verwaltbar empfinden, wenn deren Variablen eindeutige Präfixe angefügt werden. Durch Hinzufügen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    return x + y
<strong>}</strong></pre>
<h2 id="include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Skripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
<p>Erklärung: Erreicht der Ausführungsablauf des Skripts eine Funktionsdefinition, wird er sie sofort überspringen und seine Ausführung bei der Zeile nach der schließenden Klammer fortsetzen. Daraus folgt, dass die Ausführung nie in eine Funktion geraten kann, oder dass das Vorhandensein von einer oder mehreren Funktionen am Anfang des Skripts den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> beeinflussen könnten.</p>
<h2 id="lib">Libraries mit Funktionen: Standard- und Benutzer-Library <span class="ver">[v1.0.47+]</span></h2>
<p>Ein Skript kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> verwenden zu müssen. Damit dies funktioniert, muss eine Datei, die den gleichen Namen hat wie die Funktion, in einem der folgenden Library-Verzeichnissen vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Lokale Library - benötigt <span class="ver">AHK_L 42+</span>.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; Benutzer-Library.</em>
Pfad-zur-gerade-laufenden-AutoHotkey.exe\Lib\  <em>; Standard-Library.</em></pre>
<p>Ruft ein Skript beispielsweise die nicht-existierende Funktion <code>MeineFunktion()</code> auf, sucht das Programm nach einer Datei namens "MeineFunktion.ahk" in der Benutzer-Library. Wenn sie dort nicht gefunden werden kann, wird die Standard-Library durchsucht. Ergibt die Suche weiterhin keine Treffer und enthält der Funktionsname einen Unterstrich (z. B. <code>MeinPräfix_MeineFunktion</code>), sucht das Programm in beiden Libraries nach einer Datei namens <code>MeinPräfix.ahk</code> und lädt sie, falls sie existiert. Auf diese Weise kann <code>MeinPräfix.ahk</code> sowohl die Funktion <code>MeinPräfix_MeineFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>MeinPräfix_</code> beginnen.</p>
<p><span class="ver">[AHK_L 42+]:</span> Es kann nun die lokale Library verwendet werden, die durchsucht wird, bevor die Benutzer- und Standard-Library durchsucht werden.</p>
<p>Nur ein direkter Funktionsaufruf wie <code>MeineFunk()</code> kann eine Library automatisch einfügen lassen. Wenn die Funktion nur dynamisch oder indirekt aufgerufen wird, z. B. via Timer oder GUI-Ereignis, dann muss die Library explizit in das Skript eingefügt werden. Zum Beispiel: <code><a href="commands/_Include.htm">#Include</a> &lt;MeineFunk&gt;</code></p>
<p>In der Regel enthält eine Library-Datei nur eine einzelne Funktion, die den gleichen Namen hat wie die Datei. Sie kann aber auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum zur Verfügung stehen; das heißt, dass sie von überall im Skript aufgerufen werden können.</p>
<p>Verwendet eine Library-Datei <a href="commands/_Include.htm">#Include</a>, gilt als Arbeitsverzeichnis für #Include das Verzeichnis der Library-Datei. Der Vorteil davon ist, dass eine Weiterleitung zu einer größeren Library-Datei erstellt werden kann, die diese Funktion und andere dazugehörige Funktionen enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Skript-Compiler (ahk2exe)</a> unterstützt auch Library-Funktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Wenn AutoHotkey.exe dort nicht vorhanden, wird der Compiler zwar weiterhin funktionieren, aber die Library-Funktionen werden nicht mehr automatisch eingefügt.</p>
<p>Funktionen, die auf diese Weise eingefügt werden, haben die gleiche Performance wie andere Funktionen, weil sie geladen werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="BuiltIn">Built-in-Funktionen</h2>
<p>Jeder optionale Parameter, der am Ende der Parameterliste einer Built-in-Funktion vorkommt, kann komplett weggelassen werden. Zum Beispiel könnte man <code>WinExist("Unbenannt - Editor")</code> angeben, weil die Funktion ihre anderen drei Parameter als leere Werte ansieht.</p>
<p>Eine Built-in-Funktion wird überschrieben, wenn das Skript seine eigene Funktion mit dem gleichen Namen definieren würde. Zum Beispiel könnte man anstelle der normalen WinExist()-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können per <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
<h3>Häufig verwendete Funktionen</h3>
<p id="FileExist"><strong>FileExist(Dateimuster)</strong>: Gibt eine leere Zeichenkette zurück, wenn <em>Dateimuster</em> nicht existiert (<em>Dateimuster</em> befindet sich im <a href="Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist). Ansonsten wird eine <a href="commands/FileGetAttrib.htm#attrib">Zeichenkette mit Attributen</a> (eine Teilmenge von "RASHNDOCT") von der ersten gefundenen Datei oder des ersten gefundenen Ordners zurückgegeben. Hat die Datei keine Attribute (was sehr selten ist), wird "X" zurückgegeben. <em>Dateimuster</em> kann der exakte Name einer Datei oder eines Ordners sein, oder Platzhalter (* oder ?) enthalten. Da eine leere Zeichenkette als "falsch" angesehen wird, kann der Rückgabewert der Funktion immer als logischer Scheinwert verwendet werden. Zum Beispiel würde die Anweisung <code>if FileExist("C:\Meine Datei.txt")</code> als wahr angesehen werden, wenn die Datei vorhanden ist. Ebenso würde die Anweisung <code>if InStr(FileExist("C:\Meine Ordner"), "D")</code> nur als wahr angesehen werden, wenn die Datei existiert <em>und</em> ein Verzeichnis ist. Dazugehörige Befehle: <a href="commands/IfExist.htm">IfExist</a> und <a href="commands/FileGetAttrib.htm">FileGetAttrib</a>.</p>
<p id="GetKeyState"><strong>GetKeyState(<a href="KeyList.htm">Tastenname</a> [, "P"</strong> oder <strong>"T"])</strong>: Im Gegensatz zum <a href="commands/GetKeyState.htm">GetKeyState-Befehl</a> (der D für unten und U für oben zurückgibt) wird diese Funktion True (1) zurückgeben, wenn die Taste unten ist, und False (0), wenn sie oben ist. Ist der <em><a href="KeyList.htm">Tastenname</a></em> ungültig, wird eine leere Zeichenkette zurückgegeben. Siehe <a href="commands/GetKeyState.htm">GetKeyState</a> für weitere Rückgabewerte und zusätzliche Informationen zur Verwendung.</p>
<p id="InStr"><strong>InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</strong>: Gibt die Position der Zeichenkette <em>Nadel</em> zurück, die in der Zeichenkette <em>Heuhaufen</em> vorkommt. Siehe <a href="commands/InStr.htm">InStr()</a> für Details.</p>
<p><strong>RegExMatch(Heuhaufen, NadelRegEx [, AusgabeVar = "", Startposition = 1])</strong>: Überprüft, ob ein Muster (regulärer Ausdruck) in einer Zeichenkette vorkommt. Siehe <a href="commands/RegExMatch.htm">RegExMatch()</a> für Details.</p>
<p><strong>RegExReplace(Heuhaufen, NadelRegEx [, Ersatz = "", AusgabeVarAnzahl = "", Limit = -1, Startposition = 1])</strong>: Ersetzt Vorkommen eines Musters (regulärer Ausdruck) innerhalb einer Zeichenkette. Siehe <a href="commands/RegExReplace.htm">RegExReplace()</a> für Details.</p>
<p id="SubStr"><strong>SubStr(Zeichenkette, Startposition [, Länge])</strong> <span class="ver">[v1.0.46+]:</span> Ermittelt ein oder mehrere Zeichen von der angegebenen Position innerhalb einer Zeichenkette. Siehe <a href="commands/SubStr.htm">SubStr()</a> für Details.</p>
<p id="StrLen"><strong>StrLen(Zeichenkette)</strong>: Gibt die Länge der <em>Zeichenkette</em> zurück. Siehe <a href="commands/StringLen.htm">StrLen()</a> für Details.</p>
<p id="StrSplit"><strong>StrSplit(Zeichenkette [, Trennzeichen, ZuEntfernendeZeichen])</strong> <span class="ver">[v1.1.13+]:</span> Teilt eine Zeichenkette in mehreren Zeichenketten auf, basierend auf die angegebenen Trennzeichen. Siehe <a href="commands/StringSplit.htm">StrSplit()</a> für Details.</p>
<p id="WinActive"><strong>WinActive([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des aktiven Fensters zurück, wenn es die angegebenen Kriterien erfüllt. Siehe <a href="commands/WinActive.htm">WinActive()</a> für Details.</p>
<p id="WinExist"><strong>WinExist([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des ersten übereinstimmenden Fensters zurück. Siehe <a href="commands/WinExist.htm">WinExist()</a> für Details.</p>
<h3>Verschiedene Funktionen</h3>
<p id="Asc"><strong>Asc(Zeichenkette)</strong>: Gibt den numerischen Wert des ersten Bytes oder der ersten UTF-16-Codeeinheit in der <em>Zeichenkette</em> zurück, oder 0, wenn die <em>Zeichenkette</em> leer ist. Der Rückgabewert liegt im Bereich von 0 bis 255 (bei ANSI) oder von 0 bis 0xFFFF (bei Unicode). Einzelheiten findest du unter <a href="Compat.htm#Format">Unicode vs ANSI</a>. Für Unicode-Ergänzungszeichen kannst du stattdessen <a href="#Ord">Ord(Zeichenkette)</a> verwenden.</p>
<p id="Chr"><strong>Chr(Nummer)</strong>: Gibt eine Zeichenkette zurück (üblicherweise ein einzelnes Zeichen), dessen Zeichencode mit der angegebenen <em>Nummer</em> übereinstimmt. Die Bedeutung der Zeichencodes größer als 127 hängt davon ab, welche <a href="Compat.htm#Format">Zeichenkettencodierung</a> verwendet wird, das wiederum davon abhängt, ob man mit einer <a href="Variables.htm#IsUnicode">Unicode- oder ANSI</a>-Datei das Skript ausführt. Wenn Unicode unterstützt wird, ist <em>Nummer</em> ein Unicode-Zeichencode zwischen 0 und 0x10FFFF (oder 0xFFFF vor <span class="ver">[v1.1.21]</span>); ansonsten ist sie ein ANSI-Zeichencode zwischen 0 und 255. Wenn <em>Nummer</em> nicht im gültigen Bereich der Zeichencodes liegt, wird eine leere Zeichenkette zurückgegeben. Häufig verwendete Zeichencodes sind 9 (Tabulator), 10 (LF), 13 (CR), 32 (Leerzeichen), 48-57 (die Zahlen von 0 bis 9), 65-90 (Großbuchstaben von A bis Z) und 97-122 (Kleinbuchstaben von a bis z).</p>
<p><strong>DllCall()</strong>: Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows. Siehe <a href="commands/DllCall.htm">DllCall()</a> für Details.</p>
<p><strong>FileOpen()</strong>: Ermöglicht eine objektorientierte Dateibearbeitung. Siehe <a href="commands/FileOpen.htm">FileOpen()</a> für Details.</p>
<p id="Func"><strong>Func(Funktionsname)</strong> <span class="ver">[v1.1.00+]:</span> Falls <em>Funktionsname</em> im Skript explizit nicht vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>), wird Func() eine 0 zurückgeben. Ansonsten wird der <a href="Objects.htm#Function_References">Verweis auf die Funktion</a> zurückgegeben. Das kann man verwenden, um die Funktion aufzurufen oder <a href="objects/Func.htm">Informationen</a> abzurufen, wie beispielsweise die minimale und maximale Anzahl an Parametern.</p>
<p id="GetKeyName"><strong>GetKeyName(Taste), GetKeyVK(Taste), GetKeySC(Taste)</strong> <span class="ver">[v1.1.01+]:</span> Ermittelt den Namen/Text, virtuellen Tastencode oder Scancode einer Taste. <em>Taste</em> kann ein VK oder SC-Code, wie z. B. "vkA2" oder "sc01D", eine Kombination von beiden oder ein Tastenname sein. Zum Beispiel wird sowohl <code>GetKeyName("vk1B")</code> als auch <code>GetKeyName("Esc")</code> "Escape" zurückgeben, während <code>GetKeyVK("Esc")</code> eine 27 zurückgibt. Beachte, dass VK und SC hexadezimal sein müssen. Um eine dezimale Nummer in das entsprechende Format umzuwandeln, verwende <code><a href="commands/Format.htm">Format</a>("vk{:x}", vk_code)</code> oder <code>Format("sc{:x}", sc_code)</code>.</p>
<p id="IsByRef"><strong>IsByRef(Var)</strong> <span class="ver">[v1.1.01+]:</span> Gibt eine 1 zurück, falls <em>Var</em> ein ByRef-Parameter ist und der Aufrufer eine Variable übergibt; oder 0, falls <em>Var</em> ein anderer Variablentyp ist.</p>
<p id="IsFunc"><strong>IsFunc(Funktionsname)</strong> <span class="ver">[v1.0.48+]:</span> Falls <em>Funktionsname</em> im Skript explizit nicht vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>), wird IsFunc() eine 0 zurückgeben. Ansonsten gibt sie die minimale Anzahl an Parametern zurück, addiert mit 1 (also 1 für eine Funktion ohne Parameter, 2 für eine Funktion mit einem Parameter und so weiter). Zum Beispiel würden die Anweisungen <code>if IsFunc("MeineFunktion")</code> und <code>if IsFunc(VariableMitFunktionsnamen)</code> als wahr angesehen werden, wenn die Funktion vorhanden ist. Seit v1.1.00 kann <i>Funktionsname</i> anstelle eines Namens auch ein Funktionsverweis sein. Siehe auch: <a href="#DynCall">Dynamischer Funktionsaufruf</a>, <a href="Variables.htm#ThisFunc">A_ThisFunc</a></p>
<p id="IsLabel"><strong>IsLabel(Labelname)</strong>: Gibt eine Zahl ungleich 0 zurück, wenn <em>Labelname</em> als <a href="commands/Gosub.htm">Subroutine</a>, <a href="Hotkeys.htm">Hotkey</a> oder <a href="Hotstrings.htm">Hotstring</a> im Skript vorkommt (<em>Labelname</em> muss ohne den Doppelpunkten angegeben werden). Zum Beispiel würde die Anweisung <code>if IsLabel(VariableMitLabelnamen)</code> als wahr angesehen werden, wenn das Label vorhanden ist. Das ist nützlich, um Laufzeitfehler zu unterdrücken, wenn man ein dynamisches Label in Befehlen wie <a href="commands/Gosub.htm">Gosub</a>, <a href="commands/Hotkey.htm">Hotkey</a>, <a href="commands/Menu.htm">Menu</a> und <a href="commands/Gui.htm">Gui</a> angibt. Siehe auch: <a href="misc/Labels.htm">Label</a>.</p>
<p id="IsObject"><strong>IsObject()</strong> <span class="ver">[AHK_L 31+]:</span> Erkennt, ob ein Wert ein Objekt ist. Siehe auch: <a href="Objects.htm">Objekte</a>.</p>
<p><strong>ListView- und TreeView-Funktionen</strong>: Siehe <a href="commands/ListView.htm">ListView</a> und <a href="commands/TreeView.htm">TreeView</a> für Details.</p>
<p id="NumGet"><strong>NumGet(VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: Gibt eine binäre Nummer zurück, die auf der angegebenen Adresse + Offset zu finden ist. Siehe <a href="commands/NumGet.htm">NumGet</a>, um mehr darüber zu erfahren.</p>
<p id="NumPut"><strong>NumPut(Nummer, VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: Speichert eine binäre Nummer auf die angegebene Adresse + Offset. Siehe <a href="commands/NumPut.htm">NumPut</a>, um mehr darüber zu erfahren.</p>
<p><strong>OnMessage(Nachrichtennummer [, "Funktionsname"])</strong>: Überwacht eine Nachricht/ein Ereignis. Siehe <a href="commands/OnMessage.htm">OnMessage()</a> für weitere Details.</p>
<p id="Ord"><strong>Ord(Zeichenkette)</strong> <span class="ver">[v1.1.21+]</span>: Gibt den Ordinalwert (numerischen Zeichencode) des ersten Zeichens in der <em>Zeichenkette</em> zurück. Wenn die <em>Zeichenkette</em> mit einem Unicode-Ergänzungszeichen beginnt, wird <em>Ord(Zeichenkette)</em> den entsprechenden Unicode-Zeichencode zurückgeben (eine Nummer zwischen 0x10000 und 0x10FFFF). Ansonsten gibt sie den gleichen Wert wie <a href="#Asc">Asc(Zeichenkette)</a> zurück.</p>
<p><strong>StrGet(Adresse [, Länge] [, Codierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert eine Zeichenkette von einer Speicheradresse und wandelt sie optional in verschiedene Zeichensätze um. Siehe <a href="commands/StrPutGet.htm">StrGet()</a> für weitere Details.</p>
<p><strong>StrPut(Zeichenkette, Adresse [, Länge] [, Codierung = Keine ] )</strong> <span class="ver">[AHK_L 46+]:</span> Kopiert eine Zeichenkette auf eine Speicheradresse und wandelt sie optional in verschiedene Zeichensätze um. Siehe <a href="commands/StrPutGet.htm">StrPut()</a> für weitere Details.</p>
<p><strong>RegisterCallback()</strong>: Erstellt eine Maschinencode-Adresse, die, wenn sie aufgerufen wird, den Aufruf an eine Funktion im Skript weiterleitet. Siehe <a href="commands/RegisterCallback.htm">RegisterCallback()</a> für Details.</p>
<p><strong>Trim()</strong> <span class="ver">[AHK_L 31+]:</span> Entfernt bestimmte Zeichen vom Anfang und/oder Ende einer Zeichenkette. Siehe <a href="commands/Trim.htm">Trim()</a> für Details.</p>
<p><strong>VarSetCapacity(VarName [, BenötigteKapazität, Füllbyte])</strong>: Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei. Siehe <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> für Details.</p>
<h3 id="Math">Allgemeine Mathematik</h3>
<p>Hinweis: Mathematische Funktionen geben generell einen leeren Wert (leere Zeichenkette) zurück, falls einer der eingehenden Parameter nicht numerisch ist.</p>
<p id="Abs"><strong>Abs(Zahl)</strong>: Gibt den absoluten Wert von <em>Zahl</em> zurück. Der Rückgabewert hat den gleichen Typ wie <em>Zahl</em> (Integer oder Gleitkommazahl).</p>
<p id="Ceil"><strong>Ceil(Zahl)</strong>: Gibt <em>Zahl</em> zurück, aufgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Ceil(1.2)</code> gleich 2 und <code>Ceil(-1.2)</code> gleich -1.</p>
<p id="Exp"><strong>Exp(N)</strong>: Gibt <em>e</em> zurück (ungefähr 2,71828182845905), potenziert mit <em>N</em>. Der Parameter <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Um neben <em>e</em> noch andere Zahlen zu potenzieren, verwende den <a href="Variables.htm#pow">**-Operator</a>.</p>
<p id="Floor"><strong>Floor(Zahl)</strong>: Gibt <em>Zahl</em> zurück, abgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Floor(1.2)</code> gleich 1 und <code>Floor(-1.2)</code> gleich -2.</p>
<p id="Log"><strong>Log(Zahl)</strong>: Gibt den Logarithmus (Basis 10) von <em>Zahl</em> zurück. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Gleitkommazahl</a>. Wenn <em>Zahl</em> negativ ist, wird eine leere Zeichenkette zurückgegeben.</p>
<p id="Ln"><strong>Ln(Zahl)</strong>: Ermittelt den Logarithmus (Basis e) von <em>Zahl</em>. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Gleitkommazahl</a>. Wenn <em>Zahl</em> negativ ist, wird eine leere Zeichenkette zurückgegeben.</p>
<p id="Mod"><strong>Mod(Dividend, Divisor)</strong>: Modulo. Gibt den Rest zurück, wenn der <em>Dividend</em> durch den <em>Divisor</em> geteilt wird. Das Vorzeichen des Ergebnisses entspricht dem Vorzeichen des ersten Parameters. Zum Beispiel sind <code>Mod(5, 3)</code> und <code>Mod(5, -3)</code> gleich 2, aber <code>Mod(-5, 3)</code> und <code>Mod(-5, -3)</code> gleich -2. Wenn einer der beiden Parameter eine Gleitkommazahl ist, wird das Ergebnis ebenfalls eine Gleitkommazahl sein. Zum Beispiel ist <code>Mod(5.0, 3)</code> gleich 2.0 und <code>Mod(5, 3.5)</code> gleich 1.5. Ist der zweite Parameter eine 0, gibt die Funktion ein leeres Ergebnis (leere Zeichenkette) zurück.</p>
<p id="Round"><strong>Round(Zahl [, N])</strong>: Ist <em>N</em> nicht vorhanden oder eine 0, wird <em>Zahl</em> auf den nächsten Integer gerundet. Ist <em>N</em> eine positive Zahl, wird <em>Zahl</em> auf <em>N</em> Dezimalstellen gerundet. Ist <em>N</em> negativ, wird <em>Zahl</em> auf <em>N</em> Stellen nach links gerundet. Zum Beispiel ist <code>Round(345, -1)</code> gleich 350 und <code>Round(345, -2)</code> gleich 300. Im Gegensatz zu <a href="commands/Transform.htm">Transform Round</a> hat das Ergebnis keinen .000-Suffix, wenn <em>N</em> weggelassen wird oder kleiner als 1 ist. Seit v1.0.44.01 zeigt ein Wert in <em>N</em>, der größer als 0 ist, genau <em>N</em> Dezimalstellen an, anstatt <a href="commands/SetFormat.htm">SetFormat</a> zu berücksichtigen. Man kann das verhindern, wenn man eine weitere mathematische Operation beim Rückgabewert von Round() durchführt; zum Beispiel: <code>Round(3.333, 1)<strong>+0</strong></code>.</p>
<p id="Sqrt"><strong>Sqrt(Zahl)</strong>: Gibt die Quadratwurzel von <em>Zahl</em> zurück. Das Ergebnis ist eine <a href="commands/SetFormat.htm">Gleitkommazahl</a>. Wenn <em>Zahl</em> negativ ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<h3>Trigonometrie</h3>
<p><strong id="Sin">Sin(Zahl)</strong> | <strong id="Cos">Cos(Zahl)</strong> | <strong id="Tan">Tan(Zahl)</strong>: Gibt den trigonometrischen Sinus|Kosinus|Tangens von <em>Zahl</em> zurück. <em>Zahl</em> muss als Bogenmaß angegeben werden.</p>
<p id="ASin"><strong>ASin(Zahl)</strong>: Gibt den Arkussinus (die Zahl, deren Sinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (leere Zeichenkette) zurück.</p>
<p id="ACos"><strong>ACos(Zahl)</strong>: Gibt den Arkuskosinus (die Zahl, deren Kosinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (leere Zeichenkette) zurück.</p>
<p id="ATan"><strong>ATan(Zahl)</strong>: Gibt den Arkustangens (die Zahl, deren Tangens <em>Zahl</em> ist) als Bogenmaß zurück.</p>
<p><strong>Hinweis</strong>: Soll Bogenmaß in Grad umgewandelt werden, multipliziere es mit 180/pi (ungefähr 57.29578). Um ein Grad-Wert in Bogenmaß umzuwandeln, kann es mit pi/180 (ungefähr 0.01745329252) multipliziert werden. Der Wert von pi (ungefähr 3.141592653589793) ist viermal der Arkustangens von 1.</p>
<h3>Sonstige Funktionen</h3>
<p><a href="https://github.com/polyethene/AutoHotkey-Scripts/blob/master/Functions.ahk">Befehlsfunktionen von Polyethene</a>: Bietet für jeden AutoHotkey-Befehl, der eine Ausgabevariable hat, eine aufrufbare Funktion. Diese Library kann per <a href="commands/_Include.htm">#Include</a> in jedem Skript eingefügt werden.</p>
</body>
</html>
